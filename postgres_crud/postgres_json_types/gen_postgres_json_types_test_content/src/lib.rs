#[allow(unused_qualifications)]
#[allow(clippy::absolute_paths)]
mod gen_postgres_json_types_mod {
    #[derive(Debug, Clone, Copy)]
    pub struct StdPrimitiveI8AsNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI8AsNotNullJsonbNumberOrigin(i8);
    impl StdPrimitiveI8AsNotNullJsonbNumberOrigin {
        #[must_use]
        pub const fn new(value: StdPrimitiveI8AsNotNullJsonbNumberReadInner) -> Self {
            Self(value)
        }
    }
    impl From<StdPrimitiveI8AsNotNullJsonbNumberCreate> for StdPrimitiveI8AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveI8AsNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<StdPrimitiveI8AsNotNullJsonbNumberUpdate> for StdPrimitiveI8AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveI8AsNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for StdPrimitiveI8AsNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveI8AsNotNullJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI8AsNotNullJsonbNumberOrigin {
        fn default_option_some_vec_one_el() -> Self {
            Self(Default::default())
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI8AsNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveI8AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveI8AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI8AsNotNullJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration(
        StdPrimitiveI8AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub const fn new(value: StdPrimitiveI8AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI8AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveI8AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveI8AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI8AsNotNullJsonbNumberCreate(StdPrimitiveI8AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveI8AsNotNullJsonbNumberCreate {
        #[must_use]
        pub const fn new(value: StdPrimitiveI8AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI8AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI8AsNotNullJsonbNumberCreate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveI8AsNotNullJsonbNumberCreateForQuery(
        StdPrimitiveI8AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveI8AsNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveI8AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI8AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI8AsNotNullJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI8AsNotNullJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveI8AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveI8AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<StdPrimitiveI8AsNotNullJsonbNumberCreate>
        for StdPrimitiveI8AsNotNullJsonbNumberCreateForQuery
    {
        fn from(value: StdPrimitiveI8AsNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI8AsNotNullJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI8AsNotNullJsonbNumberSelect {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for StdPrimitiveI8AsNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum StdPrimitiveI8AsNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        In(
            where_filters::PostgresJsonTypeWhereIn<
                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        GreaterThan(
            where_filters::PostgresJsonTypeWhereGreaterThan<
                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        Between(
            where_filters::PostgresJsonTypeWhereBetween<
                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for StdPrimitiveI8AsNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::In(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::Between(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::In(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::Between(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveI8AsNotNullJsonbNumberWhere {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for StdPrimitiveI8AsNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::In(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::GreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::Between(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI8AsNotNullJsonbNumberRead(StdPrimitiveI8AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveI8AsNotNullJsonbNumberRead {
        #[must_use]
        pub const fn new(value: StdPrimitiveI8AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI8AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI8AsNotNullJsonbNumberRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI8AsNotNullJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI8AsNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveI8AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveI8AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct StdPrimitiveI8AsNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type StdPrimitiveI8AsNotNullJsonbNumberReadInner = i8;
    impl From<StdPrimitiveI8AsNotNullJsonbNumberOrigin>
        for StdPrimitiveI8AsNotNullJsonbNumberReadInner
    {
        fn from(value: StdPrimitiveI8AsNotNullJsonbNumberOrigin) -> Self {
            value.0
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI8AsNotNullJsonbNumberUpdate(StdPrimitiveI8AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveI8AsNotNullJsonbNumberUpdate {
        #[must_use]
        pub const fn new(value: StdPrimitiveI8AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI8AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI8AsNotNullJsonbNumberUpdate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveI8AsNotNullJsonbNumberUpdateForQuery(
        StdPrimitiveI8AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveI8AsNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveI8AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI8AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<StdPrimitiveI8AsNotNullJsonbNumberUpdate>
        for StdPrimitiveI8AsNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: StdPrimitiveI8AsNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI8AsNotNullJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI8AsNotNullJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveI8AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveI8AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for StdPrimitiveI8AsNotNullJsonbNumber {
        type TableTypeDeclaration = StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration;
        type Create = StdPrimitiveI8AsNotNullJsonbNumberCreate;
        type CreateForQuery = StdPrimitiveI8AsNotNullJsonbNumberCreateForQuery;
        type Select = StdPrimitiveI8AsNotNullJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',({column_name_and_maybe_field_getter}->'{field_ident}')))"
            ))
        }
        type Where = StdPrimitiveI8AsNotNullJsonbNumberWhere;
        type Read = StdPrimitiveI8AsNotNullJsonbNumberRead;
        type ReadOnlyIds = StdPrimitiveI8AsNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = StdPrimitiveI8AsNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0
        }
        type Update = StdPrimitiveI8AsNotNullJsonbNumberUpdate;
        type UpdateForQuery = StdPrimitiveI8AsNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for StdPrimitiveI8AsNotNullJsonbNumber {
        type PostgresJsonType = Self;
        type Select = StdPrimitiveI8AsNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some(
                postgres_crud_common::std_primitive_i8_test_cases_vec()
                    .into_iter()
                    .map(<Self as postgres_crud_common::PostgresJsonType>::Create::new)
                    .collect(),
            )
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            vec![postgres_crud_common::std_primitive_i8_test_cases_vec().into()]
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: StdPrimitiveI8AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: StdPrimitiveI8AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            StdPrimitiveI8AsNotNullJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                StdPrimitiveI8AsNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            StdPrimitiveI8AsNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            StdPrimitiveI8AsNotNullJsonbNumberWhere::Equal(
                where_filters::PostgresJsonTypeWhereEqual {
                    logical_operator: postgres_crud_common::LogicalOperator::Or,
                    value: StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration::new(
                        create.0.into(),
                    ),
                },
            )
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            let value_7aa498e8 = create.0.0.checked_sub(1)?;
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveI8AsNotNullJsonbNumberWhere::GreaterThan(
                        where_filters::PostgresJsonTypeWhereGreaterThan {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration(
                                StdPrimitiveI8AsNotNullJsonbNumberOrigin(value_7aa498e8),
                            ),
                        },
                    ),
                ),
            ]) {
                Ok(value_6f3e23b5) => Some(value_6f3e23b5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("11287f54-f840-4076-a16b-1a59a74e6dee"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            if let (Some(start), Some(end)) = (create.0.0.checked_sub(1), create.0.0.checked_add(1))
            {
                match where_filters :: Between :: try_new (StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration :: new (start) , StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration :: new (end)) { Ok (value_cdde02cc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: SingleOrMultiple :: Single (StdPrimitiveI8AsNotNullJsonbNumberWhere :: Between (where_filters :: PostgresJsonTypeWhereBetween { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : value_cdde02cc , }))]) { Ok (value_41af48fb) => Some (value_41af48fb) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("5edabfcc-fcbe-419c-a2be-5bd7e961e6e0") } } , Err (error) => None }
            } else {
                None
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveI8AsNotNullJsonbNumberWhere::In(
                        where_filters::PostgresJsonTypeWhereIn {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: where_filters::PostgresJsonTypeNotEmptyUniqueVec::try_new(vec![
                                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    create.0.0,
                                ),
                            ])
                            .expect("2737c0ed-cf4a-4aba-b749-dc7c4e37ff2e"),
                        },
                    ),
                ),
            ]) {
                Ok(value_1c4f89a4) => Some(value_1c4f89a4),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("16ae359d-3869-421b-b37d-85b0b24835bd"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionStdPrimitiveI8AsNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI8AsNullableJsonbNumberOrigin(
        Option<StdPrimitiveI8AsNotNullJsonbNumberOrigin>,
    );
    impl OptionStdPrimitiveI8AsNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI8AsNullableJsonbNumberReadInner) -> Self {
            Self(value.map(StdPrimitiveI8AsNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionStdPrimitiveI8AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveI8AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveI8AsNullableJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<OptionStdPrimitiveI8AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveI8AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveI8AsNullableJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionStdPrimitiveI8AsNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveI8AsNullableJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI8AsNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI8AsNullableJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveI8AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveI8AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI8AsNullableJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration(
        OptionStdPrimitiveI8AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI8AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI8AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveI8AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveI8AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI8AsNullableJsonbNumberCreate(
        OptionStdPrimitiveI8AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI8AsNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI8AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI8AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI8AsNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveI8AsNullableJsonbNumberCreateForQuery(
        OptionStdPrimitiveI8AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI8AsNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI8AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI8AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI8AsNullableJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI8AsNullableJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveI8AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveI8AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionStdPrimitiveI8AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveI8AsNullableJsonbNumberCreateForQuery
    {
        fn from(value: OptionStdPrimitiveI8AsNullableJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI8AsNullableJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI8AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionStdPrimitiveI8AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    pub type OptionStdPrimitiveI8AsNullableJsonbNumberWhere =
        postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter<
            <StdPrimitiveI8AsNotNullJsonbNumber as postgres_crud_common::PostgresJsonType>::Where,
        >;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI8AsNullableJsonbNumberRead(
        OptionStdPrimitiveI8AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI8AsNullableJsonbNumberRead {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI8AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI8AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI8AsNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI8AsNullableJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI8AsNullableJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveI8AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveI8AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionStdPrimitiveI8AsNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionStdPrimitiveI8AsNullableJsonbNumberReadInner = Option<i8>;
    impl From<OptionStdPrimitiveI8AsNullableJsonbNumberOrigin>
        for OptionStdPrimitiveI8AsNullableJsonbNumberReadInner
    {
        fn from(value: OptionStdPrimitiveI8AsNullableJsonbNumberOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI8AsNullableJsonbNumberUpdate(
        OptionStdPrimitiveI8AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI8AsNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI8AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI8AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI8AsNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveI8AsNullableJsonbNumberUpdateForQuery(
        OptionStdPrimitiveI8AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI8AsNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI8AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI8AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionStdPrimitiveI8AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveI8AsNullableJsonbNumberUpdateForQuery
    {
        fn from(value: OptionStdPrimitiveI8AsNullableJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI8AsNullableJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI8AsNullableJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveI8AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveI8AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for OptionStdPrimitiveI8AsNullableJsonbNumber {
        type TableTypeDeclaration = OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration;
        type Create = OptionStdPrimitiveI8AsNullableJsonbNumberCreate;
        type CreateForQuery = OptionStdPrimitiveI8AsNullableJsonbNumberCreateForQuery;
        type Select = OptionStdPrimitiveI8AsNullableJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else ({column_name_and_maybe_field_getter}->'{field_ident}') end)))"
            ))
        }
        type Where = OptionStdPrimitiveI8AsNullableJsonbNumberWhere;
        type Read = OptionStdPrimitiveI8AsNullableJsonbNumberRead;
        type ReadOnlyIds = OptionStdPrimitiveI8AsNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionStdPrimitiveI8AsNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| value_3432e728.0)
        }
        type Update = OptionStdPrimitiveI8AsNullableJsonbNumberUpdate;
        type UpdateForQuery = OptionStdPrimitiveI8AsNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for OptionStdPrimitiveI8AsNullableJsonbNumber {
        type PostgresJsonType = Self;
        type Select = OptionStdPrimitiveI8AsNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveI8AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_97242d4d = Vec::new();
            for el_8f3646f9 in < StdPrimitiveI8AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveI8AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) { for el_35a4dba9 in el_8f3646f9 { acc_97242d4d . push (vec ! [Some (el_35a4dba9)]) ; } }
            acc_97242d4d.push(vec![None]);
            acc_97242d4d
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveI8AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveI8AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionStdPrimitiveI8AsNullableJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionStdPrimitiveI8AsNullableJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionStdPrimitiveI8AsNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter(create.0.0.map(
                |value_18544acf| {
                    postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                        StdPrimitiveI8AsNotNullJsonbNumberWhere::Equal(
                            where_filters::PostgresJsonTypeWhereEqual {
                                logical_operator: postgres_crud_common::LogicalOperator::Or,
                                value: StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    value_18544acf.into(),
                                ),
                            },
                        ),
                    ])
                    .expect("88bfa095-a3ab-4d0c-be71-af63c3acd50f")
                },
            ))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin(
        Vec<StdPrimitiveI8AsNotNullJsonbNumberOrigin>,
    );
    impl VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(
                value
                    .into_iter()
                    .map(StdPrimitiveI8AsNotNullJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
        VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreate(
        VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreateForQuery(
        VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberRead(
        VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner = Vec<i8>;
    impl From<VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner
    {
        fn from(value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdate(
        VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery(
        VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery = VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere;
        type Read = VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0)
                .collect()
        }
        type Update = VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery = VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveI8AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveI8AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveI8AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new({
                let mut acc_f95ec4f2 = vec![];
                for el_ba78af60 in create.0.0 {
                    let value_027d0d3a = el_ba78af60.0.checked_sub(1);
                    match value_027d0d3a {
                        Some(value_0cd93c25) => {
                            acc_f95ec4f2 . push (postgres_crud_common :: SingleOrMultiple :: Single (VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere :: ContainsElGreaterThan (where_filters :: PostgresJsonTypeWhereContainsElGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration (StdPrimitiveI8AsNotNullJsonbNumberOrigin (value_0cd93c25)) }))) ;
                        }
                        None => {
                            return None;
                        }
                    }
                }
                acc_f95ec4f2
            }) {
                Ok(value_69c93ec5) => Some(value_69c93ec5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("47e44ecd-d1c9-4d2b-9d9e-4191cad34be9"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin(
        Vec<OptionStdPrimitiveI8AsNullableJsonbNumberOrigin>,
    );
    impl VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value
                    .into_iter()
                    .map(OptionStdPrimitiveI8AsNullableJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
        VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreate(
        VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreateForQuery(
        VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberRead(
        VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner =
        Vec<Option<i8>>;
    impl From<VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner
    {
        fn from(value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdate(
        VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdateForQuery(
        VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration;
        type Create = VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberCreateForQuery;
        type Select = VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberWhere;
        type Read = VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds = VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                .collect()
        }
        type Update = VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < OptionStdPrimitiveI8AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveI8AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveI8AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match create . 0.0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin(
        Option<VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin>,
    );
    impl OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(value.map(VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
        OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreate(
        OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreateForQuery(
        OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberRead(
        OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner =
        Option<Vec<i8>>;
    impl From<OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner
    {
        fn from(value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdate(
        OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdateForQuery(
        OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberWhere;
        type Read = OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0)
                    .collect()
            })
        }
        type Update = OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveI8AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveI8AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfStdPrimitiveI8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveI8AsNotNullJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI8AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin(
        Option<VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin>,
    );
    impl OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(value.map(VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberOrigin::new))
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
        OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreate(
        OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreateForQuery(
        OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberRead(
        OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner =
        Option<Vec<Option<i8>>>;
    impl From<OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdate(
        OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdateForQuery(
        OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration =
            OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration;
        type Create = OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberCreateForQuery;
        type Select = OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberWhere;
        type Read = OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds =
            OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner =
            OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                    .collect()
            })
        }
        type Update = OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveI8AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveI8AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfOptionStdPrimitiveI8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveI8AsNullableJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI8AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct StdPrimitiveI16AsNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI16AsNotNullJsonbNumberOrigin(i16);
    impl StdPrimitiveI16AsNotNullJsonbNumberOrigin {
        #[must_use]
        pub const fn new(value: StdPrimitiveI16AsNotNullJsonbNumberReadInner) -> Self {
            Self(value)
        }
    }
    impl From<StdPrimitiveI16AsNotNullJsonbNumberCreate> for StdPrimitiveI16AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveI16AsNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<StdPrimitiveI16AsNotNullJsonbNumberUpdate> for StdPrimitiveI16AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveI16AsNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for StdPrimitiveI16AsNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveI16AsNotNullJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI16AsNotNullJsonbNumberOrigin {
        fn default_option_some_vec_one_el() -> Self {
            Self(Default::default())
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI16AsNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveI16AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveI16AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI16AsNotNullJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration(
        StdPrimitiveI16AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub const fn new(value: StdPrimitiveI16AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI16AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveI16AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveI16AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI16AsNotNullJsonbNumberCreate(StdPrimitiveI16AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveI16AsNotNullJsonbNumberCreate {
        #[must_use]
        pub const fn new(value: StdPrimitiveI16AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI16AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI16AsNotNullJsonbNumberCreate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveI16AsNotNullJsonbNumberCreateForQuery(
        StdPrimitiveI16AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveI16AsNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveI16AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI16AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI16AsNotNullJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI16AsNotNullJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveI16AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveI16AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<StdPrimitiveI16AsNotNullJsonbNumberCreate>
        for StdPrimitiveI16AsNotNullJsonbNumberCreateForQuery
    {
        fn from(value: StdPrimitiveI16AsNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI16AsNotNullJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI16AsNotNullJsonbNumberSelect {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for StdPrimitiveI16AsNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum StdPrimitiveI16AsNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        In(
            where_filters::PostgresJsonTypeWhereIn<
                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        GreaterThan(
            where_filters::PostgresJsonTypeWhereGreaterThan<
                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        Between(
            where_filters::PostgresJsonTypeWhereBetween<
                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for StdPrimitiveI16AsNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::In(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::Between(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::In(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::Between(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveI16AsNotNullJsonbNumberWhere {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for StdPrimitiveI16AsNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::In(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::GreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::Between(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI16AsNotNullJsonbNumberRead(StdPrimitiveI16AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveI16AsNotNullJsonbNumberRead {
        #[must_use]
        pub const fn new(value: StdPrimitiveI16AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI16AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI16AsNotNullJsonbNumberRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI16AsNotNullJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI16AsNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveI16AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveI16AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct StdPrimitiveI16AsNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type StdPrimitiveI16AsNotNullJsonbNumberReadInner = i16;
    impl From<StdPrimitiveI16AsNotNullJsonbNumberOrigin>
        for StdPrimitiveI16AsNotNullJsonbNumberReadInner
    {
        fn from(value: StdPrimitiveI16AsNotNullJsonbNumberOrigin) -> Self {
            value.0
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI16AsNotNullJsonbNumberUpdate(StdPrimitiveI16AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveI16AsNotNullJsonbNumberUpdate {
        #[must_use]
        pub const fn new(value: StdPrimitiveI16AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI16AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI16AsNotNullJsonbNumberUpdate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveI16AsNotNullJsonbNumberUpdateForQuery(
        StdPrimitiveI16AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveI16AsNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveI16AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI16AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<StdPrimitiveI16AsNotNullJsonbNumberUpdate>
        for StdPrimitiveI16AsNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: StdPrimitiveI16AsNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI16AsNotNullJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI16AsNotNullJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveI16AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveI16AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for StdPrimitiveI16AsNotNullJsonbNumber {
        type TableTypeDeclaration = StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration;
        type Create = StdPrimitiveI16AsNotNullJsonbNumberCreate;
        type CreateForQuery = StdPrimitiveI16AsNotNullJsonbNumberCreateForQuery;
        type Select = StdPrimitiveI16AsNotNullJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',({column_name_and_maybe_field_getter}->'{field_ident}')))"
            ))
        }
        type Where = StdPrimitiveI16AsNotNullJsonbNumberWhere;
        type Read = StdPrimitiveI16AsNotNullJsonbNumberRead;
        type ReadOnlyIds = StdPrimitiveI16AsNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = StdPrimitiveI16AsNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0
        }
        type Update = StdPrimitiveI16AsNotNullJsonbNumberUpdate;
        type UpdateForQuery = StdPrimitiveI16AsNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for StdPrimitiveI16AsNotNullJsonbNumber {
        type PostgresJsonType = Self;
        type Select = StdPrimitiveI16AsNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some(
                postgres_crud_common::std_primitive_i16_test_cases_vec()
                    .into_iter()
                    .map(<Self as postgres_crud_common::PostgresJsonType>::Create::new)
                    .collect(),
            )
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            vec![postgres_crud_common::std_primitive_i16_test_cases_vec().into()]
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: StdPrimitiveI16AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: StdPrimitiveI16AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            StdPrimitiveI16AsNotNullJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                StdPrimitiveI16AsNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            StdPrimitiveI16AsNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            StdPrimitiveI16AsNotNullJsonbNumberWhere::Equal(
                where_filters::PostgresJsonTypeWhereEqual {
                    logical_operator: postgres_crud_common::LogicalOperator::Or,
                    value: StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration::new(
                        create.0.into(),
                    ),
                },
            )
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            let value_7aa498e8 = create.0.0.checked_sub(1)?;
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveI16AsNotNullJsonbNumberWhere::GreaterThan(
                        where_filters::PostgresJsonTypeWhereGreaterThan {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration(
                                StdPrimitiveI16AsNotNullJsonbNumberOrigin(value_7aa498e8),
                            ),
                        },
                    ),
                ),
            ]) {
                Ok(value_6f3e23b5) => Some(value_6f3e23b5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("11287f54-f840-4076-a16b-1a59a74e6dee"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            if let (Some(start), Some(end)) = (create.0.0.checked_sub(1), create.0.0.checked_add(1))
            {
                match where_filters :: Between :: try_new (StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration :: new (start) , StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration :: new (end)) { Ok (value_cdde02cc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: SingleOrMultiple :: Single (StdPrimitiveI16AsNotNullJsonbNumberWhere :: Between (where_filters :: PostgresJsonTypeWhereBetween { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : value_cdde02cc , }))]) { Ok (value_41af48fb) => Some (value_41af48fb) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("5edabfcc-fcbe-419c-a2be-5bd7e961e6e0") } } , Err (error) => None }
            } else {
                None
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveI16AsNotNullJsonbNumberWhere::In(
                        where_filters::PostgresJsonTypeWhereIn {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: where_filters::PostgresJsonTypeNotEmptyUniqueVec::try_new(vec![
                                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    create.0.0,
                                ),
                            ])
                            .expect("2737c0ed-cf4a-4aba-b749-dc7c4e37ff2e"),
                        },
                    ),
                ),
            ]) {
                Ok(value_1c4f89a4) => Some(value_1c4f89a4),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("16ae359d-3869-421b-b37d-85b0b24835bd"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionStdPrimitiveI16AsNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI16AsNullableJsonbNumberOrigin(
        Option<StdPrimitiveI16AsNotNullJsonbNumberOrigin>,
    );
    impl OptionStdPrimitiveI16AsNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI16AsNullableJsonbNumberReadInner) -> Self {
            Self(value.map(StdPrimitiveI16AsNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionStdPrimitiveI16AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveI16AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveI16AsNullableJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<OptionStdPrimitiveI16AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveI16AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveI16AsNullableJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionStdPrimitiveI16AsNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveI16AsNullableJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI16AsNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI16AsNullableJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveI16AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveI16AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI16AsNullableJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration(
        OptionStdPrimitiveI16AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI16AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI16AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveI16AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveI16AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI16AsNullableJsonbNumberCreate(
        OptionStdPrimitiveI16AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI16AsNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI16AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI16AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI16AsNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveI16AsNullableJsonbNumberCreateForQuery(
        OptionStdPrimitiveI16AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI16AsNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI16AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI16AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI16AsNullableJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI16AsNullableJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveI16AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveI16AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionStdPrimitiveI16AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveI16AsNullableJsonbNumberCreateForQuery
    {
        fn from(value: OptionStdPrimitiveI16AsNullableJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI16AsNullableJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI16AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionStdPrimitiveI16AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    pub type OptionStdPrimitiveI16AsNullableJsonbNumberWhere =
        postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter<
            <StdPrimitiveI16AsNotNullJsonbNumber as postgres_crud_common::PostgresJsonType>::Where,
        >;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI16AsNullableJsonbNumberRead(
        OptionStdPrimitiveI16AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI16AsNullableJsonbNumberRead {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI16AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI16AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI16AsNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI16AsNullableJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI16AsNullableJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveI16AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveI16AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionStdPrimitiveI16AsNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionStdPrimitiveI16AsNullableJsonbNumberReadInner = Option<i16>;
    impl From<OptionStdPrimitiveI16AsNullableJsonbNumberOrigin>
        for OptionStdPrimitiveI16AsNullableJsonbNumberReadInner
    {
        fn from(value: OptionStdPrimitiveI16AsNullableJsonbNumberOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI16AsNullableJsonbNumberUpdate(
        OptionStdPrimitiveI16AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI16AsNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI16AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI16AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI16AsNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveI16AsNullableJsonbNumberUpdateForQuery(
        OptionStdPrimitiveI16AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI16AsNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI16AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI16AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionStdPrimitiveI16AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveI16AsNullableJsonbNumberUpdateForQuery
    {
        fn from(value: OptionStdPrimitiveI16AsNullableJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI16AsNullableJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI16AsNullableJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveI16AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveI16AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for OptionStdPrimitiveI16AsNullableJsonbNumber {
        type TableTypeDeclaration = OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration;
        type Create = OptionStdPrimitiveI16AsNullableJsonbNumberCreate;
        type CreateForQuery = OptionStdPrimitiveI16AsNullableJsonbNumberCreateForQuery;
        type Select = OptionStdPrimitiveI16AsNullableJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else ({column_name_and_maybe_field_getter}->'{field_ident}') end)))"
            ))
        }
        type Where = OptionStdPrimitiveI16AsNullableJsonbNumberWhere;
        type Read = OptionStdPrimitiveI16AsNullableJsonbNumberRead;
        type ReadOnlyIds = OptionStdPrimitiveI16AsNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionStdPrimitiveI16AsNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| value_3432e728.0)
        }
        type Update = OptionStdPrimitiveI16AsNullableJsonbNumberUpdate;
        type UpdateForQuery = OptionStdPrimitiveI16AsNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionStdPrimitiveI16AsNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionStdPrimitiveI16AsNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveI16AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_97242d4d = Vec::new();
            for el_8f3646f9 in < StdPrimitiveI16AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveI16AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) { for el_35a4dba9 in el_8f3646f9 { acc_97242d4d . push (vec ! [Some (el_35a4dba9)]) ; } }
            acc_97242d4d.push(vec![None]);
            acc_97242d4d
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveI16AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveI16AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionStdPrimitiveI16AsNullableJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionStdPrimitiveI16AsNullableJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionStdPrimitiveI16AsNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter(create.0.0.map(
                |value_18544acf| {
                    postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                        StdPrimitiveI16AsNotNullJsonbNumberWhere::Equal(
                            where_filters::PostgresJsonTypeWhereEqual {
                                logical_operator: postgres_crud_common::LogicalOperator::Or,
                                value: StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    value_18544acf.into(),
                                ),
                            },
                        ),
                    ])
                    .expect("88bfa095-a3ab-4d0c-be71-af63c3acd50f")
                },
            ))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin(
        Vec<StdPrimitiveI16AsNotNullJsonbNumberOrigin>,
    );
    impl VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(
                value
                    .into_iter()
                    .map(StdPrimitiveI16AsNotNullJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
        VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreate(
        VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreateForQuery(
        VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberRead(
        VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner = Vec<i16>;
    impl From<VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner
    {
        fn from(value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdate(
        VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery(
        VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere;
        type Read = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0)
                .collect()
        }
        type Update = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveI16AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveI16AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveI16AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new({
                let mut acc_f95ec4f2 = vec![];
                for el_ba78af60 in create.0.0 {
                    let value_027d0d3a = el_ba78af60.0.checked_sub(1);
                    match value_027d0d3a {
                        Some(value_0cd93c25) => {
                            acc_f95ec4f2 . push (postgres_crud_common :: SingleOrMultiple :: Single (VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere :: ContainsElGreaterThan (where_filters :: PostgresJsonTypeWhereContainsElGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration (StdPrimitiveI16AsNotNullJsonbNumberOrigin (value_0cd93c25)) }))) ;
                        }
                        None => {
                            return None;
                        }
                    }
                }
                acc_f95ec4f2
            }) {
                Ok(value_69c93ec5) => Some(value_69c93ec5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("47e44ecd-d1c9-4d2b-9d9e-4191cad34be9"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin(
        Vec<OptionStdPrimitiveI16AsNullableJsonbNumberOrigin>,
    );
    impl VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value
                    .into_iter()
                    .map(OptionStdPrimitiveI16AsNullableJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
        VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreate(
        VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreateForQuery(
        VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberRead(
        VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner =
        Vec<Option<i16>>;
    impl From<VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdate(
        VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdateForQuery(
        VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration;
        type Create = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberCreateForQuery;
        type Select = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberWhere;
        type Read = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                .collect()
        }
        type Update = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < OptionStdPrimitiveI16AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveI16AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveI16AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match create . 0.0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin(
        Option<VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin>,
    );
    impl OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(value.map(VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
        OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreate(
        OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreateForQuery(
        OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberRead(
        OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner =
        Option<Vec<i16>>;
    impl From<OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdate(
        OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdateForQuery(
        OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberWhere;
        type Read = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0)
                    .collect()
            })
        }
        type Update = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveI16AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveI16AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveI16AsNotNullJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI16AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin(
        Option<VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin>,
    );
    impl OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value.map(VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberOrigin::new),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
        OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreate(
        OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreateForQuery(
        OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberRead(
        OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner =
        Option<Vec<Option<i16>>>;
    impl From<OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdate(
        OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdateForQuery(
        OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration ;
        type Create = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberCreateForQuery;
        type Select = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberWhere;
        type Read = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds =
            OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner =
            OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                    .collect()
            })
        }
        type Update = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveI16AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveI16AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveI16AsNullableJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct StdPrimitiveI32AsNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI32AsNotNullJsonbNumberOrigin(i32);
    impl StdPrimitiveI32AsNotNullJsonbNumberOrigin {
        #[must_use]
        pub const fn new(value: StdPrimitiveI32AsNotNullJsonbNumberReadInner) -> Self {
            Self(value)
        }
    }
    impl From<StdPrimitiveI32AsNotNullJsonbNumberCreate> for StdPrimitiveI32AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveI32AsNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<StdPrimitiveI32AsNotNullJsonbNumberUpdate> for StdPrimitiveI32AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveI32AsNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for StdPrimitiveI32AsNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveI32AsNotNullJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI32AsNotNullJsonbNumberOrigin {
        fn default_option_some_vec_one_el() -> Self {
            Self(Default::default())
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI32AsNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveI32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveI32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI32AsNotNullJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration(
        StdPrimitiveI32AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub const fn new(value: StdPrimitiveI32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveI32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveI32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI32AsNotNullJsonbNumberCreate(StdPrimitiveI32AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveI32AsNotNullJsonbNumberCreate {
        #[must_use]
        pub const fn new(value: StdPrimitiveI32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI32AsNotNullJsonbNumberCreate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveI32AsNotNullJsonbNumberCreateForQuery(
        StdPrimitiveI32AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveI32AsNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveI32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI32AsNotNullJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI32AsNotNullJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveI32AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveI32AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<StdPrimitiveI32AsNotNullJsonbNumberCreate>
        for StdPrimitiveI32AsNotNullJsonbNumberCreateForQuery
    {
        fn from(value: StdPrimitiveI32AsNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI32AsNotNullJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI32AsNotNullJsonbNumberSelect {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for StdPrimitiveI32AsNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum StdPrimitiveI32AsNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        In(
            where_filters::PostgresJsonTypeWhereIn<
                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        GreaterThan(
            where_filters::PostgresJsonTypeWhereGreaterThan<
                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        Between(
            where_filters::PostgresJsonTypeWhereBetween<
                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for StdPrimitiveI32AsNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::In(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::Between(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::In(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::Between(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveI32AsNotNullJsonbNumberWhere {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for StdPrimitiveI32AsNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::In(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::GreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::Between(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI32AsNotNullJsonbNumberRead(StdPrimitiveI32AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveI32AsNotNullJsonbNumberRead {
        #[must_use]
        pub const fn new(value: StdPrimitiveI32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI32AsNotNullJsonbNumberRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI32AsNotNullJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI32AsNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveI32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveI32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct StdPrimitiveI32AsNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type StdPrimitiveI32AsNotNullJsonbNumberReadInner = i32;
    impl From<StdPrimitiveI32AsNotNullJsonbNumberOrigin>
        for StdPrimitiveI32AsNotNullJsonbNumberReadInner
    {
        fn from(value: StdPrimitiveI32AsNotNullJsonbNumberOrigin) -> Self {
            value.0
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI32AsNotNullJsonbNumberUpdate(StdPrimitiveI32AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveI32AsNotNullJsonbNumberUpdate {
        #[must_use]
        pub const fn new(value: StdPrimitiveI32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI32AsNotNullJsonbNumberUpdate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveI32AsNotNullJsonbNumberUpdateForQuery(
        StdPrimitiveI32AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveI32AsNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveI32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<StdPrimitiveI32AsNotNullJsonbNumberUpdate>
        for StdPrimitiveI32AsNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: StdPrimitiveI32AsNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI32AsNotNullJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI32AsNotNullJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveI32AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveI32AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for StdPrimitiveI32AsNotNullJsonbNumber {
        type TableTypeDeclaration = StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration;
        type Create = StdPrimitiveI32AsNotNullJsonbNumberCreate;
        type CreateForQuery = StdPrimitiveI32AsNotNullJsonbNumberCreateForQuery;
        type Select = StdPrimitiveI32AsNotNullJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',({column_name_and_maybe_field_getter}->'{field_ident}')))"
            ))
        }
        type Where = StdPrimitiveI32AsNotNullJsonbNumberWhere;
        type Read = StdPrimitiveI32AsNotNullJsonbNumberRead;
        type ReadOnlyIds = StdPrimitiveI32AsNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = StdPrimitiveI32AsNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0
        }
        type Update = StdPrimitiveI32AsNotNullJsonbNumberUpdate;
        type UpdateForQuery = StdPrimitiveI32AsNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for StdPrimitiveI32AsNotNullJsonbNumber {
        type PostgresJsonType = Self;
        type Select = StdPrimitiveI32AsNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some(
                postgres_crud_common::std_primitive_i32_test_cases_vec()
                    .into_iter()
                    .map(<Self as postgres_crud_common::PostgresJsonType>::Create::new)
                    .collect(),
            )
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            vec![postgres_crud_common::std_primitive_i32_test_cases_vec().into()]
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: StdPrimitiveI32AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: StdPrimitiveI32AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            StdPrimitiveI32AsNotNullJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                StdPrimitiveI32AsNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            StdPrimitiveI32AsNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            StdPrimitiveI32AsNotNullJsonbNumberWhere::Equal(
                where_filters::PostgresJsonTypeWhereEqual {
                    logical_operator: postgres_crud_common::LogicalOperator::Or,
                    value: StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration::new(
                        create.0.into(),
                    ),
                },
            )
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            let value_7aa498e8 = create.0.0.checked_sub(1)?;
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveI32AsNotNullJsonbNumberWhere::GreaterThan(
                        where_filters::PostgresJsonTypeWhereGreaterThan {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration(
                                StdPrimitiveI32AsNotNullJsonbNumberOrigin(value_7aa498e8),
                            ),
                        },
                    ),
                ),
            ]) {
                Ok(value_6f3e23b5) => Some(value_6f3e23b5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("11287f54-f840-4076-a16b-1a59a74e6dee"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            if let (Some(start), Some(end)) = (create.0.0.checked_sub(1), create.0.0.checked_add(1))
            {
                match where_filters :: Between :: try_new (StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration :: new (start) , StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration :: new (end)) { Ok (value_cdde02cc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: SingleOrMultiple :: Single (StdPrimitiveI32AsNotNullJsonbNumberWhere :: Between (where_filters :: PostgresJsonTypeWhereBetween { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : value_cdde02cc , }))]) { Ok (value_41af48fb) => Some (value_41af48fb) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("5edabfcc-fcbe-419c-a2be-5bd7e961e6e0") } } , Err (error) => None }
            } else {
                None
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveI32AsNotNullJsonbNumberWhere::In(
                        where_filters::PostgresJsonTypeWhereIn {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: where_filters::PostgresJsonTypeNotEmptyUniqueVec::try_new(vec![
                                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    create.0.0,
                                ),
                            ])
                            .expect("2737c0ed-cf4a-4aba-b749-dc7c4e37ff2e"),
                        },
                    ),
                ),
            ]) {
                Ok(value_1c4f89a4) => Some(value_1c4f89a4),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("16ae359d-3869-421b-b37d-85b0b24835bd"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionStdPrimitiveI32AsNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI32AsNullableJsonbNumberOrigin(
        Option<StdPrimitiveI32AsNotNullJsonbNumberOrigin>,
    );
    impl OptionStdPrimitiveI32AsNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI32AsNullableJsonbNumberReadInner) -> Self {
            Self(value.map(StdPrimitiveI32AsNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionStdPrimitiveI32AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveI32AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveI32AsNullableJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<OptionStdPrimitiveI32AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveI32AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveI32AsNullableJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionStdPrimitiveI32AsNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveI32AsNullableJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI32AsNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI32AsNullableJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveI32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveI32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI32AsNullableJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration(
        OptionStdPrimitiveI32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveI32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveI32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI32AsNullableJsonbNumberCreate(
        OptionStdPrimitiveI32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI32AsNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI32AsNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveI32AsNullableJsonbNumberCreateForQuery(
        OptionStdPrimitiveI32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI32AsNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI32AsNullableJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI32AsNullableJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveI32AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveI32AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionStdPrimitiveI32AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveI32AsNullableJsonbNumberCreateForQuery
    {
        fn from(value: OptionStdPrimitiveI32AsNullableJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI32AsNullableJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI32AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionStdPrimitiveI32AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    pub type OptionStdPrimitiveI32AsNullableJsonbNumberWhere =
        postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter<
            <StdPrimitiveI32AsNotNullJsonbNumber as postgres_crud_common::PostgresJsonType>::Where,
        >;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI32AsNullableJsonbNumberRead(
        OptionStdPrimitiveI32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI32AsNullableJsonbNumberRead {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI32AsNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI32AsNullableJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI32AsNullableJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveI32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveI32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionStdPrimitiveI32AsNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionStdPrimitiveI32AsNullableJsonbNumberReadInner = Option<i32>;
    impl From<OptionStdPrimitiveI32AsNullableJsonbNumberOrigin>
        for OptionStdPrimitiveI32AsNullableJsonbNumberReadInner
    {
        fn from(value: OptionStdPrimitiveI32AsNullableJsonbNumberOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI32AsNullableJsonbNumberUpdate(
        OptionStdPrimitiveI32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI32AsNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI32AsNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveI32AsNullableJsonbNumberUpdateForQuery(
        OptionStdPrimitiveI32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI32AsNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionStdPrimitiveI32AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveI32AsNullableJsonbNumberUpdateForQuery
    {
        fn from(value: OptionStdPrimitiveI32AsNullableJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI32AsNullableJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI32AsNullableJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveI32AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveI32AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for OptionStdPrimitiveI32AsNullableJsonbNumber {
        type TableTypeDeclaration = OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration;
        type Create = OptionStdPrimitiveI32AsNullableJsonbNumberCreate;
        type CreateForQuery = OptionStdPrimitiveI32AsNullableJsonbNumberCreateForQuery;
        type Select = OptionStdPrimitiveI32AsNullableJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else ({column_name_and_maybe_field_getter}->'{field_ident}') end)))"
            ))
        }
        type Where = OptionStdPrimitiveI32AsNullableJsonbNumberWhere;
        type Read = OptionStdPrimitiveI32AsNullableJsonbNumberRead;
        type ReadOnlyIds = OptionStdPrimitiveI32AsNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionStdPrimitiveI32AsNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| value_3432e728.0)
        }
        type Update = OptionStdPrimitiveI32AsNullableJsonbNumberUpdate;
        type UpdateForQuery = OptionStdPrimitiveI32AsNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionStdPrimitiveI32AsNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionStdPrimitiveI32AsNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveI32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_97242d4d = Vec::new();
            for el_8f3646f9 in < StdPrimitiveI32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveI32AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) { for el_35a4dba9 in el_8f3646f9 { acc_97242d4d . push (vec ! [Some (el_35a4dba9)]) ; } }
            acc_97242d4d.push(vec![None]);
            acc_97242d4d
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveI32AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveI32AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionStdPrimitiveI32AsNullableJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionStdPrimitiveI32AsNullableJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionStdPrimitiveI32AsNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter(create.0.0.map(
                |value_18544acf| {
                    postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                        StdPrimitiveI32AsNotNullJsonbNumberWhere::Equal(
                            where_filters::PostgresJsonTypeWhereEqual {
                                logical_operator: postgres_crud_common::LogicalOperator::Or,
                                value: StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    value_18544acf.into(),
                                ),
                            },
                        ),
                    ])
                    .expect("88bfa095-a3ab-4d0c-be71-af63c3acd50f")
                },
            ))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin(
        Vec<StdPrimitiveI32AsNotNullJsonbNumberOrigin>,
    );
    impl VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(
                value
                    .into_iter()
                    .map(StdPrimitiveI32AsNotNullJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
        VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreate(
        VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery(
        VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberRead(
        VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner = Vec<i32>;
    impl From<VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner
    {
        fn from(value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdate(
        VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery(
        VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere;
        type Read = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0)
                .collect()
        }
        type Update = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveI32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveI32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveI32AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new({
                let mut acc_f95ec4f2 = vec![];
                for el_ba78af60 in create.0.0 {
                    let value_027d0d3a = el_ba78af60.0.checked_sub(1);
                    match value_027d0d3a {
                        Some(value_0cd93c25) => {
                            acc_f95ec4f2 . push (postgres_crud_common :: SingleOrMultiple :: Single (VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere :: ContainsElGreaterThan (where_filters :: PostgresJsonTypeWhereContainsElGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration (StdPrimitiveI32AsNotNullJsonbNumberOrigin (value_0cd93c25)) }))) ;
                        }
                        None => {
                            return None;
                        }
                    }
                }
                acc_f95ec4f2
            }) {
                Ok(value_69c93ec5) => Some(value_69c93ec5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("47e44ecd-d1c9-4d2b-9d9e-4191cad34be9"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin(
        Vec<OptionStdPrimitiveI32AsNullableJsonbNumberOrigin>,
    );
    impl VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value
                    .into_iter()
                    .map(OptionStdPrimitiveI32AsNullableJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
        VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreate(
        VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreateForQuery(
        VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberRead(
        VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner =
        Vec<Option<i32>>;
    impl From<VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdate(
        VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery(
        VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration;
        type Create = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberCreateForQuery;
        type Select = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberWhere;
        type Read = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                .collect()
        }
        type Update = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < OptionStdPrimitiveI32AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveI32AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveI32AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match create . 0.0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin(
        Option<VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin>,
    );
    impl OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(value.map(VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
        OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreate(
        OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreateForQuery(
        OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberRead(
        OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner =
        Option<Vec<i32>>;
    impl From<OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdate(
        OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery(
        OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberWhere;
        type Read = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0)
                    .collect()
            })
        }
        type Update = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveI32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveI32AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveI32AsNotNullJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI32AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin(
        Option<VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin>,
    );
    impl OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value.map(VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberOrigin::new),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
        OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreate(
        OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreateForQuery(
        OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberRead(
        OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner =
        Option<Vec<Option<i32>>>;
    impl From<OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdate(
        OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdateForQuery(
        OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration ;
        type Create = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberCreateForQuery;
        type Select = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberWhere;
        type Read = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds =
            OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner =
            OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                    .collect()
            })
        }
        type Update = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveI32AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveI32AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveI32AsNullableJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct StdPrimitiveI64AsNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI64AsNotNullJsonbNumberOrigin(i64);
    impl StdPrimitiveI64AsNotNullJsonbNumberOrigin {
        #[must_use]
        pub const fn new(value: StdPrimitiveI64AsNotNullJsonbNumberReadInner) -> Self {
            Self(value)
        }
    }
    impl From<StdPrimitiveI64AsNotNullJsonbNumberCreate> for StdPrimitiveI64AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveI64AsNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<StdPrimitiveI64AsNotNullJsonbNumberUpdate> for StdPrimitiveI64AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveI64AsNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for StdPrimitiveI64AsNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveI64AsNotNullJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI64AsNotNullJsonbNumberOrigin {
        fn default_option_some_vec_one_el() -> Self {
            Self(Default::default())
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI64AsNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveI64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveI64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI64AsNotNullJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration(
        StdPrimitiveI64AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub const fn new(value: StdPrimitiveI64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveI64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveI64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI64AsNotNullJsonbNumberCreate(StdPrimitiveI64AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveI64AsNotNullJsonbNumberCreate {
        #[must_use]
        pub const fn new(value: StdPrimitiveI64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI64AsNotNullJsonbNumberCreate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveI64AsNotNullJsonbNumberCreateForQuery(
        StdPrimitiveI64AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveI64AsNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveI64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI64AsNotNullJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI64AsNotNullJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveI64AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveI64AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<StdPrimitiveI64AsNotNullJsonbNumberCreate>
        for StdPrimitiveI64AsNotNullJsonbNumberCreateForQuery
    {
        fn from(value: StdPrimitiveI64AsNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI64AsNotNullJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI64AsNotNullJsonbNumberSelect {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for StdPrimitiveI64AsNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum StdPrimitiveI64AsNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        In(
            where_filters::PostgresJsonTypeWhereIn<
                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        GreaterThan(
            where_filters::PostgresJsonTypeWhereGreaterThan<
                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        Between(
            where_filters::PostgresJsonTypeWhereBetween<
                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for StdPrimitiveI64AsNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::In(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::Between(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::In(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::Between(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveI64AsNotNullJsonbNumberWhere {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for StdPrimitiveI64AsNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::In(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::GreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::Between(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI64AsNotNullJsonbNumberRead(StdPrimitiveI64AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveI64AsNotNullJsonbNumberRead {
        #[must_use]
        pub const fn new(value: StdPrimitiveI64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI64AsNotNullJsonbNumberRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI64AsNotNullJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI64AsNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveI64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveI64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct StdPrimitiveI64AsNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type StdPrimitiveI64AsNotNullJsonbNumberReadInner = i64;
    impl From<StdPrimitiveI64AsNotNullJsonbNumberOrigin>
        for StdPrimitiveI64AsNotNullJsonbNumberReadInner
    {
        fn from(value: StdPrimitiveI64AsNotNullJsonbNumberOrigin) -> Self {
            value.0
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveI64AsNotNullJsonbNumberUpdate(StdPrimitiveI64AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveI64AsNotNullJsonbNumberUpdate {
        #[must_use]
        pub const fn new(value: StdPrimitiveI64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveI64AsNotNullJsonbNumberUpdate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveI64AsNotNullJsonbNumberUpdateForQuery(
        StdPrimitiveI64AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveI64AsNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveI64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveI64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<StdPrimitiveI64AsNotNullJsonbNumberUpdate>
        for StdPrimitiveI64AsNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: StdPrimitiveI64AsNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI64AsNotNullJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI64AsNotNullJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveI64AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveI64AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for StdPrimitiveI64AsNotNullJsonbNumber {
        type TableTypeDeclaration = StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration;
        type Create = StdPrimitiveI64AsNotNullJsonbNumberCreate;
        type CreateForQuery = StdPrimitiveI64AsNotNullJsonbNumberCreateForQuery;
        type Select = StdPrimitiveI64AsNotNullJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',({column_name_and_maybe_field_getter}->'{field_ident}')))"
            ))
        }
        type Where = StdPrimitiveI64AsNotNullJsonbNumberWhere;
        type Read = StdPrimitiveI64AsNotNullJsonbNumberRead;
        type ReadOnlyIds = StdPrimitiveI64AsNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = StdPrimitiveI64AsNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0
        }
        type Update = StdPrimitiveI64AsNotNullJsonbNumberUpdate;
        type UpdateForQuery = StdPrimitiveI64AsNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for StdPrimitiveI64AsNotNullJsonbNumber {
        type PostgresJsonType = Self;
        type Select = StdPrimitiveI64AsNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some(
                postgres_crud_common::std_primitive_i64_test_cases_vec()
                    .into_iter()
                    .map(<Self as postgres_crud_common::PostgresJsonType>::Create::new)
                    .collect(),
            )
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            vec![postgres_crud_common::std_primitive_i64_test_cases_vec().into()]
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: StdPrimitiveI64AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: StdPrimitiveI64AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            StdPrimitiveI64AsNotNullJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                StdPrimitiveI64AsNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            StdPrimitiveI64AsNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            StdPrimitiveI64AsNotNullJsonbNumberWhere::Equal(
                where_filters::PostgresJsonTypeWhereEqual {
                    logical_operator: postgres_crud_common::LogicalOperator::Or,
                    value: StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration::new(
                        create.0.into(),
                    ),
                },
            )
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            let value_7aa498e8 = create.0.0.checked_sub(1)?;
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveI64AsNotNullJsonbNumberWhere::GreaterThan(
                        where_filters::PostgresJsonTypeWhereGreaterThan {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration(
                                StdPrimitiveI64AsNotNullJsonbNumberOrigin(value_7aa498e8),
                            ),
                        },
                    ),
                ),
            ]) {
                Ok(value_6f3e23b5) => Some(value_6f3e23b5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("11287f54-f840-4076-a16b-1a59a74e6dee"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            if let (Some(start), Some(end)) = (create.0.0.checked_sub(1), create.0.0.checked_add(1))
            {
                match where_filters :: Between :: try_new (StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration :: new (start) , StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration :: new (end)) { Ok (value_cdde02cc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: SingleOrMultiple :: Single (StdPrimitiveI64AsNotNullJsonbNumberWhere :: Between (where_filters :: PostgresJsonTypeWhereBetween { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : value_cdde02cc , }))]) { Ok (value_41af48fb) => Some (value_41af48fb) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("5edabfcc-fcbe-419c-a2be-5bd7e961e6e0") } } , Err (error) => None }
            } else {
                None
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveI64AsNotNullJsonbNumberWhere::In(
                        where_filters::PostgresJsonTypeWhereIn {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: where_filters::PostgresJsonTypeNotEmptyUniqueVec::try_new(vec![
                                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    create.0.0,
                                ),
                            ])
                            .expect("2737c0ed-cf4a-4aba-b749-dc7c4e37ff2e"),
                        },
                    ),
                ),
            ]) {
                Ok(value_1c4f89a4) => Some(value_1c4f89a4),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("16ae359d-3869-421b-b37d-85b0b24835bd"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionStdPrimitiveI64AsNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI64AsNullableJsonbNumberOrigin(
        Option<StdPrimitiveI64AsNotNullJsonbNumberOrigin>,
    );
    impl OptionStdPrimitiveI64AsNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI64AsNullableJsonbNumberReadInner) -> Self {
            Self(value.map(StdPrimitiveI64AsNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionStdPrimitiveI64AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveI64AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveI64AsNullableJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<OptionStdPrimitiveI64AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveI64AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveI64AsNullableJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionStdPrimitiveI64AsNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveI64AsNullableJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI64AsNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI64AsNullableJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveI64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveI64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI64AsNullableJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration(
        OptionStdPrimitiveI64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveI64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveI64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI64AsNullableJsonbNumberCreate(
        OptionStdPrimitiveI64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI64AsNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI64AsNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveI64AsNullableJsonbNumberCreateForQuery(
        OptionStdPrimitiveI64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI64AsNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI64AsNullableJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI64AsNullableJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveI64AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveI64AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionStdPrimitiveI64AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveI64AsNullableJsonbNumberCreateForQuery
    {
        fn from(value: OptionStdPrimitiveI64AsNullableJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI64AsNullableJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI64AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionStdPrimitiveI64AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    pub type OptionStdPrimitiveI64AsNullableJsonbNumberWhere =
        postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter<
            <StdPrimitiveI64AsNotNullJsonbNumber as postgres_crud_common::PostgresJsonType>::Where,
        >;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI64AsNullableJsonbNumberRead(
        OptionStdPrimitiveI64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI64AsNullableJsonbNumberRead {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI64AsNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI64AsNullableJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI64AsNullableJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveI64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveI64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionStdPrimitiveI64AsNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionStdPrimitiveI64AsNullableJsonbNumberReadInner = Option<i64>;
    impl From<OptionStdPrimitiveI64AsNullableJsonbNumberOrigin>
        for OptionStdPrimitiveI64AsNullableJsonbNumberReadInner
    {
        fn from(value: OptionStdPrimitiveI64AsNullableJsonbNumberOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveI64AsNullableJsonbNumberUpdate(
        OptionStdPrimitiveI64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI64AsNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveI64AsNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveI64AsNullableJsonbNumberUpdateForQuery(
        OptionStdPrimitiveI64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveI64AsNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveI64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveI64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionStdPrimitiveI64AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveI64AsNullableJsonbNumberUpdateForQuery
    {
        fn from(value: OptionStdPrimitiveI64AsNullableJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI64AsNullableJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI64AsNullableJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveI64AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveI64AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for OptionStdPrimitiveI64AsNullableJsonbNumber {
        type TableTypeDeclaration = OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration;
        type Create = OptionStdPrimitiveI64AsNullableJsonbNumberCreate;
        type CreateForQuery = OptionStdPrimitiveI64AsNullableJsonbNumberCreateForQuery;
        type Select = OptionStdPrimitiveI64AsNullableJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else ({column_name_and_maybe_field_getter}->'{field_ident}') end)))"
            ))
        }
        type Where = OptionStdPrimitiveI64AsNullableJsonbNumberWhere;
        type Read = OptionStdPrimitiveI64AsNullableJsonbNumberRead;
        type ReadOnlyIds = OptionStdPrimitiveI64AsNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionStdPrimitiveI64AsNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| value_3432e728.0)
        }
        type Update = OptionStdPrimitiveI64AsNullableJsonbNumberUpdate;
        type UpdateForQuery = OptionStdPrimitiveI64AsNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionStdPrimitiveI64AsNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionStdPrimitiveI64AsNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveI64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_97242d4d = Vec::new();
            for el_8f3646f9 in < StdPrimitiveI64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveI64AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) { for el_35a4dba9 in el_8f3646f9 { acc_97242d4d . push (vec ! [Some (el_35a4dba9)]) ; } }
            acc_97242d4d.push(vec![None]);
            acc_97242d4d
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveI64AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveI64AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionStdPrimitiveI64AsNullableJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionStdPrimitiveI64AsNullableJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionStdPrimitiveI64AsNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter(create.0.0.map(
                |value_18544acf| {
                    postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                        StdPrimitiveI64AsNotNullJsonbNumberWhere::Equal(
                            where_filters::PostgresJsonTypeWhereEqual {
                                logical_operator: postgres_crud_common::LogicalOperator::Or,
                                value: StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    value_18544acf.into(),
                                ),
                            },
                        ),
                    ])
                    .expect("88bfa095-a3ab-4d0c-be71-af63c3acd50f")
                },
            ))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin(
        Vec<StdPrimitiveI64AsNotNullJsonbNumberOrigin>,
    );
    impl VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(
                value
                    .into_iter()
                    .map(StdPrimitiveI64AsNotNullJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
        VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreate(
        VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery(
        VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberRead(
        VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner = Vec<i64>;
    impl From<VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner
    {
        fn from(value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdate(
        VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery(
        VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere;
        type Read = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0)
                .collect()
        }
        type Update = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveI64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveI64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveI64AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new({
                let mut acc_f95ec4f2 = vec![];
                for el_ba78af60 in create.0.0 {
                    let value_027d0d3a = el_ba78af60.0.checked_sub(1);
                    match value_027d0d3a {
                        Some(value_0cd93c25) => {
                            acc_f95ec4f2 . push (postgres_crud_common :: SingleOrMultiple :: Single (VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere :: ContainsElGreaterThan (where_filters :: PostgresJsonTypeWhereContainsElGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration (StdPrimitiveI64AsNotNullJsonbNumberOrigin (value_0cd93c25)) }))) ;
                        }
                        None => {
                            return None;
                        }
                    }
                }
                acc_f95ec4f2
            }) {
                Ok(value_69c93ec5) => Some(value_69c93ec5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("47e44ecd-d1c9-4d2b-9d9e-4191cad34be9"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin(
        Vec<OptionStdPrimitiveI64AsNullableJsonbNumberOrigin>,
    );
    impl VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value
                    .into_iter()
                    .map(OptionStdPrimitiveI64AsNullableJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
        VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreate(
        VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreateForQuery(
        VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberRead(
        VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner =
        Vec<Option<i64>>;
    impl From<VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdate(
        VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery(
        VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration;
        type Create = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberCreateForQuery;
        type Select = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberWhere;
        type Read = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                .collect()
        }
        type Update = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < OptionStdPrimitiveI64AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveI64AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveI64AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match create . 0.0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin(
        Option<VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin>,
    );
    impl OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(value.map(VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
        OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreate(
        OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreateForQuery(
        OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberRead(
        OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner =
        Option<Vec<i64>>;
    impl From<OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdate(
        OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery(
        OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberWhere;
        type Read = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0)
                    .collect()
            })
        }
        type Update = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveI64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveI64AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveI64AsNotNullJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveI64AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin(
        Option<VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin>,
    );
    impl OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value.map(VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberOrigin::new),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
        OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreate(
        OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreateForQuery(
        OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberRead(
        OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner =
        Option<Vec<Option<i64>>>;
    impl From<OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdate(
        OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdateForQuery(
        OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration ;
        type Create = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberCreateForQuery;
        type Select = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberWhere;
        type Read = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds =
            OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner =
            OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                    .collect()
            })
        }
        type Update = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveI64AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveI64AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveI64AsNullableJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct StdPrimitiveU8AsNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU8AsNotNullJsonbNumberOrigin(u8);
    impl StdPrimitiveU8AsNotNullJsonbNumberOrigin {
        #[must_use]
        pub const fn new(value: StdPrimitiveU8AsNotNullJsonbNumberReadInner) -> Self {
            Self(value)
        }
    }
    impl From<StdPrimitiveU8AsNotNullJsonbNumberCreate> for StdPrimitiveU8AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveU8AsNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<StdPrimitiveU8AsNotNullJsonbNumberUpdate> for StdPrimitiveU8AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveU8AsNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for StdPrimitiveU8AsNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveU8AsNotNullJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU8AsNotNullJsonbNumberOrigin {
        fn default_option_some_vec_one_el() -> Self {
            Self(Default::default())
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU8AsNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveU8AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveU8AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU8AsNotNullJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration(
        StdPrimitiveU8AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub const fn new(value: StdPrimitiveU8AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU8AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveU8AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveU8AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU8AsNotNullJsonbNumberCreate(StdPrimitiveU8AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveU8AsNotNullJsonbNumberCreate {
        #[must_use]
        pub const fn new(value: StdPrimitiveU8AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU8AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU8AsNotNullJsonbNumberCreate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveU8AsNotNullJsonbNumberCreateForQuery(
        StdPrimitiveU8AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveU8AsNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveU8AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU8AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU8AsNotNullJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU8AsNotNullJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveU8AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveU8AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<StdPrimitiveU8AsNotNullJsonbNumberCreate>
        for StdPrimitiveU8AsNotNullJsonbNumberCreateForQuery
    {
        fn from(value: StdPrimitiveU8AsNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU8AsNotNullJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU8AsNotNullJsonbNumberSelect {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for StdPrimitiveU8AsNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum StdPrimitiveU8AsNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        In(
            where_filters::PostgresJsonTypeWhereIn<
                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        GreaterThan(
            where_filters::PostgresJsonTypeWhereGreaterThan<
                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        Between(
            where_filters::PostgresJsonTypeWhereBetween<
                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for StdPrimitiveU8AsNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::In(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::Between(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::In(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::Between(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveU8AsNotNullJsonbNumberWhere {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for StdPrimitiveU8AsNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::In(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::GreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::Between(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU8AsNotNullJsonbNumberRead(StdPrimitiveU8AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveU8AsNotNullJsonbNumberRead {
        #[must_use]
        pub const fn new(value: StdPrimitiveU8AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU8AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU8AsNotNullJsonbNumberRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU8AsNotNullJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU8AsNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveU8AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveU8AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct StdPrimitiveU8AsNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type StdPrimitiveU8AsNotNullJsonbNumberReadInner = u8;
    impl From<StdPrimitiveU8AsNotNullJsonbNumberOrigin>
        for StdPrimitiveU8AsNotNullJsonbNumberReadInner
    {
        fn from(value: StdPrimitiveU8AsNotNullJsonbNumberOrigin) -> Self {
            value.0
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU8AsNotNullJsonbNumberUpdate(StdPrimitiveU8AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveU8AsNotNullJsonbNumberUpdate {
        #[must_use]
        pub const fn new(value: StdPrimitiveU8AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU8AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU8AsNotNullJsonbNumberUpdate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveU8AsNotNullJsonbNumberUpdateForQuery(
        StdPrimitiveU8AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveU8AsNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveU8AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU8AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<StdPrimitiveU8AsNotNullJsonbNumberUpdate>
        for StdPrimitiveU8AsNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: StdPrimitiveU8AsNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU8AsNotNullJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU8AsNotNullJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveU8AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveU8AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for StdPrimitiveU8AsNotNullJsonbNumber {
        type TableTypeDeclaration = StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration;
        type Create = StdPrimitiveU8AsNotNullJsonbNumberCreate;
        type CreateForQuery = StdPrimitiveU8AsNotNullJsonbNumberCreateForQuery;
        type Select = StdPrimitiveU8AsNotNullJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',({column_name_and_maybe_field_getter}->'{field_ident}')))"
            ))
        }
        type Where = StdPrimitiveU8AsNotNullJsonbNumberWhere;
        type Read = StdPrimitiveU8AsNotNullJsonbNumberRead;
        type ReadOnlyIds = StdPrimitiveU8AsNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = StdPrimitiveU8AsNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0
        }
        type Update = StdPrimitiveU8AsNotNullJsonbNumberUpdate;
        type UpdateForQuery = StdPrimitiveU8AsNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for StdPrimitiveU8AsNotNullJsonbNumber {
        type PostgresJsonType = Self;
        type Select = StdPrimitiveU8AsNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some(
                postgres_crud_common::std_primitive_u8_test_cases_vec()
                    .into_iter()
                    .map(<Self as postgres_crud_common::PostgresJsonType>::Create::new)
                    .collect(),
            )
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            vec![postgres_crud_common::std_primitive_u8_test_cases_vec().into()]
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: StdPrimitiveU8AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: StdPrimitiveU8AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            StdPrimitiveU8AsNotNullJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                StdPrimitiveU8AsNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            StdPrimitiveU8AsNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            StdPrimitiveU8AsNotNullJsonbNumberWhere::Equal(
                where_filters::PostgresJsonTypeWhereEqual {
                    logical_operator: postgres_crud_common::LogicalOperator::Or,
                    value: StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration::new(
                        create.0.into(),
                    ),
                },
            )
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            let value_7aa498e8 = create.0.0.checked_sub(1)?;
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveU8AsNotNullJsonbNumberWhere::GreaterThan(
                        where_filters::PostgresJsonTypeWhereGreaterThan {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration(
                                StdPrimitiveU8AsNotNullJsonbNumberOrigin(value_7aa498e8),
                            ),
                        },
                    ),
                ),
            ]) {
                Ok(value_6f3e23b5) => Some(value_6f3e23b5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("11287f54-f840-4076-a16b-1a59a74e6dee"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            if let (Some(start), Some(end)) = (create.0.0.checked_sub(1), create.0.0.checked_add(1))
            {
                match where_filters :: Between :: try_new (StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration :: new (start) , StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration :: new (end)) { Ok (value_cdde02cc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: SingleOrMultiple :: Single (StdPrimitiveU8AsNotNullJsonbNumberWhere :: Between (where_filters :: PostgresJsonTypeWhereBetween { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : value_cdde02cc , }))]) { Ok (value_41af48fb) => Some (value_41af48fb) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("5edabfcc-fcbe-419c-a2be-5bd7e961e6e0") } } , Err (error) => None }
            } else {
                None
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveU8AsNotNullJsonbNumberWhere::In(
                        where_filters::PostgresJsonTypeWhereIn {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: where_filters::PostgresJsonTypeNotEmptyUniqueVec::try_new(vec![
                                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    create.0.0,
                                ),
                            ])
                            .expect("2737c0ed-cf4a-4aba-b749-dc7c4e37ff2e"),
                        },
                    ),
                ),
            ]) {
                Ok(value_1c4f89a4) => Some(value_1c4f89a4),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("16ae359d-3869-421b-b37d-85b0b24835bd"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionStdPrimitiveU8AsNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU8AsNullableJsonbNumberOrigin(
        Option<StdPrimitiveU8AsNotNullJsonbNumberOrigin>,
    );
    impl OptionStdPrimitiveU8AsNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU8AsNullableJsonbNumberReadInner) -> Self {
            Self(value.map(StdPrimitiveU8AsNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionStdPrimitiveU8AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveU8AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveU8AsNullableJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<OptionStdPrimitiveU8AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveU8AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveU8AsNullableJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionStdPrimitiveU8AsNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveU8AsNullableJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU8AsNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU8AsNullableJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveU8AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveU8AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU8AsNullableJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration(
        OptionStdPrimitiveU8AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU8AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU8AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveU8AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveU8AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU8AsNullableJsonbNumberCreate(
        OptionStdPrimitiveU8AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU8AsNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU8AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU8AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU8AsNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveU8AsNullableJsonbNumberCreateForQuery(
        OptionStdPrimitiveU8AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU8AsNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU8AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU8AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU8AsNullableJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU8AsNullableJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveU8AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveU8AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionStdPrimitiveU8AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveU8AsNullableJsonbNumberCreateForQuery
    {
        fn from(value: OptionStdPrimitiveU8AsNullableJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU8AsNullableJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU8AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionStdPrimitiveU8AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    pub type OptionStdPrimitiveU8AsNullableJsonbNumberWhere =
        postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter<
            <StdPrimitiveU8AsNotNullJsonbNumber as postgres_crud_common::PostgresJsonType>::Where,
        >;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU8AsNullableJsonbNumberRead(
        OptionStdPrimitiveU8AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU8AsNullableJsonbNumberRead {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU8AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU8AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU8AsNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU8AsNullableJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU8AsNullableJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveU8AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveU8AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionStdPrimitiveU8AsNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionStdPrimitiveU8AsNullableJsonbNumberReadInner = Option<u8>;
    impl From<OptionStdPrimitiveU8AsNullableJsonbNumberOrigin>
        for OptionStdPrimitiveU8AsNullableJsonbNumberReadInner
    {
        fn from(value: OptionStdPrimitiveU8AsNullableJsonbNumberOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU8AsNullableJsonbNumberUpdate(
        OptionStdPrimitiveU8AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU8AsNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU8AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU8AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU8AsNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveU8AsNullableJsonbNumberUpdateForQuery(
        OptionStdPrimitiveU8AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU8AsNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU8AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU8AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionStdPrimitiveU8AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveU8AsNullableJsonbNumberUpdateForQuery
    {
        fn from(value: OptionStdPrimitiveU8AsNullableJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU8AsNullableJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU8AsNullableJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveU8AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveU8AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for OptionStdPrimitiveU8AsNullableJsonbNumber {
        type TableTypeDeclaration = OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration;
        type Create = OptionStdPrimitiveU8AsNullableJsonbNumberCreate;
        type CreateForQuery = OptionStdPrimitiveU8AsNullableJsonbNumberCreateForQuery;
        type Select = OptionStdPrimitiveU8AsNullableJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else ({column_name_and_maybe_field_getter}->'{field_ident}') end)))"
            ))
        }
        type Where = OptionStdPrimitiveU8AsNullableJsonbNumberWhere;
        type Read = OptionStdPrimitiveU8AsNullableJsonbNumberRead;
        type ReadOnlyIds = OptionStdPrimitiveU8AsNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionStdPrimitiveU8AsNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| value_3432e728.0)
        }
        type Update = OptionStdPrimitiveU8AsNullableJsonbNumberUpdate;
        type UpdateForQuery = OptionStdPrimitiveU8AsNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for OptionStdPrimitiveU8AsNullableJsonbNumber {
        type PostgresJsonType = Self;
        type Select = OptionStdPrimitiveU8AsNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveU8AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_97242d4d = Vec::new();
            for el_8f3646f9 in < StdPrimitiveU8AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveU8AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) { for el_35a4dba9 in el_8f3646f9 { acc_97242d4d . push (vec ! [Some (el_35a4dba9)]) ; } }
            acc_97242d4d.push(vec![None]);
            acc_97242d4d
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveU8AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveU8AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionStdPrimitiveU8AsNullableJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionStdPrimitiveU8AsNullableJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionStdPrimitiveU8AsNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter(create.0.0.map(
                |value_18544acf| {
                    postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                        StdPrimitiveU8AsNotNullJsonbNumberWhere::Equal(
                            where_filters::PostgresJsonTypeWhereEqual {
                                logical_operator: postgres_crud_common::LogicalOperator::Or,
                                value: StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    value_18544acf.into(),
                                ),
                            },
                        ),
                    ])
                    .expect("88bfa095-a3ab-4d0c-be71-af63c3acd50f")
                },
            ))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin(
        Vec<StdPrimitiveU8AsNotNullJsonbNumberOrigin>,
    );
    impl VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(
                value
                    .into_iter()
                    .map(StdPrimitiveU8AsNotNullJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
        VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreate(
        VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreateForQuery(
        VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberRead(
        VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner = Vec<u8>;
    impl From<VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner
    {
        fn from(value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdate(
        VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery(
        VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery = VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere;
        type Read = VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0)
                .collect()
        }
        type Update = VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery = VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveU8AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveU8AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveU8AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new({
                let mut acc_f95ec4f2 = vec![];
                for el_ba78af60 in create.0.0 {
                    let value_027d0d3a = el_ba78af60.0.checked_sub(1);
                    match value_027d0d3a {
                        Some(value_0cd93c25) => {
                            acc_f95ec4f2 . push (postgres_crud_common :: SingleOrMultiple :: Single (VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere :: ContainsElGreaterThan (where_filters :: PostgresJsonTypeWhereContainsElGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration (StdPrimitiveU8AsNotNullJsonbNumberOrigin (value_0cd93c25)) }))) ;
                        }
                        None => {
                            return None;
                        }
                    }
                }
                acc_f95ec4f2
            }) {
                Ok(value_69c93ec5) => Some(value_69c93ec5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("47e44ecd-d1c9-4d2b-9d9e-4191cad34be9"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin(
        Vec<OptionStdPrimitiveU8AsNullableJsonbNumberOrigin>,
    );
    impl VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value
                    .into_iter()
                    .map(OptionStdPrimitiveU8AsNullableJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
        VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreate(
        VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreateForQuery(
        VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberRead(
        VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner =
        Vec<Option<u8>>;
    impl From<VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner
    {
        fn from(value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdate(
        VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdateForQuery(
        VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration;
        type Create = VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberCreateForQuery;
        type Select = VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberWhere;
        type Read = VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds = VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                .collect()
        }
        type Update = VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < OptionStdPrimitiveU8AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveU8AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveU8AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match create . 0.0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin(
        Option<VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin>,
    );
    impl OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(value.map(VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
        OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreate(
        OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreateForQuery(
        OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberRead(
        OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner =
        Option<Vec<u8>>;
    impl From<OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner
    {
        fn from(value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdate(
        OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdateForQuery(
        OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberWhere;
        type Read = OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0)
                    .collect()
            })
        }
        type Update = OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveU8AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveU8AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfStdPrimitiveU8AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveU8AsNotNullJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU8AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin(
        Option<VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin>,
    );
    impl OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(value.map(VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberOrigin::new))
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
        OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreate(
        OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreateForQuery(
        OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberRead(
        OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner =
        Option<Vec<Option<u8>>>;
    impl From<OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdate(
        OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdateForQuery(
        OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration =
            OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration;
        type Create = OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberCreateForQuery;
        type Select = OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberWhere;
        type Read = OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds =
            OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner =
            OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                    .collect()
            })
        }
        type Update = OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveU8AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveU8AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfOptionStdPrimitiveU8AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveU8AsNullableJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU8AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct StdPrimitiveU16AsNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU16AsNotNullJsonbNumberOrigin(u16);
    impl StdPrimitiveU16AsNotNullJsonbNumberOrigin {
        #[must_use]
        pub const fn new(value: StdPrimitiveU16AsNotNullJsonbNumberReadInner) -> Self {
            Self(value)
        }
    }
    impl From<StdPrimitiveU16AsNotNullJsonbNumberCreate> for StdPrimitiveU16AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveU16AsNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<StdPrimitiveU16AsNotNullJsonbNumberUpdate> for StdPrimitiveU16AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveU16AsNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for StdPrimitiveU16AsNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveU16AsNotNullJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU16AsNotNullJsonbNumberOrigin {
        fn default_option_some_vec_one_el() -> Self {
            Self(Default::default())
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU16AsNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveU16AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveU16AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU16AsNotNullJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration(
        StdPrimitiveU16AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub const fn new(value: StdPrimitiveU16AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU16AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveU16AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveU16AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU16AsNotNullJsonbNumberCreate(StdPrimitiveU16AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveU16AsNotNullJsonbNumberCreate {
        #[must_use]
        pub const fn new(value: StdPrimitiveU16AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU16AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU16AsNotNullJsonbNumberCreate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveU16AsNotNullJsonbNumberCreateForQuery(
        StdPrimitiveU16AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveU16AsNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveU16AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU16AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU16AsNotNullJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU16AsNotNullJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveU16AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveU16AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<StdPrimitiveU16AsNotNullJsonbNumberCreate>
        for StdPrimitiveU16AsNotNullJsonbNumberCreateForQuery
    {
        fn from(value: StdPrimitiveU16AsNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU16AsNotNullJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU16AsNotNullJsonbNumberSelect {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for StdPrimitiveU16AsNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum StdPrimitiveU16AsNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        In(
            where_filters::PostgresJsonTypeWhereIn<
                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        GreaterThan(
            where_filters::PostgresJsonTypeWhereGreaterThan<
                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        Between(
            where_filters::PostgresJsonTypeWhereBetween<
                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for StdPrimitiveU16AsNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::In(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::Between(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::In(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::Between(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveU16AsNotNullJsonbNumberWhere {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for StdPrimitiveU16AsNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::In(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::GreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::Between(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU16AsNotNullJsonbNumberRead(StdPrimitiveU16AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveU16AsNotNullJsonbNumberRead {
        #[must_use]
        pub const fn new(value: StdPrimitiveU16AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU16AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU16AsNotNullJsonbNumberRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU16AsNotNullJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU16AsNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveU16AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveU16AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct StdPrimitiveU16AsNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type StdPrimitiveU16AsNotNullJsonbNumberReadInner = u16;
    impl From<StdPrimitiveU16AsNotNullJsonbNumberOrigin>
        for StdPrimitiveU16AsNotNullJsonbNumberReadInner
    {
        fn from(value: StdPrimitiveU16AsNotNullJsonbNumberOrigin) -> Self {
            value.0
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU16AsNotNullJsonbNumberUpdate(StdPrimitiveU16AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveU16AsNotNullJsonbNumberUpdate {
        #[must_use]
        pub const fn new(value: StdPrimitiveU16AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU16AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU16AsNotNullJsonbNumberUpdate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveU16AsNotNullJsonbNumberUpdateForQuery(
        StdPrimitiveU16AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveU16AsNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveU16AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU16AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<StdPrimitiveU16AsNotNullJsonbNumberUpdate>
        for StdPrimitiveU16AsNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: StdPrimitiveU16AsNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU16AsNotNullJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU16AsNotNullJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveU16AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveU16AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for StdPrimitiveU16AsNotNullJsonbNumber {
        type TableTypeDeclaration = StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration;
        type Create = StdPrimitiveU16AsNotNullJsonbNumberCreate;
        type CreateForQuery = StdPrimitiveU16AsNotNullJsonbNumberCreateForQuery;
        type Select = StdPrimitiveU16AsNotNullJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',({column_name_and_maybe_field_getter}->'{field_ident}')))"
            ))
        }
        type Where = StdPrimitiveU16AsNotNullJsonbNumberWhere;
        type Read = StdPrimitiveU16AsNotNullJsonbNumberRead;
        type ReadOnlyIds = StdPrimitiveU16AsNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = StdPrimitiveU16AsNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0
        }
        type Update = StdPrimitiveU16AsNotNullJsonbNumberUpdate;
        type UpdateForQuery = StdPrimitiveU16AsNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for StdPrimitiveU16AsNotNullJsonbNumber {
        type PostgresJsonType = Self;
        type Select = StdPrimitiveU16AsNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some(
                postgres_crud_common::std_primitive_u16_test_cases_vec()
                    .into_iter()
                    .map(<Self as postgres_crud_common::PostgresJsonType>::Create::new)
                    .collect(),
            )
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            vec![postgres_crud_common::std_primitive_u16_test_cases_vec().into()]
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: StdPrimitiveU16AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: StdPrimitiveU16AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            StdPrimitiveU16AsNotNullJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                StdPrimitiveU16AsNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            StdPrimitiveU16AsNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            StdPrimitiveU16AsNotNullJsonbNumberWhere::Equal(
                where_filters::PostgresJsonTypeWhereEqual {
                    logical_operator: postgres_crud_common::LogicalOperator::Or,
                    value: StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration::new(
                        create.0.into(),
                    ),
                },
            )
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            let value_7aa498e8 = create.0.0.checked_sub(1)?;
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveU16AsNotNullJsonbNumberWhere::GreaterThan(
                        where_filters::PostgresJsonTypeWhereGreaterThan {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration(
                                StdPrimitiveU16AsNotNullJsonbNumberOrigin(value_7aa498e8),
                            ),
                        },
                    ),
                ),
            ]) {
                Ok(value_6f3e23b5) => Some(value_6f3e23b5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("11287f54-f840-4076-a16b-1a59a74e6dee"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            if let (Some(start), Some(end)) = (create.0.0.checked_sub(1), create.0.0.checked_add(1))
            {
                match where_filters :: Between :: try_new (StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration :: new (start) , StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration :: new (end)) { Ok (value_cdde02cc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: SingleOrMultiple :: Single (StdPrimitiveU16AsNotNullJsonbNumberWhere :: Between (where_filters :: PostgresJsonTypeWhereBetween { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : value_cdde02cc , }))]) { Ok (value_41af48fb) => Some (value_41af48fb) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("5edabfcc-fcbe-419c-a2be-5bd7e961e6e0") } } , Err (error) => None }
            } else {
                None
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveU16AsNotNullJsonbNumberWhere::In(
                        where_filters::PostgresJsonTypeWhereIn {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: where_filters::PostgresJsonTypeNotEmptyUniqueVec::try_new(vec![
                                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    create.0.0,
                                ),
                            ])
                            .expect("2737c0ed-cf4a-4aba-b749-dc7c4e37ff2e"),
                        },
                    ),
                ),
            ]) {
                Ok(value_1c4f89a4) => Some(value_1c4f89a4),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("16ae359d-3869-421b-b37d-85b0b24835bd"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionStdPrimitiveU16AsNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU16AsNullableJsonbNumberOrigin(
        Option<StdPrimitiveU16AsNotNullJsonbNumberOrigin>,
    );
    impl OptionStdPrimitiveU16AsNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU16AsNullableJsonbNumberReadInner) -> Self {
            Self(value.map(StdPrimitiveU16AsNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionStdPrimitiveU16AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveU16AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveU16AsNullableJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<OptionStdPrimitiveU16AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveU16AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveU16AsNullableJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionStdPrimitiveU16AsNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveU16AsNullableJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU16AsNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU16AsNullableJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveU16AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveU16AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU16AsNullableJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration(
        OptionStdPrimitiveU16AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU16AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU16AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveU16AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveU16AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU16AsNullableJsonbNumberCreate(
        OptionStdPrimitiveU16AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU16AsNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU16AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU16AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU16AsNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveU16AsNullableJsonbNumberCreateForQuery(
        OptionStdPrimitiveU16AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU16AsNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU16AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU16AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU16AsNullableJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU16AsNullableJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveU16AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveU16AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionStdPrimitiveU16AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveU16AsNullableJsonbNumberCreateForQuery
    {
        fn from(value: OptionStdPrimitiveU16AsNullableJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU16AsNullableJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU16AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionStdPrimitiveU16AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    pub type OptionStdPrimitiveU16AsNullableJsonbNumberWhere =
        postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter<
            <StdPrimitiveU16AsNotNullJsonbNumber as postgres_crud_common::PostgresJsonType>::Where,
        >;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU16AsNullableJsonbNumberRead(
        OptionStdPrimitiveU16AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU16AsNullableJsonbNumberRead {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU16AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU16AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU16AsNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU16AsNullableJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU16AsNullableJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveU16AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveU16AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionStdPrimitiveU16AsNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionStdPrimitiveU16AsNullableJsonbNumberReadInner = Option<u16>;
    impl From<OptionStdPrimitiveU16AsNullableJsonbNumberOrigin>
        for OptionStdPrimitiveU16AsNullableJsonbNumberReadInner
    {
        fn from(value: OptionStdPrimitiveU16AsNullableJsonbNumberOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU16AsNullableJsonbNumberUpdate(
        OptionStdPrimitiveU16AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU16AsNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU16AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU16AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU16AsNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveU16AsNullableJsonbNumberUpdateForQuery(
        OptionStdPrimitiveU16AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU16AsNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU16AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU16AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionStdPrimitiveU16AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveU16AsNullableJsonbNumberUpdateForQuery
    {
        fn from(value: OptionStdPrimitiveU16AsNullableJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU16AsNullableJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU16AsNullableJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveU16AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveU16AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for OptionStdPrimitiveU16AsNullableJsonbNumber {
        type TableTypeDeclaration = OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration;
        type Create = OptionStdPrimitiveU16AsNullableJsonbNumberCreate;
        type CreateForQuery = OptionStdPrimitiveU16AsNullableJsonbNumberCreateForQuery;
        type Select = OptionStdPrimitiveU16AsNullableJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else ({column_name_and_maybe_field_getter}->'{field_ident}') end)))"
            ))
        }
        type Where = OptionStdPrimitiveU16AsNullableJsonbNumberWhere;
        type Read = OptionStdPrimitiveU16AsNullableJsonbNumberRead;
        type ReadOnlyIds = OptionStdPrimitiveU16AsNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionStdPrimitiveU16AsNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| value_3432e728.0)
        }
        type Update = OptionStdPrimitiveU16AsNullableJsonbNumberUpdate;
        type UpdateForQuery = OptionStdPrimitiveU16AsNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionStdPrimitiveU16AsNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionStdPrimitiveU16AsNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveU16AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_97242d4d = Vec::new();
            for el_8f3646f9 in < StdPrimitiveU16AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveU16AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) { for el_35a4dba9 in el_8f3646f9 { acc_97242d4d . push (vec ! [Some (el_35a4dba9)]) ; } }
            acc_97242d4d.push(vec![None]);
            acc_97242d4d
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveU16AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveU16AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionStdPrimitiveU16AsNullableJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionStdPrimitiveU16AsNullableJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionStdPrimitiveU16AsNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter(create.0.0.map(
                |value_18544acf| {
                    postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                        StdPrimitiveU16AsNotNullJsonbNumberWhere::Equal(
                            where_filters::PostgresJsonTypeWhereEqual {
                                logical_operator: postgres_crud_common::LogicalOperator::Or,
                                value: StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    value_18544acf.into(),
                                ),
                            },
                        ),
                    ])
                    .expect("88bfa095-a3ab-4d0c-be71-af63c3acd50f")
                },
            ))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin(
        Vec<StdPrimitiveU16AsNotNullJsonbNumberOrigin>,
    );
    impl VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(
                value
                    .into_iter()
                    .map(StdPrimitiveU16AsNotNullJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
        VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreate(
        VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreateForQuery(
        VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberRead(
        VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner = Vec<u16>;
    impl From<VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner
    {
        fn from(value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdate(
        VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery(
        VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery = VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere;
        type Read = VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0)
                .collect()
        }
        type Update = VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery = VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveU16AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveU16AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveU16AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new({
                let mut acc_f95ec4f2 = vec![];
                for el_ba78af60 in create.0.0 {
                    let value_027d0d3a = el_ba78af60.0.checked_sub(1);
                    match value_027d0d3a {
                        Some(value_0cd93c25) => {
                            acc_f95ec4f2 . push (postgres_crud_common :: SingleOrMultiple :: Single (VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere :: ContainsElGreaterThan (where_filters :: PostgresJsonTypeWhereContainsElGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration (StdPrimitiveU16AsNotNullJsonbNumberOrigin (value_0cd93c25)) }))) ;
                        }
                        None => {
                            return None;
                        }
                    }
                }
                acc_f95ec4f2
            }) {
                Ok(value_69c93ec5) => Some(value_69c93ec5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("47e44ecd-d1c9-4d2b-9d9e-4191cad34be9"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin(
        Vec<OptionStdPrimitiveU16AsNullableJsonbNumberOrigin>,
    );
    impl VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value
                    .into_iter()
                    .map(OptionStdPrimitiveU16AsNullableJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
        VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreate(
        VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreateForQuery(
        VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberRead(
        VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner =
        Vec<Option<u16>>;
    impl From<VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdate(
        VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdateForQuery(
        VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration;
        type Create = VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberCreateForQuery;
        type Select = VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberWhere;
        type Read = VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds = VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                .collect()
        }
        type Update = VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < OptionStdPrimitiveU16AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveU16AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveU16AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match create . 0.0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin(
        Option<VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin>,
    );
    impl OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(value.map(VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
        OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreate(
        OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreateForQuery(
        OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberRead(
        OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner =
        Option<Vec<u16>>;
    impl From<OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdate(
        OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdateForQuery(
        OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberWhere;
        type Read = OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0)
                    .collect()
            })
        }
        type Update = OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveU16AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveU16AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfStdPrimitiveU16AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveU16AsNotNullJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU16AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin(
        Option<VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin>,
    );
    impl OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value.map(VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberOrigin::new),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
        OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreate(
        OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreateForQuery(
        OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberRead(
        OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner =
        Option<Vec<Option<u16>>>;
    impl From<OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdate(
        OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdateForQuery(
        OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration ;
        type Create = OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberCreateForQuery;
        type Select = OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberWhere;
        type Read = OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds =
            OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner =
            OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                    .collect()
            })
        }
        type Update = OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveU16AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveU16AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfOptionStdPrimitiveU16AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveU16AsNullableJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU16AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct StdPrimitiveU32AsNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU32AsNotNullJsonbNumberOrigin(u32);
    impl StdPrimitiveU32AsNotNullJsonbNumberOrigin {
        #[must_use]
        pub const fn new(value: StdPrimitiveU32AsNotNullJsonbNumberReadInner) -> Self {
            Self(value)
        }
    }
    impl From<StdPrimitiveU32AsNotNullJsonbNumberCreate> for StdPrimitiveU32AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveU32AsNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<StdPrimitiveU32AsNotNullJsonbNumberUpdate> for StdPrimitiveU32AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveU32AsNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for StdPrimitiveU32AsNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveU32AsNotNullJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU32AsNotNullJsonbNumberOrigin {
        fn default_option_some_vec_one_el() -> Self {
            Self(Default::default())
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU32AsNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveU32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveU32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU32AsNotNullJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration(
        StdPrimitiveU32AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub const fn new(value: StdPrimitiveU32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveU32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveU32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU32AsNotNullJsonbNumberCreate(StdPrimitiveU32AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveU32AsNotNullJsonbNumberCreate {
        #[must_use]
        pub const fn new(value: StdPrimitiveU32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU32AsNotNullJsonbNumberCreate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveU32AsNotNullJsonbNumberCreateForQuery(
        StdPrimitiveU32AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveU32AsNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveU32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU32AsNotNullJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU32AsNotNullJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveU32AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveU32AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<StdPrimitiveU32AsNotNullJsonbNumberCreate>
        for StdPrimitiveU32AsNotNullJsonbNumberCreateForQuery
    {
        fn from(value: StdPrimitiveU32AsNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU32AsNotNullJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU32AsNotNullJsonbNumberSelect {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for StdPrimitiveU32AsNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum StdPrimitiveU32AsNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        In(
            where_filters::PostgresJsonTypeWhereIn<
                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        GreaterThan(
            where_filters::PostgresJsonTypeWhereGreaterThan<
                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        Between(
            where_filters::PostgresJsonTypeWhereBetween<
                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for StdPrimitiveU32AsNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::In(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::Between(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::In(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::Between(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveU32AsNotNullJsonbNumberWhere {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for StdPrimitiveU32AsNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::In(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::GreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::Between(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU32AsNotNullJsonbNumberRead(StdPrimitiveU32AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveU32AsNotNullJsonbNumberRead {
        #[must_use]
        pub const fn new(value: StdPrimitiveU32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU32AsNotNullJsonbNumberRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU32AsNotNullJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU32AsNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveU32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveU32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct StdPrimitiveU32AsNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type StdPrimitiveU32AsNotNullJsonbNumberReadInner = u32;
    impl From<StdPrimitiveU32AsNotNullJsonbNumberOrigin>
        for StdPrimitiveU32AsNotNullJsonbNumberReadInner
    {
        fn from(value: StdPrimitiveU32AsNotNullJsonbNumberOrigin) -> Self {
            value.0
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU32AsNotNullJsonbNumberUpdate(StdPrimitiveU32AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveU32AsNotNullJsonbNumberUpdate {
        #[must_use]
        pub const fn new(value: StdPrimitiveU32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU32AsNotNullJsonbNumberUpdate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveU32AsNotNullJsonbNumberUpdateForQuery(
        StdPrimitiveU32AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveU32AsNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveU32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<StdPrimitiveU32AsNotNullJsonbNumberUpdate>
        for StdPrimitiveU32AsNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: StdPrimitiveU32AsNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU32AsNotNullJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU32AsNotNullJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveU32AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveU32AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for StdPrimitiveU32AsNotNullJsonbNumber {
        type TableTypeDeclaration = StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration;
        type Create = StdPrimitiveU32AsNotNullJsonbNumberCreate;
        type CreateForQuery = StdPrimitiveU32AsNotNullJsonbNumberCreateForQuery;
        type Select = StdPrimitiveU32AsNotNullJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',({column_name_and_maybe_field_getter}->'{field_ident}')))"
            ))
        }
        type Where = StdPrimitiveU32AsNotNullJsonbNumberWhere;
        type Read = StdPrimitiveU32AsNotNullJsonbNumberRead;
        type ReadOnlyIds = StdPrimitiveU32AsNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = StdPrimitiveU32AsNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0
        }
        type Update = StdPrimitiveU32AsNotNullJsonbNumberUpdate;
        type UpdateForQuery = StdPrimitiveU32AsNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for StdPrimitiveU32AsNotNullJsonbNumber {
        type PostgresJsonType = Self;
        type Select = StdPrimitiveU32AsNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some(
                postgres_crud_common::std_primitive_u32_test_cases_vec()
                    .into_iter()
                    .map(<Self as postgres_crud_common::PostgresJsonType>::Create::new)
                    .collect(),
            )
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            vec![postgres_crud_common::std_primitive_u32_test_cases_vec().into()]
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: StdPrimitiveU32AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: StdPrimitiveU32AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            StdPrimitiveU32AsNotNullJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                StdPrimitiveU32AsNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            StdPrimitiveU32AsNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            StdPrimitiveU32AsNotNullJsonbNumberWhere::Equal(
                where_filters::PostgresJsonTypeWhereEqual {
                    logical_operator: postgres_crud_common::LogicalOperator::Or,
                    value: StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration::new(
                        create.0.into(),
                    ),
                },
            )
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            let value_7aa498e8 = create.0.0.checked_sub(1)?;
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveU32AsNotNullJsonbNumberWhere::GreaterThan(
                        where_filters::PostgresJsonTypeWhereGreaterThan {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration(
                                StdPrimitiveU32AsNotNullJsonbNumberOrigin(value_7aa498e8),
                            ),
                        },
                    ),
                ),
            ]) {
                Ok(value_6f3e23b5) => Some(value_6f3e23b5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("11287f54-f840-4076-a16b-1a59a74e6dee"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            if let (Some(start), Some(end)) = (create.0.0.checked_sub(1), create.0.0.checked_add(1))
            {
                match where_filters :: Between :: try_new (StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration :: new (start) , StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration :: new (end)) { Ok (value_cdde02cc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: SingleOrMultiple :: Single (StdPrimitiveU32AsNotNullJsonbNumberWhere :: Between (where_filters :: PostgresJsonTypeWhereBetween { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : value_cdde02cc , }))]) { Ok (value_41af48fb) => Some (value_41af48fb) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("5edabfcc-fcbe-419c-a2be-5bd7e961e6e0") } } , Err (error) => None }
            } else {
                None
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveU32AsNotNullJsonbNumberWhere::In(
                        where_filters::PostgresJsonTypeWhereIn {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: where_filters::PostgresJsonTypeNotEmptyUniqueVec::try_new(vec![
                                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    create.0.0,
                                ),
                            ])
                            .expect("2737c0ed-cf4a-4aba-b749-dc7c4e37ff2e"),
                        },
                    ),
                ),
            ]) {
                Ok(value_1c4f89a4) => Some(value_1c4f89a4),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("16ae359d-3869-421b-b37d-85b0b24835bd"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionStdPrimitiveU32AsNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU32AsNullableJsonbNumberOrigin(
        Option<StdPrimitiveU32AsNotNullJsonbNumberOrigin>,
    );
    impl OptionStdPrimitiveU32AsNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU32AsNullableJsonbNumberReadInner) -> Self {
            Self(value.map(StdPrimitiveU32AsNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionStdPrimitiveU32AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveU32AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveU32AsNullableJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<OptionStdPrimitiveU32AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveU32AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveU32AsNullableJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionStdPrimitiveU32AsNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveU32AsNullableJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU32AsNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU32AsNullableJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveU32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveU32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU32AsNullableJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration(
        OptionStdPrimitiveU32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveU32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveU32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU32AsNullableJsonbNumberCreate(
        OptionStdPrimitiveU32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU32AsNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU32AsNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveU32AsNullableJsonbNumberCreateForQuery(
        OptionStdPrimitiveU32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU32AsNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU32AsNullableJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU32AsNullableJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveU32AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveU32AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionStdPrimitiveU32AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveU32AsNullableJsonbNumberCreateForQuery
    {
        fn from(value: OptionStdPrimitiveU32AsNullableJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU32AsNullableJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU32AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionStdPrimitiveU32AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    pub type OptionStdPrimitiveU32AsNullableJsonbNumberWhere =
        postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter<
            <StdPrimitiveU32AsNotNullJsonbNumber as postgres_crud_common::PostgresJsonType>::Where,
        >;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU32AsNullableJsonbNumberRead(
        OptionStdPrimitiveU32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU32AsNullableJsonbNumberRead {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU32AsNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU32AsNullableJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU32AsNullableJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveU32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveU32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionStdPrimitiveU32AsNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionStdPrimitiveU32AsNullableJsonbNumberReadInner = Option<u32>;
    impl From<OptionStdPrimitiveU32AsNullableJsonbNumberOrigin>
        for OptionStdPrimitiveU32AsNullableJsonbNumberReadInner
    {
        fn from(value: OptionStdPrimitiveU32AsNullableJsonbNumberOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU32AsNullableJsonbNumberUpdate(
        OptionStdPrimitiveU32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU32AsNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU32AsNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveU32AsNullableJsonbNumberUpdateForQuery(
        OptionStdPrimitiveU32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU32AsNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionStdPrimitiveU32AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveU32AsNullableJsonbNumberUpdateForQuery
    {
        fn from(value: OptionStdPrimitiveU32AsNullableJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU32AsNullableJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU32AsNullableJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveU32AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveU32AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for OptionStdPrimitiveU32AsNullableJsonbNumber {
        type TableTypeDeclaration = OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration;
        type Create = OptionStdPrimitiveU32AsNullableJsonbNumberCreate;
        type CreateForQuery = OptionStdPrimitiveU32AsNullableJsonbNumberCreateForQuery;
        type Select = OptionStdPrimitiveU32AsNullableJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else ({column_name_and_maybe_field_getter}->'{field_ident}') end)))"
            ))
        }
        type Where = OptionStdPrimitiveU32AsNullableJsonbNumberWhere;
        type Read = OptionStdPrimitiveU32AsNullableJsonbNumberRead;
        type ReadOnlyIds = OptionStdPrimitiveU32AsNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionStdPrimitiveU32AsNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| value_3432e728.0)
        }
        type Update = OptionStdPrimitiveU32AsNullableJsonbNumberUpdate;
        type UpdateForQuery = OptionStdPrimitiveU32AsNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionStdPrimitiveU32AsNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionStdPrimitiveU32AsNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveU32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_97242d4d = Vec::new();
            for el_8f3646f9 in < StdPrimitiveU32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveU32AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) { for el_35a4dba9 in el_8f3646f9 { acc_97242d4d . push (vec ! [Some (el_35a4dba9)]) ; } }
            acc_97242d4d.push(vec![None]);
            acc_97242d4d
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveU32AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveU32AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionStdPrimitiveU32AsNullableJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionStdPrimitiveU32AsNullableJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionStdPrimitiveU32AsNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter(create.0.0.map(
                |value_18544acf| {
                    postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                        StdPrimitiveU32AsNotNullJsonbNumberWhere::Equal(
                            where_filters::PostgresJsonTypeWhereEqual {
                                logical_operator: postgres_crud_common::LogicalOperator::Or,
                                value: StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    value_18544acf.into(),
                                ),
                            },
                        ),
                    ])
                    .expect("88bfa095-a3ab-4d0c-be71-af63c3acd50f")
                },
            ))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin(
        Vec<StdPrimitiveU32AsNotNullJsonbNumberOrigin>,
    );
    impl VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(
                value
                    .into_iter()
                    .map(StdPrimitiveU32AsNotNullJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
        VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreate(
        VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery(
        VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberRead(
        VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner = Vec<u32>;
    impl From<VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner
    {
        fn from(value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdate(
        VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery(
        VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery = VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere;
        type Read = VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0)
                .collect()
        }
        type Update = VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery = VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveU32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveU32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveU32AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new({
                let mut acc_f95ec4f2 = vec![];
                for el_ba78af60 in create.0.0 {
                    let value_027d0d3a = el_ba78af60.0.checked_sub(1);
                    match value_027d0d3a {
                        Some(value_0cd93c25) => {
                            acc_f95ec4f2 . push (postgres_crud_common :: SingleOrMultiple :: Single (VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere :: ContainsElGreaterThan (where_filters :: PostgresJsonTypeWhereContainsElGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration (StdPrimitiveU32AsNotNullJsonbNumberOrigin (value_0cd93c25)) }))) ;
                        }
                        None => {
                            return None;
                        }
                    }
                }
                acc_f95ec4f2
            }) {
                Ok(value_69c93ec5) => Some(value_69c93ec5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("47e44ecd-d1c9-4d2b-9d9e-4191cad34be9"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin(
        Vec<OptionStdPrimitiveU32AsNullableJsonbNumberOrigin>,
    );
    impl VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value
                    .into_iter()
                    .map(OptionStdPrimitiveU32AsNullableJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
        VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreate(
        VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreateForQuery(
        VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberRead(
        VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner =
        Vec<Option<u32>>;
    impl From<VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdate(
        VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery(
        VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration;
        type Create = VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberCreateForQuery;
        type Select = VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberWhere;
        type Read = VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds = VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                .collect()
        }
        type Update = VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < OptionStdPrimitiveU32AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveU32AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveU32AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match create . 0.0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin(
        Option<VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin>,
    );
    impl OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(value.map(VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
        OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreate(
        OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreateForQuery(
        OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberRead(
        OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner =
        Option<Vec<u32>>;
    impl From<OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdate(
        OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery(
        OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberWhere;
        type Read = OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0)
                    .collect()
            })
        }
        type Update = OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveU32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveU32AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfStdPrimitiveU32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveU32AsNotNullJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU32AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin(
        Option<VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin>,
    );
    impl OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value.map(VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberOrigin::new),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
        OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreate(
        OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreateForQuery(
        OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberRead(
        OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner =
        Option<Vec<Option<u32>>>;
    impl From<OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdate(
        OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdateForQuery(
        OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration ;
        type Create = OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberCreateForQuery;
        type Select = OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberWhere;
        type Read = OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds =
            OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner =
            OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                    .collect()
            })
        }
        type Update = OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveU32AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveU32AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfOptionStdPrimitiveU32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveU32AsNullableJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU32AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct StdPrimitiveU64AsNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU64AsNotNullJsonbNumberOrigin(u64);
    impl StdPrimitiveU64AsNotNullJsonbNumberOrigin {
        #[must_use]
        pub const fn new(value: StdPrimitiveU64AsNotNullJsonbNumberReadInner) -> Self {
            Self(value)
        }
    }
    impl From<StdPrimitiveU64AsNotNullJsonbNumberCreate> for StdPrimitiveU64AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveU64AsNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<StdPrimitiveU64AsNotNullJsonbNumberUpdate> for StdPrimitiveU64AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveU64AsNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for StdPrimitiveU64AsNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveU64AsNotNullJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU64AsNotNullJsonbNumberOrigin {
        fn default_option_some_vec_one_el() -> Self {
            Self(Default::default())
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU64AsNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveU64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveU64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU64AsNotNullJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration(
        StdPrimitiveU64AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub const fn new(value: StdPrimitiveU64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveU64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveU64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU64AsNotNullJsonbNumberCreate(StdPrimitiveU64AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveU64AsNotNullJsonbNumberCreate {
        #[must_use]
        pub const fn new(value: StdPrimitiveU64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU64AsNotNullJsonbNumberCreate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveU64AsNotNullJsonbNumberCreateForQuery(
        StdPrimitiveU64AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveU64AsNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveU64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU64AsNotNullJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU64AsNotNullJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveU64AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveU64AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<StdPrimitiveU64AsNotNullJsonbNumberCreate>
        for StdPrimitiveU64AsNotNullJsonbNumberCreateForQuery
    {
        fn from(value: StdPrimitiveU64AsNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU64AsNotNullJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU64AsNotNullJsonbNumberSelect {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for StdPrimitiveU64AsNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum StdPrimitiveU64AsNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        In(
            where_filters::PostgresJsonTypeWhereIn<
                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        GreaterThan(
            where_filters::PostgresJsonTypeWhereGreaterThan<
                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        Between(
            where_filters::PostgresJsonTypeWhereBetween<
                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for StdPrimitiveU64AsNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::In(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::Between(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::In(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::Between(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveU64AsNotNullJsonbNumberWhere {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for StdPrimitiveU64AsNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::In(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::GreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::Between(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU64AsNotNullJsonbNumberRead(StdPrimitiveU64AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveU64AsNotNullJsonbNumberRead {
        #[must_use]
        pub const fn new(value: StdPrimitiveU64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU64AsNotNullJsonbNumberRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU64AsNotNullJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU64AsNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveU64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveU64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct StdPrimitiveU64AsNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type StdPrimitiveU64AsNotNullJsonbNumberReadInner = u64;
    impl From<StdPrimitiveU64AsNotNullJsonbNumberOrigin>
        for StdPrimitiveU64AsNotNullJsonbNumberReadInner
    {
        fn from(value: StdPrimitiveU64AsNotNullJsonbNumberOrigin) -> Self {
            value.0
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveU64AsNotNullJsonbNumberUpdate(StdPrimitiveU64AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveU64AsNotNullJsonbNumberUpdate {
        #[must_use]
        pub const fn new(value: StdPrimitiveU64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveU64AsNotNullJsonbNumberUpdate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveU64AsNotNullJsonbNumberUpdateForQuery(
        StdPrimitiveU64AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveU64AsNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveU64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveU64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<StdPrimitiveU64AsNotNullJsonbNumberUpdate>
        for StdPrimitiveU64AsNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: StdPrimitiveU64AsNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveU64AsNotNullJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveU64AsNotNullJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveU64AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveU64AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for StdPrimitiveU64AsNotNullJsonbNumber {
        type TableTypeDeclaration = StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration;
        type Create = StdPrimitiveU64AsNotNullJsonbNumberCreate;
        type CreateForQuery = StdPrimitiveU64AsNotNullJsonbNumberCreateForQuery;
        type Select = StdPrimitiveU64AsNotNullJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',({column_name_and_maybe_field_getter}->'{field_ident}')))"
            ))
        }
        type Where = StdPrimitiveU64AsNotNullJsonbNumberWhere;
        type Read = StdPrimitiveU64AsNotNullJsonbNumberRead;
        type ReadOnlyIds = StdPrimitiveU64AsNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = StdPrimitiveU64AsNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0
        }
        type Update = StdPrimitiveU64AsNotNullJsonbNumberUpdate;
        type UpdateForQuery = StdPrimitiveU64AsNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for StdPrimitiveU64AsNotNullJsonbNumber {
        type PostgresJsonType = Self;
        type Select = StdPrimitiveU64AsNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some(
                postgres_crud_common::std_primitive_u64_test_cases_vec()
                    .into_iter()
                    .map(<Self as postgres_crud_common::PostgresJsonType>::Create::new)
                    .collect(),
            )
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            vec![postgres_crud_common::std_primitive_u64_test_cases_vec().into()]
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: StdPrimitiveU64AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: StdPrimitiveU64AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            StdPrimitiveU64AsNotNullJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                StdPrimitiveU64AsNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            StdPrimitiveU64AsNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            StdPrimitiveU64AsNotNullJsonbNumberWhere::Equal(
                where_filters::PostgresJsonTypeWhereEqual {
                    logical_operator: postgres_crud_common::LogicalOperator::Or,
                    value: StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration::new(
                        create.0.into(),
                    ),
                },
            )
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            let value_7aa498e8 = create.0.0.checked_sub(1)?;
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveU64AsNotNullJsonbNumberWhere::GreaterThan(
                        where_filters::PostgresJsonTypeWhereGreaterThan {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration(
                                StdPrimitiveU64AsNotNullJsonbNumberOrigin(value_7aa498e8),
                            ),
                        },
                    ),
                ),
            ]) {
                Ok(value_6f3e23b5) => Some(value_6f3e23b5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("11287f54-f840-4076-a16b-1a59a74e6dee"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            if let (Some(start), Some(end)) = (create.0.0.checked_sub(1), create.0.0.checked_add(1))
            {
                match where_filters :: Between :: try_new (StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration :: new (start) , StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration :: new (end)) { Ok (value_cdde02cc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: SingleOrMultiple :: Single (StdPrimitiveU64AsNotNullJsonbNumberWhere :: Between (where_filters :: PostgresJsonTypeWhereBetween { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : value_cdde02cc , }))]) { Ok (value_41af48fb) => Some (value_41af48fb) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("5edabfcc-fcbe-419c-a2be-5bd7e961e6e0") } } , Err (error) => None }
            } else {
                None
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveU64AsNotNullJsonbNumberWhere::In(
                        where_filters::PostgresJsonTypeWhereIn {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: where_filters::PostgresJsonTypeNotEmptyUniqueVec::try_new(vec![
                                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    create.0.0,
                                ),
                            ])
                            .expect("2737c0ed-cf4a-4aba-b749-dc7c4e37ff2e"),
                        },
                    ),
                ),
            ]) {
                Ok(value_1c4f89a4) => Some(value_1c4f89a4),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("16ae359d-3869-421b-b37d-85b0b24835bd"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionStdPrimitiveU64AsNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU64AsNullableJsonbNumberOrigin(
        Option<StdPrimitiveU64AsNotNullJsonbNumberOrigin>,
    );
    impl OptionStdPrimitiveU64AsNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU64AsNullableJsonbNumberReadInner) -> Self {
            Self(value.map(StdPrimitiveU64AsNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionStdPrimitiveU64AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveU64AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveU64AsNullableJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<OptionStdPrimitiveU64AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveU64AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveU64AsNullableJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionStdPrimitiveU64AsNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveU64AsNullableJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU64AsNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU64AsNullableJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveU64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveU64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU64AsNullableJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration(
        OptionStdPrimitiveU64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveU64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveU64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU64AsNullableJsonbNumberCreate(
        OptionStdPrimitiveU64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU64AsNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU64AsNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveU64AsNullableJsonbNumberCreateForQuery(
        OptionStdPrimitiveU64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU64AsNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU64AsNullableJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU64AsNullableJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveU64AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveU64AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionStdPrimitiveU64AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveU64AsNullableJsonbNumberCreateForQuery
    {
        fn from(value: OptionStdPrimitiveU64AsNullableJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU64AsNullableJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU64AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionStdPrimitiveU64AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    pub type OptionStdPrimitiveU64AsNullableJsonbNumberWhere =
        postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter<
            <StdPrimitiveU64AsNotNullJsonbNumber as postgres_crud_common::PostgresJsonType>::Where,
        >;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU64AsNullableJsonbNumberRead(
        OptionStdPrimitiveU64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU64AsNullableJsonbNumberRead {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU64AsNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU64AsNullableJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU64AsNullableJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveU64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveU64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionStdPrimitiveU64AsNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionStdPrimitiveU64AsNullableJsonbNumberReadInner = Option<u64>;
    impl From<OptionStdPrimitiveU64AsNullableJsonbNumberOrigin>
        for OptionStdPrimitiveU64AsNullableJsonbNumberReadInner
    {
        fn from(value: OptionStdPrimitiveU64AsNullableJsonbNumberOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveU64AsNullableJsonbNumberUpdate(
        OptionStdPrimitiveU64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU64AsNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveU64AsNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveU64AsNullableJsonbNumberUpdateForQuery(
        OptionStdPrimitiveU64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveU64AsNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveU64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveU64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionStdPrimitiveU64AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveU64AsNullableJsonbNumberUpdateForQuery
    {
        fn from(value: OptionStdPrimitiveU64AsNullableJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveU64AsNullableJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveU64AsNullableJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveU64AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveU64AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for OptionStdPrimitiveU64AsNullableJsonbNumber {
        type TableTypeDeclaration = OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration;
        type Create = OptionStdPrimitiveU64AsNullableJsonbNumberCreate;
        type CreateForQuery = OptionStdPrimitiveU64AsNullableJsonbNumberCreateForQuery;
        type Select = OptionStdPrimitiveU64AsNullableJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else ({column_name_and_maybe_field_getter}->'{field_ident}') end)))"
            ))
        }
        type Where = OptionStdPrimitiveU64AsNullableJsonbNumberWhere;
        type Read = OptionStdPrimitiveU64AsNullableJsonbNumberRead;
        type ReadOnlyIds = OptionStdPrimitiveU64AsNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionStdPrimitiveU64AsNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| value_3432e728.0)
        }
        type Update = OptionStdPrimitiveU64AsNullableJsonbNumberUpdate;
        type UpdateForQuery = OptionStdPrimitiveU64AsNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionStdPrimitiveU64AsNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionStdPrimitiveU64AsNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveU64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_97242d4d = Vec::new();
            for el_8f3646f9 in < StdPrimitiveU64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveU64AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) { for el_35a4dba9 in el_8f3646f9 { acc_97242d4d . push (vec ! [Some (el_35a4dba9)]) ; } }
            acc_97242d4d.push(vec![None]);
            acc_97242d4d
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveU64AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveU64AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionStdPrimitiveU64AsNullableJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionStdPrimitiveU64AsNullableJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionStdPrimitiveU64AsNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter(create.0.0.map(
                |value_18544acf| {
                    postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                        StdPrimitiveU64AsNotNullJsonbNumberWhere::Equal(
                            where_filters::PostgresJsonTypeWhereEqual {
                                logical_operator: postgres_crud_common::LogicalOperator::Or,
                                value: StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    value_18544acf.into(),
                                ),
                            },
                        ),
                    ])
                    .expect("88bfa095-a3ab-4d0c-be71-af63c3acd50f")
                },
            ))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin(
        Vec<StdPrimitiveU64AsNotNullJsonbNumberOrigin>,
    );
    impl VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(
                value
                    .into_iter()
                    .map(StdPrimitiveU64AsNotNullJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
        VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreate(
        VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery(
        VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberRead(
        VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner = Vec<u64>;
    impl From<VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner
    {
        fn from(value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdate(
        VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery(
        VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery = VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere;
        type Read = VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0)
                .collect()
        }
        type Update = VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery = VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveU64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveU64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveU64AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new({
                let mut acc_f95ec4f2 = vec![];
                for el_ba78af60 in create.0.0 {
                    let value_027d0d3a = el_ba78af60.0.checked_sub(1);
                    match value_027d0d3a {
                        Some(value_0cd93c25) => {
                            acc_f95ec4f2 . push (postgres_crud_common :: SingleOrMultiple :: Single (VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere :: ContainsElGreaterThan (where_filters :: PostgresJsonTypeWhereContainsElGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration (StdPrimitiveU64AsNotNullJsonbNumberOrigin (value_0cd93c25)) }))) ;
                        }
                        None => {
                            return None;
                        }
                    }
                }
                acc_f95ec4f2
            }) {
                Ok(value_69c93ec5) => Some(value_69c93ec5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("47e44ecd-d1c9-4d2b-9d9e-4191cad34be9"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin(
        Vec<OptionStdPrimitiveU64AsNullableJsonbNumberOrigin>,
    );
    impl VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value
                    .into_iter()
                    .map(OptionStdPrimitiveU64AsNullableJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
        VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreate(
        VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreateForQuery(
        VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberRead(
        VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner =
        Vec<Option<u64>>;
    impl From<VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdate(
        VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery(
        VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration;
        type Create = VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberCreateForQuery;
        type Select = VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberWhere;
        type Read = VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds = VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                .collect()
        }
        type Update = VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < OptionStdPrimitiveU64AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveU64AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveU64AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match create . 0.0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin(
        Option<VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin>,
    );
    impl OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(value.map(VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
        OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreate(
        OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreateForQuery(
        OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberRead(
        OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner =
        Option<Vec<u64>>;
    impl From<OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdate(
        OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery(
        OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberWhere;
        type Read = OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0)
                    .collect()
            })
        }
        type Update = OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveU64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveU64AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfStdPrimitiveU64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveU64AsNotNullJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveU64AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin(
        Option<VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin>,
    );
    impl OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value.map(VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberOrigin::new),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
        OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreate(
        OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreateForQuery(
        OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberRead(
        OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner =
        Option<Vec<Option<u64>>>;
    impl From<OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdate(
        OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdateForQuery(
        OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration ;
        type Create = OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberCreateForQuery;
        type Select = OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberWhere;
        type Read = OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds =
            OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner =
            OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                    .collect()
            })
        }
        type Update = OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveU64AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveU64AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfOptionStdPrimitiveU64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveU64AsNullableJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveU64AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct StdPrimitiveF32AsNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveF32AsNotNullJsonbNumberOrigin(f32);
    impl StdPrimitiveF32AsNotNullJsonbNumberOrigin {
        #[must_use]
        pub const fn new(value: StdPrimitiveF32AsNotNullJsonbNumberReadInner) -> Self {
            Self(value)
        }
    }
    impl From<StdPrimitiveF32AsNotNullJsonbNumberCreate> for StdPrimitiveF32AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveF32AsNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<StdPrimitiveF32AsNotNullJsonbNumberUpdate> for StdPrimitiveF32AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveF32AsNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for StdPrimitiveF32AsNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveF32AsNotNullJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveF32AsNotNullJsonbNumberOrigin {
        fn default_option_some_vec_one_el() -> Self {
            Self(Default::default())
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF32AsNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveF32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveF32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF32AsNotNullJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration(
        StdPrimitiveF32AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub const fn new(value: StdPrimitiveF32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveF32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveF32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveF32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveF32AsNotNullJsonbNumberCreate(StdPrimitiveF32AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveF32AsNotNullJsonbNumberCreate {
        #[must_use]
        pub const fn new(value: StdPrimitiveF32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveF32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveF32AsNotNullJsonbNumberCreate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveF32AsNotNullJsonbNumberCreateForQuery(
        StdPrimitiveF32AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveF32AsNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveF32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveF32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF32AsNotNullJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF32AsNotNullJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveF32AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveF32AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<StdPrimitiveF32AsNotNullJsonbNumberCreate>
        for StdPrimitiveF32AsNotNullJsonbNumberCreateForQuery
    {
        fn from(value: StdPrimitiveF32AsNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveF32AsNotNullJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveF32AsNotNullJsonbNumberSelect {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for StdPrimitiveF32AsNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum StdPrimitiveF32AsNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        In(
            where_filters::PostgresJsonTypeWhereIn<
                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        GreaterThan(
            where_filters::PostgresJsonTypeWhereGreaterThan<
                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        Between(
            where_filters::PostgresJsonTypeWhereBetween<
                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for StdPrimitiveF32AsNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::In(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::Between(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::In(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::Between(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveF32AsNotNullJsonbNumberWhere {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for StdPrimitiveF32AsNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::In(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::GreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::Between(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveF32AsNotNullJsonbNumberRead(StdPrimitiveF32AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveF32AsNotNullJsonbNumberRead {
        #[must_use]
        pub const fn new(value: StdPrimitiveF32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveF32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveF32AsNotNullJsonbNumberRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF32AsNotNullJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF32AsNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveF32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveF32AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct StdPrimitiveF32AsNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type StdPrimitiveF32AsNotNullJsonbNumberReadInner = f32;
    impl From<StdPrimitiveF32AsNotNullJsonbNumberOrigin>
        for StdPrimitiveF32AsNotNullJsonbNumberReadInner
    {
        fn from(value: StdPrimitiveF32AsNotNullJsonbNumberOrigin) -> Self {
            value.0
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveF32AsNotNullJsonbNumberUpdate(StdPrimitiveF32AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveF32AsNotNullJsonbNumberUpdate {
        #[must_use]
        pub const fn new(value: StdPrimitiveF32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveF32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveF32AsNotNullJsonbNumberUpdate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveF32AsNotNullJsonbNumberUpdateForQuery(
        StdPrimitiveF32AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveF32AsNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveF32AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveF32AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<StdPrimitiveF32AsNotNullJsonbNumberUpdate>
        for StdPrimitiveF32AsNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: StdPrimitiveF32AsNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF32AsNotNullJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF32AsNotNullJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveF32AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveF32AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for StdPrimitiveF32AsNotNullJsonbNumber {
        type TableTypeDeclaration = StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration;
        type Create = StdPrimitiveF32AsNotNullJsonbNumberCreate;
        type CreateForQuery = StdPrimitiveF32AsNotNullJsonbNumberCreateForQuery;
        type Select = StdPrimitiveF32AsNotNullJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',({column_name_and_maybe_field_getter}->'{field_ident}')))"
            ))
        }
        type Where = StdPrimitiveF32AsNotNullJsonbNumberWhere;
        type Read = StdPrimitiveF32AsNotNullJsonbNumberRead;
        type ReadOnlyIds = StdPrimitiveF32AsNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = StdPrimitiveF32AsNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0
        }
        type Update = StdPrimitiveF32AsNotNullJsonbNumberUpdate;
        type UpdateForQuery = StdPrimitiveF32AsNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for StdPrimitiveF32AsNotNullJsonbNumber {
        type PostgresJsonType = Self;
        type Select = StdPrimitiveF32AsNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some(
                postgres_crud_common::std_primitive_f32_test_cases_vec()
                    .into_iter()
                    .map(<Self as postgres_crud_common::PostgresJsonType>::Create::new)
                    .collect(),
            )
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            vec![postgres_crud_common::std_primitive_f32_test_cases_vec().into()]
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: StdPrimitiveF32AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: StdPrimitiveF32AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            StdPrimitiveF32AsNotNullJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                StdPrimitiveF32AsNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            StdPrimitiveF32AsNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            StdPrimitiveF32AsNotNullJsonbNumberWhere::Equal(
                where_filters::PostgresJsonTypeWhereEqual {
                    logical_operator: postgres_crud_common::LogicalOperator::Or,
                    value: StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration::new(
                        create.0.into(),
                    ),
                },
            )
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            let value_7aa498e8 = {
                let value = create.0.0 - 1.0f32;
                if (create.0.0 - value).abs() < 0.1f32 {
                    None
                } else {
                    value.is_finite().then_some(value)
                }
            }?;
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveF32AsNotNullJsonbNumberWhere::GreaterThan(
                        where_filters::PostgresJsonTypeWhereGreaterThan {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration(
                                StdPrimitiveF32AsNotNullJsonbNumberOrigin(value_7aa498e8),
                            ),
                        },
                    ),
                ),
            ]) {
                Ok(value_6f3e23b5) => Some(value_6f3e23b5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("11287f54-f840-4076-a16b-1a59a74e6dee"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            if let (Some(start), Some(end)) = (
                {
                    let value = create.0.0 - 1.0;
                    value.is_finite().then_some(value)
                },
                {
                    let value = create.0.0 + 1.0;
                    value.is_finite().then_some(value)
                },
            ) {
                match where_filters :: Between :: try_new (StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration :: new (start) , StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration :: new (end)) { Ok (value_cdde02cc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: SingleOrMultiple :: Single (StdPrimitiveF32AsNotNullJsonbNumberWhere :: Between (where_filters :: PostgresJsonTypeWhereBetween { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : value_cdde02cc , }))]) { Ok (value_41af48fb) => Some (value_41af48fb) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("5edabfcc-fcbe-419c-a2be-5bd7e961e6e0") } } , Err (error) => None }
            } else {
                None
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveF32AsNotNullJsonbNumberWhere::In(
                        where_filters::PostgresJsonTypeWhereIn {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: where_filters::PostgresJsonTypeNotEmptyUniqueVec::try_new(vec![
                                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    create.0.0,
                                ),
                            ])
                            .expect("2737c0ed-cf4a-4aba-b749-dc7c4e37ff2e"),
                        },
                    ),
                ),
            ]) {
                Ok(value_1c4f89a4) => Some(value_1c4f89a4),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("16ae359d-3869-421b-b37d-85b0b24835bd"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionStdPrimitiveF32AsNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveF32AsNullableJsonbNumberOrigin(
        Option<StdPrimitiveF32AsNotNullJsonbNumberOrigin>,
    );
    impl OptionStdPrimitiveF32AsNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF32AsNullableJsonbNumberReadInner) -> Self {
            Self(value.map(StdPrimitiveF32AsNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionStdPrimitiveF32AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveF32AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveF32AsNullableJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<OptionStdPrimitiveF32AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveF32AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveF32AsNullableJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionStdPrimitiveF32AsNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveF32AsNullableJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveF32AsNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF32AsNullableJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveF32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveF32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveF32AsNullableJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration(
        OptionStdPrimitiveF32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveF32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveF32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveF32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveF32AsNullableJsonbNumberCreate(
        OptionStdPrimitiveF32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveF32AsNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveF32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveF32AsNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveF32AsNullableJsonbNumberCreateForQuery(
        OptionStdPrimitiveF32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveF32AsNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveF32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveF32AsNullableJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF32AsNullableJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveF32AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveF32AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionStdPrimitiveF32AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveF32AsNullableJsonbNumberCreateForQuery
    {
        fn from(value: OptionStdPrimitiveF32AsNullableJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveF32AsNullableJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveF32AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionStdPrimitiveF32AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    pub type OptionStdPrimitiveF32AsNullableJsonbNumberWhere =
        postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter<
            <StdPrimitiveF32AsNotNullJsonbNumber as postgres_crud_common::PostgresJsonType>::Where,
        >;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveF32AsNullableJsonbNumberRead(
        OptionStdPrimitiveF32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveF32AsNullableJsonbNumberRead {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveF32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveF32AsNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveF32AsNullableJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF32AsNullableJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveF32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveF32AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionStdPrimitiveF32AsNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionStdPrimitiveF32AsNullableJsonbNumberReadInner = Option<f32>;
    impl From<OptionStdPrimitiveF32AsNullableJsonbNumberOrigin>
        for OptionStdPrimitiveF32AsNullableJsonbNumberReadInner
    {
        fn from(value: OptionStdPrimitiveF32AsNullableJsonbNumberOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveF32AsNullableJsonbNumberUpdate(
        OptionStdPrimitiveF32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveF32AsNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveF32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveF32AsNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveF32AsNullableJsonbNumberUpdateForQuery(
        OptionStdPrimitiveF32AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveF32AsNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF32AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveF32AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionStdPrimitiveF32AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveF32AsNullableJsonbNumberUpdateForQuery
    {
        fn from(value: OptionStdPrimitiveF32AsNullableJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveF32AsNullableJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF32AsNullableJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveF32AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveF32AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for OptionStdPrimitiveF32AsNullableJsonbNumber {
        type TableTypeDeclaration = OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration;
        type Create = OptionStdPrimitiveF32AsNullableJsonbNumberCreate;
        type CreateForQuery = OptionStdPrimitiveF32AsNullableJsonbNumberCreateForQuery;
        type Select = OptionStdPrimitiveF32AsNullableJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else ({column_name_and_maybe_field_getter}->'{field_ident}') end)))"
            ))
        }
        type Where = OptionStdPrimitiveF32AsNullableJsonbNumberWhere;
        type Read = OptionStdPrimitiveF32AsNullableJsonbNumberRead;
        type ReadOnlyIds = OptionStdPrimitiveF32AsNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionStdPrimitiveF32AsNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| value_3432e728.0)
        }
        type Update = OptionStdPrimitiveF32AsNullableJsonbNumberUpdate;
        type UpdateForQuery = OptionStdPrimitiveF32AsNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionStdPrimitiveF32AsNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionStdPrimitiveF32AsNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveF32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_97242d4d = Vec::new();
            for el_8f3646f9 in < StdPrimitiveF32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveF32AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) { for el_35a4dba9 in el_8f3646f9 { acc_97242d4d . push (vec ! [Some (el_35a4dba9)]) ; } }
            acc_97242d4d.push(vec![None]);
            acc_97242d4d
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveF32AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveF32AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionStdPrimitiveF32AsNullableJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionStdPrimitiveF32AsNullableJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionStdPrimitiveF32AsNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter(create.0.0.map(
                |value_18544acf| {
                    postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                        StdPrimitiveF32AsNotNullJsonbNumberWhere::Equal(
                            where_filters::PostgresJsonTypeWhereEqual {
                                logical_operator: postgres_crud_common::LogicalOperator::Or,
                                value: StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    value_18544acf.into(),
                                ),
                            },
                        ),
                    ])
                    .expect("88bfa095-a3ab-4d0c-be71-af63c3acd50f")
                },
            ))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin(
        Vec<StdPrimitiveF32AsNotNullJsonbNumberOrigin>,
    );
    impl VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(
                value
                    .into_iter()
                    .map(StdPrimitiveF32AsNotNullJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
        VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreate(
        VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery(
        VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberRead(
        VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner = Vec<f32>;
    impl From<VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner
    {
        fn from(value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdate(
        VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery(
        VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere;
        type Read = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0)
                .collect()
        }
        type Update = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveF32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveF32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveF32AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new({
                let mut acc_f95ec4f2 = vec![];
                for el_ba78af60 in create.0.0 {
                    let value_027d0d3a = {
                        let value = el_ba78af60.0 - 1.0f32;
                        if (el_ba78af60.0 - value).abs() < 0.1f32 {
                            None
                        } else {
                            value.is_finite().then_some(value)
                        }
                    };
                    match value_027d0d3a {
                        Some(value_0cd93c25) => {
                            acc_f95ec4f2 . push (postgres_crud_common :: SingleOrMultiple :: Single (VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere :: ContainsElGreaterThan (where_filters :: PostgresJsonTypeWhereContainsElGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration (StdPrimitiveF32AsNotNullJsonbNumberOrigin (value_0cd93c25)) }))) ;
                        }
                        None => {
                            return None;
                        }
                    }
                }
                acc_f95ec4f2
            }) {
                Ok(value_69c93ec5) => Some(value_69c93ec5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("47e44ecd-d1c9-4d2b-9d9e-4191cad34be9"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin(
        Vec<OptionStdPrimitiveF32AsNullableJsonbNumberOrigin>,
    );
    impl VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value
                    .into_iter()
                    .map(OptionStdPrimitiveF32AsNullableJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
        VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreate(
        VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreateForQuery(
        VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberRead(
        VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner =
        Vec<Option<f32>>;
    impl From<VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdate(
        VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery(
        VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration;
        type Create = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberCreateForQuery;
        type Select = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberWhere;
        type Read = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                .collect()
        }
        type Update = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < OptionStdPrimitiveF32AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveF32AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveF32AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match create . 0.0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin(
        Option<VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin>,
    );
    impl OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(value.map(VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
        OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreate(
        OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreateForQuery(
        OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberRead(
        OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner =
        Option<Vec<f32>>;
    impl From<OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdate(
        OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery(
        OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberWhere;
        type Read = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0)
                    .collect()
            })
        }
        type Update = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveF32AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveF32AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveF32AsNotNullJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveF32AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin(
        Option<VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin>,
    );
    impl OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value.map(VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberOrigin::new),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
        OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreate(
        OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreateForQuery(
        OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberRead(
        OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner =
        Option<Vec<Option<f32>>>;
    impl From<OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdate(
        OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdateForQuery(
        OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration ;
        type Create = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberCreateForQuery;
        type Select = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberWhere;
        type Read = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds =
            OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner =
            OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                    .collect()
            })
        }
        type Update = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveF32AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveF32AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveF32AsNullableJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct StdPrimitiveF64AsNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveF64AsNotNullJsonbNumberOrigin(f64);
    impl StdPrimitiveF64AsNotNullJsonbNumberOrigin {
        #[must_use]
        pub const fn new(value: StdPrimitiveF64AsNotNullJsonbNumberReadInner) -> Self {
            Self(value)
        }
    }
    impl From<StdPrimitiveF64AsNotNullJsonbNumberCreate> for StdPrimitiveF64AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveF64AsNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<StdPrimitiveF64AsNotNullJsonbNumberUpdate> for StdPrimitiveF64AsNotNullJsonbNumberOrigin {
        fn from(value: StdPrimitiveF64AsNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for StdPrimitiveF64AsNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveF64AsNotNullJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveF64AsNotNullJsonbNumberOrigin {
        fn default_option_some_vec_one_el() -> Self {
            Self(Default::default())
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF64AsNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveF64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveF64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF64AsNotNullJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration(
        StdPrimitiveF64AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub const fn new(value: StdPrimitiveF64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveF64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveF64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveF64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveF64AsNotNullJsonbNumberCreate(StdPrimitiveF64AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveF64AsNotNullJsonbNumberCreate {
        #[must_use]
        pub const fn new(value: StdPrimitiveF64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveF64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveF64AsNotNullJsonbNumberCreate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveF64AsNotNullJsonbNumberCreateForQuery(
        StdPrimitiveF64AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveF64AsNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveF64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveF64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF64AsNotNullJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF64AsNotNullJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveF64AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveF64AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<StdPrimitiveF64AsNotNullJsonbNumberCreate>
        for StdPrimitiveF64AsNotNullJsonbNumberCreateForQuery
    {
        fn from(value: StdPrimitiveF64AsNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveF64AsNotNullJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveF64AsNotNullJsonbNumberSelect {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for StdPrimitiveF64AsNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum StdPrimitiveF64AsNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        In(
            where_filters::PostgresJsonTypeWhereIn<
                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        GreaterThan(
            where_filters::PostgresJsonTypeWhereGreaterThan<
                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        Between(
            where_filters::PostgresJsonTypeWhereBetween<
                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for StdPrimitiveF64AsNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::In(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::Between(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::In(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::GreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::Between(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveF64AsNotNullJsonbNumberWhere {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for StdPrimitiveF64AsNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::In(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::GreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::Between(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveF64AsNotNullJsonbNumberRead(StdPrimitiveF64AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveF64AsNotNullJsonbNumberRead {
        #[must_use]
        pub const fn new(value: StdPrimitiveF64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveF64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveF64AsNotNullJsonbNumberRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF64AsNotNullJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF64AsNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveF64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveF64AsNotNullJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct StdPrimitiveF64AsNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type StdPrimitiveF64AsNotNullJsonbNumberReadInner = f64;
    impl From<StdPrimitiveF64AsNotNullJsonbNumberOrigin>
        for StdPrimitiveF64AsNotNullJsonbNumberReadInner
    {
        fn from(value: StdPrimitiveF64AsNotNullJsonbNumberOrigin) -> Self {
            value.0
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveF64AsNotNullJsonbNumberUpdate(StdPrimitiveF64AsNotNullJsonbNumberOrigin);
    impl StdPrimitiveF64AsNotNullJsonbNumberUpdate {
        #[must_use]
        pub const fn new(value: StdPrimitiveF64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveF64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveF64AsNotNullJsonbNumberUpdate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveF64AsNotNullJsonbNumberUpdateForQuery(
        StdPrimitiveF64AsNotNullJsonbNumberOrigin,
    );
    impl StdPrimitiveF64AsNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveF64AsNotNullJsonbNumberReadInner) -> Self {
            Self(StdPrimitiveF64AsNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<StdPrimitiveF64AsNotNullJsonbNumberUpdate>
        for StdPrimitiveF64AsNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: StdPrimitiveF64AsNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF64AsNotNullJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF64AsNotNullJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveF64AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveF64AsNotNullJsonbNumberOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for StdPrimitiveF64AsNotNullJsonbNumber {
        type TableTypeDeclaration = StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration;
        type Create = StdPrimitiveF64AsNotNullJsonbNumberCreate;
        type CreateForQuery = StdPrimitiveF64AsNotNullJsonbNumberCreateForQuery;
        type Select = StdPrimitiveF64AsNotNullJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',({column_name_and_maybe_field_getter}->'{field_ident}')))"
            ))
        }
        type Where = StdPrimitiveF64AsNotNullJsonbNumberWhere;
        type Read = StdPrimitiveF64AsNotNullJsonbNumberRead;
        type ReadOnlyIds = StdPrimitiveF64AsNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = StdPrimitiveF64AsNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0
        }
        type Update = StdPrimitiveF64AsNotNullJsonbNumberUpdate;
        type UpdateForQuery = StdPrimitiveF64AsNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for StdPrimitiveF64AsNotNullJsonbNumber {
        type PostgresJsonType = Self;
        type Select = StdPrimitiveF64AsNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some(
                postgres_crud_common::std_primitive_f64_test_cases_vec()
                    .into_iter()
                    .map(<Self as postgres_crud_common::PostgresJsonType>::Create::new)
                    .collect(),
            )
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            vec![postgres_crud_common::std_primitive_f64_test_cases_vec().into()]
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: StdPrimitiveF64AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: StdPrimitiveF64AsNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            StdPrimitiveF64AsNotNullJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                StdPrimitiveF64AsNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            StdPrimitiveF64AsNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            StdPrimitiveF64AsNotNullJsonbNumberWhere::Equal(
                where_filters::PostgresJsonTypeWhereEqual {
                    logical_operator: postgres_crud_common::LogicalOperator::Or,
                    value: StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration::new(
                        create.0.into(),
                    ),
                },
            )
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            let value_7aa498e8 = {
                let value = create.0.0 - 1.0f64;
                if (create.0.0 - value).abs() < 0.1f64 {
                    None
                } else {
                    value.is_finite().then_some(value)
                }
            }?;
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveF64AsNotNullJsonbNumberWhere::GreaterThan(
                        where_filters::PostgresJsonTypeWhereGreaterThan {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration(
                                StdPrimitiveF64AsNotNullJsonbNumberOrigin(value_7aa498e8),
                            ),
                        },
                    ),
                ),
            ]) {
                Ok(value_6f3e23b5) => Some(value_6f3e23b5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("11287f54-f840-4076-a16b-1a59a74e6dee"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            if let (Some(start), Some(end)) = (
                {
                    let value = create.0.0 - 1.0;
                    value.is_finite().then_some(value)
                },
                {
                    let value = create.0.0 + 1.0;
                    value.is_finite().then_some(value)
                },
            ) {
                match where_filters :: Between :: try_new (StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration :: new (start) , StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration :: new (end)) { Ok (value_cdde02cc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: SingleOrMultiple :: Single (StdPrimitiveF64AsNotNullJsonbNumberWhere :: Between (where_filters :: PostgresJsonTypeWhereBetween { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : value_cdde02cc , }))]) { Ok (value_41af48fb) => Some (value_41af48fb) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("5edabfcc-fcbe-419c-a2be-5bd7e961e6e0") } } , Err (error) => None }
            } else {
                None
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdPrimitiveF64AsNotNullJsonbNumberWhere::In(
                        where_filters::PostgresJsonTypeWhereIn {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            value: where_filters::PostgresJsonTypeNotEmptyUniqueVec::try_new(vec![
                                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    create.0.0,
                                ),
                            ])
                            .expect("2737c0ed-cf4a-4aba-b749-dc7c4e37ff2e"),
                        },
                    ),
                ),
            ]) {
                Ok(value_1c4f89a4) => Some(value_1c4f89a4),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("16ae359d-3869-421b-b37d-85b0b24835bd"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionStdPrimitiveF64AsNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveF64AsNullableJsonbNumberOrigin(
        Option<StdPrimitiveF64AsNotNullJsonbNumberOrigin>,
    );
    impl OptionStdPrimitiveF64AsNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF64AsNullableJsonbNumberReadInner) -> Self {
            Self(value.map(StdPrimitiveF64AsNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionStdPrimitiveF64AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveF64AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveF64AsNullableJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<OptionStdPrimitiveF64AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveF64AsNullableJsonbNumberOrigin
    {
        fn from(value: OptionStdPrimitiveF64AsNullableJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionStdPrimitiveF64AsNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveF64AsNullableJsonbNumberOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveF64AsNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF64AsNullableJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveF64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveF64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveF64AsNullableJsonbNumberOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration(
        OptionStdPrimitiveF64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveF64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveF64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveF64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveF64AsNullableJsonbNumberCreate(
        OptionStdPrimitiveF64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveF64AsNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveF64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveF64AsNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveF64AsNullableJsonbNumberCreateForQuery(
        OptionStdPrimitiveF64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveF64AsNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveF64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveF64AsNullableJsonbNumberCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF64AsNullableJsonbNumberCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveF64AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveF64AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionStdPrimitiveF64AsNullableJsonbNumberCreate>
        for OptionStdPrimitiveF64AsNullableJsonbNumberCreateForQuery
    {
        fn from(value: OptionStdPrimitiveF64AsNullableJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveF64AsNullableJsonbNumberSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveF64AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionStdPrimitiveF64AsNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    pub type OptionStdPrimitiveF64AsNullableJsonbNumberWhere =
        postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter<
            <StdPrimitiveF64AsNotNullJsonbNumber as postgres_crud_common::PostgresJsonType>::Where,
        >;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveF64AsNullableJsonbNumberRead(
        OptionStdPrimitiveF64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveF64AsNullableJsonbNumberRead {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveF64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveF64AsNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveF64AsNullableJsonbNumberRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF64AsNullableJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdPrimitiveF64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdPrimitiveF64AsNullableJsonbNumberReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionStdPrimitiveF64AsNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionStdPrimitiveF64AsNullableJsonbNumberReadInner = Option<f64>;
    impl From<OptionStdPrimitiveF64AsNullableJsonbNumberOrigin>
        for OptionStdPrimitiveF64AsNullableJsonbNumberReadInner
    {
        fn from(value: OptionStdPrimitiveF64AsNullableJsonbNumberOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveF64AsNullableJsonbNumberUpdate(
        OptionStdPrimitiveF64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveF64AsNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveF64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveF64AsNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveF64AsNullableJsonbNumberUpdateForQuery(
        OptionStdPrimitiveF64AsNullableJsonbNumberOrigin,
    );
    impl OptionStdPrimitiveF64AsNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveF64AsNullableJsonbNumberReadInner) -> Self {
            Self(OptionStdPrimitiveF64AsNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionStdPrimitiveF64AsNullableJsonbNumberUpdate>
        for OptionStdPrimitiveF64AsNullableJsonbNumberUpdateForQuery
    {
        fn from(value: OptionStdPrimitiveF64AsNullableJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveF64AsNullableJsonbNumberUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF64AsNullableJsonbNumberUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveF64AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveF64AsNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for OptionStdPrimitiveF64AsNullableJsonbNumber {
        type TableTypeDeclaration = OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration;
        type Create = OptionStdPrimitiveF64AsNullableJsonbNumberCreate;
        type CreateForQuery = OptionStdPrimitiveF64AsNullableJsonbNumberCreateForQuery;
        type Select = OptionStdPrimitiveF64AsNullableJsonbNumberSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else ({column_name_and_maybe_field_getter}->'{field_ident}') end)))"
            ))
        }
        type Where = OptionStdPrimitiveF64AsNullableJsonbNumberWhere;
        type Read = OptionStdPrimitiveF64AsNullableJsonbNumberRead;
        type ReadOnlyIds = OptionStdPrimitiveF64AsNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionStdPrimitiveF64AsNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| value_3432e728.0)
        }
        type Update = OptionStdPrimitiveF64AsNullableJsonbNumberUpdate;
        type UpdateForQuery = OptionStdPrimitiveF64AsNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionStdPrimitiveF64AsNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionStdPrimitiveF64AsNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveF64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_97242d4d = Vec::new();
            for el_8f3646f9 in < StdPrimitiveF64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveF64AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) { for el_35a4dba9 in el_8f3646f9 { acc_97242d4d . push (vec ! [Some (el_35a4dba9)]) ; } }
            acc_97242d4d.push(vec![None]);
            acc_97242d4d
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveF64AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveF64AsNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionStdPrimitiveF64AsNullableJsonbNumberReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionStdPrimitiveF64AsNullableJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionStdPrimitiveF64AsNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter(create.0.0.map(
                |value_18544acf| {
                    postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                        StdPrimitiveF64AsNotNullJsonbNumberWhere::Equal(
                            where_filters::PostgresJsonTypeWhereEqual {
                                logical_operator: postgres_crud_common::LogicalOperator::Or,
                                value: StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration::new(
                                    value_18544acf.into(),
                                ),
                            },
                        ),
                    ])
                    .expect("88bfa095-a3ab-4d0c-be71-af63c3acd50f")
                },
            ))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin(
        Vec<StdPrimitiveF64AsNotNullJsonbNumberOrigin>,
    );
    impl VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(
                value
                    .into_iter()
                    .map(StdPrimitiveF64AsNotNullJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn from(value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
        VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreate(
        VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery(
        VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreate>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberRead(
        VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner = Vec<f64>;
    impl From<VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner
    {
        fn from(value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdate(
        VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery(
        VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin,
    );
    impl VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner) -> Self {
            Self(VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdate>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere;
        type Read = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0)
                .collect()
        }
        type Update = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveF64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveF64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveF64AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new({
                let mut acc_f95ec4f2 = vec![];
                for el_ba78af60 in create.0.0 {
                    let value_027d0d3a = {
                        let value = el_ba78af60.0 - 1.0f64;
                        if (el_ba78af60.0 - value).abs() < 0.1f64 {
                            None
                        } else {
                            value.is_finite().then_some(value)
                        }
                    };
                    match value_027d0d3a {
                        Some(value_0cd93c25) => {
                            acc_f95ec4f2 . push (postgres_crud_common :: SingleOrMultiple :: Single (VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere :: ContainsElGreaterThan (where_filters :: PostgresJsonTypeWhereContainsElGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration (StdPrimitiveF64AsNotNullJsonbNumberOrigin (value_0cd93c25)) }))) ;
                        }
                        None => {
                            return None;
                        }
                    }
                }
                acc_f95ec4f2
            }) {
                Ok(value_69c93ec5) => Some(value_69c93ec5),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("47e44ecd-d1c9-4d2b-9d9e-4191cad34be9"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin(
        Vec<OptionStdPrimitiveF64AsNullableJsonbNumberOrigin>,
    );
    impl VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value
                    .into_iter()
                    .map(OptionStdPrimitiveF64AsNullableJsonbNumberOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
        VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreate(
        VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreateForQuery(
        VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreate>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneGreaterThan<
                OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        DimensionOneBetween(
            where_filters::PostgresJsonTypeWhereDimensionOneBetween<
                OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        ContainsElGreaterThan(
            where_filters::PostgresJsonTypeWhereContainsElGreaterThan<
                OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
        AllElementsGreaterThan(
            where_filters::PostgresJsonTypeWhereAllElementsGreaterThan<
                OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneBetween(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneBetween(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberRead(
        VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner =
        Vec<Option<f64>>;
    impl From<VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdate(
        VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery(
        VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin,
    );
    impl VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin::new(value))
        }
    }
    impl From<VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdate>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration =
            VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration;
        type Create = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberCreateForQuery;
        type Select = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberWhere;
        type Read = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                .collect()
        }
        type Update = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < OptionStdPrimitiveF64AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveF64AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveF64AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match create . 0.0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin(
        Option<VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin>,
    );
    impl OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(value.map(VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberOrigin::new))
        }
    }
    impl From<OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
        OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreate(
        OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreateForQuery(
        OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreate>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberRead(
        OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner =
        Option<Vec<f64>>;
    impl From<OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdate(
        OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery(
        OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin,
    );
    impl OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin::new(value))
        }
    }
    impl From<OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdate>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumber
    {
        type TableTypeDeclaration =
            OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration;
        type Create = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberCreateForQuery;
        type Select = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberWhere;
        type Read = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberRead;
        type ReadOnlyIds = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0)
                    .collect()
            })
        }
        type Update = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveF64AsNotNullJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveF64AsNotNullJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveF64AsNotNullJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveF64AsNotNullArrayOfNotNullJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumber;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin(
        Option<VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin>,
    );
    impl OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                value.map(VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberOrigin::new),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
        OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreate(
        OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreateForQuery(
        OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreate>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberRead(
        OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner =
        Option<Vec<Option<f64>>>;
    impl From<OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdate(
        OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdateForQuery(
        OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin::new(
                    value,
                ),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdate>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumber
    {
        type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration ;
        type Create = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreate;
        type CreateForQuery =
            OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberCreateForQuery;
        type Select = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberWhere;
        type Read = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberRead;
        type ReadOnlyIds =
            OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner =
            OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                    .collect()
            })
        }
        type Update = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdate;
        type UpdateForQuery =
            OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumber
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveF64AsNullableJsonbNumber as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveF64AsNullableJsonbNumberReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableJsonbNumberTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveF64AsNullableJsonbNumberTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableJsonbNumberWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct StdPrimitiveBoolAsNotNullJsonbBoolean;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveBoolAsNotNullJsonbBooleanOrigin(bool);
    impl StdPrimitiveBoolAsNotNullJsonbBooleanOrigin {
        #[must_use]
        pub const fn new(value: StdPrimitiveBoolAsNotNullJsonbBooleanReadInner) -> Self {
            Self(value)
        }
    }
    impl From<StdPrimitiveBoolAsNotNullJsonbBooleanCreate>
        for StdPrimitiveBoolAsNotNullJsonbBooleanOrigin
    {
        fn from(value: StdPrimitiveBoolAsNotNullJsonbBooleanCreate) -> Self {
            value.0
        }
    }
    impl From<StdPrimitiveBoolAsNotNullJsonbBooleanUpdate>
        for StdPrimitiveBoolAsNotNullJsonbBooleanOrigin
    {
        fn from(value: StdPrimitiveBoolAsNotNullJsonbBooleanUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for StdPrimitiveBoolAsNotNullJsonbBooleanOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveBoolAsNotNullJsonbBooleanOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveBoolAsNotNullJsonbBooleanOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Default::default())
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveBoolAsNotNullJsonbBooleanOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveBoolAsNotNullJsonbBooleanReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveBoolAsNotNullJsonbBooleanReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveBoolAsNotNullJsonbBooleanOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration(
        StdPrimitiveBoolAsNotNullJsonbBooleanOrigin,
    );
    impl StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration {
        #[must_use]
        pub const fn new(value: StdPrimitiveBoolAsNotNullJsonbBooleanReadInner) -> Self {
            Self(StdPrimitiveBoolAsNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveBoolAsNotNullJsonbBooleanReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveBoolAsNotNullJsonbBooleanReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveBoolAsNotNullJsonbBooleanCreate(
        StdPrimitiveBoolAsNotNullJsonbBooleanOrigin,
    );
    impl StdPrimitiveBoolAsNotNullJsonbBooleanCreate {
        #[must_use]
        pub const fn new(value: StdPrimitiveBoolAsNotNullJsonbBooleanReadInner) -> Self {
            Self(StdPrimitiveBoolAsNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveBoolAsNotNullJsonbBooleanCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveBoolAsNotNullJsonbBooleanCreateForQuery(
        StdPrimitiveBoolAsNotNullJsonbBooleanOrigin,
    );
    impl StdPrimitiveBoolAsNotNullJsonbBooleanCreateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveBoolAsNotNullJsonbBooleanReadInner) -> Self {
            Self(StdPrimitiveBoolAsNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveBoolAsNotNullJsonbBooleanCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveBoolAsNotNullJsonbBooleanCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveBoolAsNotNullJsonbBooleanOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveBoolAsNotNullJsonbBooleanOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<StdPrimitiveBoolAsNotNullJsonbBooleanCreate>
        for StdPrimitiveBoolAsNotNullJsonbBooleanCreateForQuery
    {
        fn from(value: StdPrimitiveBoolAsNotNullJsonbBooleanCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveBoolAsNotNullJsonbBooleanSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveBoolAsNotNullJsonbBooleanSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for StdPrimitiveBoolAsNotNullJsonbBooleanSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum StdPrimitiveBoolAsNotNullJsonbBooleanWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration,
            >,
        ),
        In(
            where_filters::PostgresJsonTypeWhereIn<
                StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for StdPrimitiveBoolAsNotNullJsonbBooleanWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::In(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::In(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString for StdPrimitiveBoolAsNotNullJsonbBooleanWhere {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for StdPrimitiveBoolAsNotNullJsonbBooleanWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::In(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveBoolAsNotNullJsonbBooleanRead(
        StdPrimitiveBoolAsNotNullJsonbBooleanOrigin,
    );
    impl StdPrimitiveBoolAsNotNullJsonbBooleanRead {
        #[must_use]
        pub const fn new(value: StdPrimitiveBoolAsNotNullJsonbBooleanReadInner) -> Self {
            Self(StdPrimitiveBoolAsNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdPrimitiveBoolAsNotNullJsonbBooleanRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveBoolAsNotNullJsonbBooleanRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveBoolAsNotNullJsonbBooleanRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdPrimitiveBoolAsNotNullJsonbBooleanReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdPrimitiveBoolAsNotNullJsonbBooleanReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct StdPrimitiveBoolAsNotNullJsonbBooleanReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type StdPrimitiveBoolAsNotNullJsonbBooleanReadInner = bool;
    impl From<StdPrimitiveBoolAsNotNullJsonbBooleanOrigin>
        for StdPrimitiveBoolAsNotNullJsonbBooleanReadInner
    {
        fn from(value: StdPrimitiveBoolAsNotNullJsonbBooleanOrigin) -> Self {
            value.0
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdPrimitiveBoolAsNotNullJsonbBooleanUpdate(
        StdPrimitiveBoolAsNotNullJsonbBooleanOrigin,
    );
    impl StdPrimitiveBoolAsNotNullJsonbBooleanUpdate {
        #[must_use]
        pub const fn new(value: StdPrimitiveBoolAsNotNullJsonbBooleanReadInner) -> Self {
            Self(StdPrimitiveBoolAsNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdPrimitiveBoolAsNotNullJsonbBooleanUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct StdPrimitiveBoolAsNotNullJsonbBooleanUpdateForQuery(
        StdPrimitiveBoolAsNotNullJsonbBooleanOrigin,
    );
    impl StdPrimitiveBoolAsNotNullJsonbBooleanUpdateForQuery {
        #[must_use]
        pub const fn new(value: StdPrimitiveBoolAsNotNullJsonbBooleanReadInner) -> Self {
            Self(StdPrimitiveBoolAsNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl From<StdPrimitiveBoolAsNotNullJsonbBooleanUpdate>
        for StdPrimitiveBoolAsNotNullJsonbBooleanUpdateForQuery
    {
        fn from(value: StdPrimitiveBoolAsNotNullJsonbBooleanUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveBoolAsNotNullJsonbBooleanUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdPrimitiveBoolAsNotNullJsonbBooleanUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdPrimitiveBoolAsNotNullJsonbBooleanOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdPrimitiveBoolAsNotNullJsonbBooleanOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for StdPrimitiveBoolAsNotNullJsonbBoolean {
        type TableTypeDeclaration = StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration;
        type Create = StdPrimitiveBoolAsNotNullJsonbBooleanCreate;
        type CreateForQuery = StdPrimitiveBoolAsNotNullJsonbBooleanCreateForQuery;
        type Select = StdPrimitiveBoolAsNotNullJsonbBooleanSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',({column_name_and_maybe_field_getter}->'{field_ident}')))"
            ))
        }
        type Where = StdPrimitiveBoolAsNotNullJsonbBooleanWhere;
        type Read = StdPrimitiveBoolAsNotNullJsonbBooleanRead;
        type ReadOnlyIds = StdPrimitiveBoolAsNotNullJsonbBooleanReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = StdPrimitiveBoolAsNotNullJsonbBooleanReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0
        }
        type Update = StdPrimitiveBoolAsNotNullJsonbBooleanUpdate;
        type UpdateForQuery = StdPrimitiveBoolAsNotNullJsonbBooleanUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for StdPrimitiveBoolAsNotNullJsonbBoolean {
        type PostgresJsonType = Self;
        type Select = StdPrimitiveBoolAsNotNullJsonbBooleanSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some(
                postgres_crud_common::std_primitive_bool_test_cases_vec()
                    .into_iter()
                    .map(<Self as postgres_crud_common::PostgresJsonType>::Create::new)
                    .collect(),
            )
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            vec![postgres_crud_common::std_primitive_bool_test_cases_vec().into()]
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: StdPrimitiveBoolAsNotNullJsonbBooleanReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: StdPrimitiveBoolAsNotNullJsonbBooleanReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            StdPrimitiveBoolAsNotNullJsonbBooleanReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                StdPrimitiveBoolAsNotNullJsonbBooleanRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            StdPrimitiveBoolAsNotNullJsonbBooleanRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            StdPrimitiveBoolAsNotNullJsonbBooleanWhere::Equal(
                where_filters::PostgresJsonTypeWhereEqual {
                    logical_operator: postgres_crud_common::LogicalOperator::Or,
                    value: StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration::new(
                        create.0.into(),
                    ),
                },
            )
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionStdPrimitiveBoolAsNullableJsonbBoolean;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin(
        Option<StdPrimitiveBoolAsNotNullJsonbBooleanOrigin>,
    );
    impl OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner) -> Self {
            Self(value.map(StdPrimitiveBoolAsNotNullJsonbBooleanOrigin::new))
        }
    }
    impl From<OptionStdPrimitiveBoolAsNullableJsonbBooleanCreate>
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin
    {
        fn from(value: OptionStdPrimitiveBoolAsNullableJsonbBooleanCreate) -> Self {
            value.0
        }
    }
    impl From<OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdate>
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin
    {
        fn from(value: OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration(
        OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin,
    );
    impl OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner) -> Self {
            Self(OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin::new(
                value,
            ))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveBoolAsNullableJsonbBooleanCreate(
        OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin,
    );
    impl OptionStdPrimitiveBoolAsNullableJsonbBooleanCreate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner) -> Self {
            Self(OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin::new(
                value,
            ))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveBoolAsNullableJsonbBooleanCreateForQuery(
        OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin,
    );
    impl OptionStdPrimitiveBoolAsNullableJsonbBooleanCreateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner) -> Self {
            Self(OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin::new(
                value,
            ))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveBoolAsNullableJsonbBooleanCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionStdPrimitiveBoolAsNullableJsonbBooleanCreate>
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanCreateForQuery
    {
        fn from(value: OptionStdPrimitiveBoolAsNullableJsonbBooleanCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveBoolAsNullableJsonbBooleanSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    pub type OptionStdPrimitiveBoolAsNullableJsonbBooleanWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < StdPrimitiveBoolAsNotNullJsonbBoolean as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveBoolAsNullableJsonbBooleanRead(
        OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin,
    );
    impl OptionStdPrimitiveBoolAsNullableJsonbBooleanRead {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner) -> Self {
            Self(OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin::new(
                value,
            ))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveBoolAsNullableJsonbBooleanRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveBoolAsNullableJsonbBooleanRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionStdPrimitiveBoolAsNullableJsonbBooleanReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner = Option<bool>;
    impl From<OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin>
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner
    {
        fn from(value: OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdate(
        OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin,
    );
    impl OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdate {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner) -> Self {
            Self(OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin::new(
                value,
            ))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdateForQuery(
        OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin,
    );
    impl OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner) -> Self {
            Self(OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin::new(
                value,
            ))
        }
    }
    impl From<OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdate>
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdateForQuery
    {
        fn from(value: OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for OptionStdPrimitiveBoolAsNullableJsonbBoolean {
        type TableTypeDeclaration =
            OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration;
        type Create = OptionStdPrimitiveBoolAsNullableJsonbBooleanCreate;
        type CreateForQuery = OptionStdPrimitiveBoolAsNullableJsonbBooleanCreateForQuery;
        type Select = OptionStdPrimitiveBoolAsNullableJsonbBooleanSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else ({column_name_and_maybe_field_getter}->'{field_ident}') end)))"
            ))
        }
        type Where = OptionStdPrimitiveBoolAsNullableJsonbBooleanWhere;
        type Read = OptionStdPrimitiveBoolAsNullableJsonbBooleanRead;
        type ReadOnlyIds = OptionStdPrimitiveBoolAsNullableJsonbBooleanReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| value_3432e728.0)
        }
        type Update = OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdate;
        type UpdateForQuery = OptionStdPrimitiveBoolAsNullableJsonbBooleanUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionStdPrimitiveBoolAsNullableJsonbBoolean
    {
        type PostgresJsonType = Self;
        type Select = OptionStdPrimitiveBoolAsNullableJsonbBooleanSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveBoolAsNotNullJsonbBoolean as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_97242d4d = Vec::new();
            for el_8f3646f9 in < StdPrimitiveBoolAsNotNullJsonbBoolean as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveBoolAsNotNullJsonbBooleanReadOnlyIds (read_only_ids . 0 . clone ())) { for el_35a4dba9 in el_8f3646f9 { acc_97242d4d . push (vec ! [Some (el_35a4dba9)]) ; } }
            acc_97242d4d.push(vec![None]);
            acc_97242d4d
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionStdPrimitiveBoolAsNullableJsonbBooleanReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionStdPrimitiveBoolAsNullableJsonbBooleanReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionStdPrimitiveBoolAsNullableJsonbBooleanRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionStdPrimitiveBoolAsNullableJsonbBooleanRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter(create.0.0.map(
                |value_18544acf| {
                    postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                        StdPrimitiveBoolAsNotNullJsonbBooleanWhere::Equal(
                            where_filters::PostgresJsonTypeWhereEqual {
                                logical_operator: postgres_crud_common::LogicalOperator::Or,
                                value:
                                    StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration::new(
                                        value_18544acf.into(),
                                    ),
                            },
                        ),
                    ])
                    .expect("88bfa095-a3ab-4d0c-be71-af63c3acd50f")
                },
            ))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBoolean;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin(
        Vec<StdPrimitiveBoolAsNotNullJsonbBooleanOrigin>,
    );
    impl VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin {
        #[must_use]
        pub fn new(
            value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(
                value
                    .into_iter()
                    .map(StdPrimitiveBoolAsNotNullJsonbBooleanOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreate>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin
    {
        fn from(value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdate>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin
    {
        fn from(value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanTableTypeDeclaration(
        VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin,
    );
    impl VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreate(
        VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin,
    );
    impl VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreate {
        #[must_use]
        pub fn new(
            value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreateForQuery(
        VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin,
    );
    impl VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreate>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreateForQuery
    {
        fn from(value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanRead(
        VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin,
    );
    impl VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanRead {
        #[must_use]
        pub fn new(
            value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner = Vec<bool>;
    impl From<VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner
    {
        fn from(value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdate(
        VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin,
    );
    impl VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdate {
        #[must_use]
        pub fn new(
            value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdateForQuery(
        VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin,
    );
    impl VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl From<VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdate>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdateForQuery
    {
        fn from(value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBoolean
    {
        type TableTypeDeclaration =
            VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanTableTypeDeclaration;
        type Create = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreate;
        type CreateForQuery =
            VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanCreateForQuery;
        type Select = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanWhere;
        type Read = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanRead;
        type ReadOnlyIds = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0)
                .collect()
        }
        type Update = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdate;
        type UpdateForQuery =
            VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBoolean
    {
        type PostgresJsonType = Self;
        type Select = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdPrimitiveBoolAsNotNullJsonbBoolean as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveBoolAsNotNullJsonbBoolean as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveBoolAsNotNullJsonbBooleanReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBoolean;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin(
        Vec<OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin>,
    );
    impl VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(
                value
                    .into_iter()
                    .map(OptionStdPrimitiveBoolAsNullableJsonbBooleanOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreate>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdate>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin
    {
        fn from(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanTableTypeDeclaration(
        VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin,
    );
    impl VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreate(
        VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin,
    );
    impl VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreateForQuery(
        VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin,
    );
    impl VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreate>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration,
            >,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanRead(
        VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin,
    );
    impl VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanRead {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner =
        Vec<Option<bool>>;
    impl From<VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner
    {
        fn from(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin,
        ) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdate(
        VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin,
    );
    impl VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdateForQuery(
        VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin,
    );
    impl VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin::new(value))
        }
    }
    impl From<VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdate>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdateForQuery
    {
        fn from(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBoolean
    {
        type TableTypeDeclaration =
            VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanTableTypeDeclaration;
        type Create = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreate;
        type CreateForQuery =
            VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanCreateForQuery;
        type Select = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanWhere;
        type Read = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanRead;
        type ReadOnlyIds =
            VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                .collect()
        }
        type Update = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdate;
        type UpdateForQuery =
            VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBoolean
    {
        type PostgresJsonType = Self;
        type Select = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < OptionStdPrimitiveBoolAsNullableJsonbBoolean as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveBoolAsNullableJsonbBoolean as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveBoolAsNullableJsonbBooleanReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match create . 0.0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBoolean;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin(
        Option<VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin>,
    );
    impl OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(value.map(VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanOrigin::new))
        }
    }
    impl From<OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreate>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdate>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin
    {
        fn from(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanTableTypeDeclaration(
        OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin,
    );
    impl OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreate(
        OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin,
    );
    impl OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreateForQuery(
        OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin,
    );
    impl OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreate>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBoolean as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanRead(
        OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin,
    );
    impl OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner =
        Option<Vec<bool>>;
    impl From<OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner
    {
        fn from(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdate(
        OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin,
    );
    impl OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdateForQuery(
        OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin,
    );
    impl OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
        ) -> Self {
            Self(OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin::new(value))
        }
    }
    impl From<OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdate>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdateForQuery
    {
        fn from(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBoolean
    {
        type TableTypeDeclaration =
            OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanTableTypeDeclaration;
        type Create = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreate;
        type CreateForQuery =
            OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanCreateForQuery;
        type Select = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanWhere;
        type Read = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanRead;
        type ReadOnlyIds =
            OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0)
                    .collect()
            })
        }
        type Update = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdate;
        type UpdateForQuery =
            OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBoolean
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBoolean as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdPrimitiveBoolAsNotNullJsonbBoolean as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdPrimitiveBoolAsNotNullJsonbBooleanReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullJsonbBooleanTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdPrimitiveBoolAsNotNullJsonbBooleanTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullJsonbBooleanWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBoolean;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin(
        Option<VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin>,
    );
    impl OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(
                value.map(
                    VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanOrigin::new,
                ),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreate>
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdate>
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanTableTypeDeclaration(
        OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common :: DefaultOptionSomeVecOneEl for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanTableTypeDeclaration { fn default_option_some_vec_one_el () -> Self { Self (postgres_crud_common :: DefaultOptionSomeVecOneEl :: default_option_some_vec_one_el ()) } }
    impl sqlx :: Encode < '_ , sqlx :: Postgres > for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanTableTypeDeclaration { fn encode_by_ref (& self , buf : & mut sqlx :: postgres :: PgArgumentBuffer) -> Result < sqlx :: encode :: IsNull , Box < dyn std :: error :: Error + Send + Sync >> { sqlx :: Encode :: < sqlx :: Postgres > :: encode_by_ref (& & self . 0 , buf) } }
    impl sqlx :: Type < sqlx :: Postgres > for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanTableTypeDeclaration { fn compatible (ty : & < sqlx :: Postgres as sqlx :: Database > :: TypeInfo) -> bool { < sqlx :: types :: Json < OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty) } fn type_info () -> < sqlx :: Postgres as sqlx :: Database > :: TypeInfo { < sqlx :: types :: Json < OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info () } }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreate(
        OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreateForQuery(
        OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin::new(
                    value,
                ),
            )
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreate>
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBoolean as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanRead(
        OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner =
        Option<Vec<Option<bool>>>;
    impl From<OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin>
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdate(
        OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdateForQuery(
        OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin,
    );
    impl OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin::new(
                    value,
                ),
            )
        }
    }
    impl From<OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdate>
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBoolean
    {
        type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanTableTypeDeclaration ;
        type Create = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreate;
        type CreateForQuery =
            OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanCreateForQuery;
        type Select = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanWhere;
        type Read = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanRead;
        type ReadOnlyIds =
            OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner =
            OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                    .collect()
            })
        }
        type Update = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdate;
        type UpdateForQuery =
            OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBoolean
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBoolean as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdPrimitiveBoolAsNullableJsonbBoolean as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdPrimitiveBoolAsNullableJsonbBooleanReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanRead(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableJsonbBooleanTableTypeDeclaration (create . into ())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdPrimitiveBoolAsNullableJsonbBooleanTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableJsonbBooleanWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct StdStringStringAsNotNullJsonbString;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdStringStringAsNotNullJsonbStringOrigin(String);
    impl StdStringStringAsNotNullJsonbStringOrigin {
        #[must_use]
        pub const fn new(value: StdStringStringAsNotNullJsonbStringReadInner) -> Self {
            Self(value)
        }
    }
    impl From<StdStringStringAsNotNullJsonbStringCreate> for StdStringStringAsNotNullJsonbStringOrigin {
        fn from(value: StdStringStringAsNotNullJsonbStringCreate) -> Self {
            value.0
        }
    }
    impl From<StdStringStringAsNotNullJsonbStringUpdate> for StdStringStringAsNotNullJsonbStringOrigin {
        fn from(value: StdStringStringAsNotNullJsonbStringUpdate) -> Self {
            value.0
        }
    }
    impl postgres_crud_common::IsStringEmpty for StdStringStringAsNotNullJsonbStringOrigin {
        fn is_string_empty(&self) -> bool {
            self.0.clone().is_empty()
        }
    }
    impl std::fmt::Display for StdStringStringAsNotNullJsonbStringOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for StdStringStringAsNotNullJsonbStringOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdStringStringAsNotNullJsonbStringOrigin {
        fn default_option_some_vec_one_el() -> Self {
            Self(String::default())
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdStringStringAsNotNullJsonbStringOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdStringStringAsNotNullJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdStringStringAsNotNullJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdStringStringAsNotNullJsonbStringOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdStringStringAsNotNullJsonbStringTableTypeDeclaration(
        StdStringStringAsNotNullJsonbStringOrigin,
    );
    impl StdStringStringAsNotNullJsonbStringTableTypeDeclaration {
        #[must_use]
        pub const fn new(value: StdStringStringAsNotNullJsonbStringReadInner) -> Self {
            Self(StdStringStringAsNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for StdStringStringAsNotNullJsonbStringTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdStringStringAsNotNullJsonbStringTableTypeDeclaration {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdStringStringAsNotNullJsonbStringTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdStringStringAsNotNullJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdStringStringAsNotNullJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdStringStringAsNotNullJsonbStringCreate(StdStringStringAsNotNullJsonbStringOrigin);
    impl StdStringStringAsNotNullJsonbStringCreate {
        #[must_use]
        pub const fn new(value: StdStringStringAsNotNullJsonbStringReadInner) -> Self {
            Self(StdStringStringAsNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdStringStringAsNotNullJsonbStringCreate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct StdStringStringAsNotNullJsonbStringCreateForQuery(
        StdStringStringAsNotNullJsonbStringOrigin,
    );
    impl StdStringStringAsNotNullJsonbStringCreateForQuery {
        #[must_use]
        pub const fn new(value: StdStringStringAsNotNullJsonbStringReadInner) -> Self {
            Self(StdStringStringAsNotNullJsonbStringOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdStringStringAsNotNullJsonbStringCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdStringStringAsNotNullJsonbStringCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdStringStringAsNotNullJsonbStringOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdStringStringAsNotNullJsonbStringOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<StdStringStringAsNotNullJsonbStringCreate>
        for StdStringStringAsNotNullJsonbStringCreateForQuery
    {
        fn from(value: StdStringStringAsNotNullJsonbStringCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdStringStringAsNotNullJsonbStringSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdStringStringAsNotNullJsonbStringSelect {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for StdStringStringAsNotNullJsonbStringSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum StdStringStringAsNotNullJsonbStringWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                StdStringStringAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        In(
            where_filters::PostgresJsonTypeWhereIn<
                StdStringStringAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        RegularExpression(where_filters::PostgresJsonTypeWhereRegularExpression),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for StdStringStringAsNotNullJsonbStringWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::In(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::RegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::In(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::RegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString for StdStringStringAsNotNullJsonbStringWhere {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for StdStringStringAsNotNullJsonbStringWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::In(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::RegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdStringStringAsNotNullJsonbStringRead(StdStringStringAsNotNullJsonbStringOrigin);
    impl StdStringStringAsNotNullJsonbStringRead {
        #[must_use]
        pub const fn new(value: StdStringStringAsNotNullJsonbStringReadInner) -> Self {
            Self(StdStringStringAsNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdStringStringAsNotNullJsonbStringRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdStringStringAsNotNullJsonbStringRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdStringStringAsNotNullJsonbStringRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<StdStringStringAsNotNullJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<StdStringStringAsNotNullJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct StdStringStringAsNotNullJsonbStringReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type StdStringStringAsNotNullJsonbStringReadInner = String;
    impl From<StdStringStringAsNotNullJsonbStringOrigin>
        for StdStringStringAsNotNullJsonbStringReadInner
    {
        fn from(value: StdStringStringAsNotNullJsonbStringOrigin) -> Self {
            value.0
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct StdStringStringAsNotNullJsonbStringUpdate(StdStringStringAsNotNullJsonbStringOrigin);
    impl StdStringStringAsNotNullJsonbStringUpdate {
        #[must_use]
        pub const fn new(value: StdStringStringAsNotNullJsonbStringReadInner) -> Self {
            Self(StdStringStringAsNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for StdStringStringAsNotNullJsonbStringUpdate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct StdStringStringAsNotNullJsonbStringUpdateForQuery(
        StdStringStringAsNotNullJsonbStringOrigin,
    );
    impl StdStringStringAsNotNullJsonbStringUpdateForQuery {
        #[must_use]
        pub const fn new(value: StdStringStringAsNotNullJsonbStringReadInner) -> Self {
            Self(StdStringStringAsNotNullJsonbStringOrigin::new(value))
        }
    }
    impl From<StdStringStringAsNotNullJsonbStringUpdate>
        for StdStringStringAsNotNullJsonbStringUpdateForQuery
    {
        fn from(value: StdStringStringAsNotNullJsonbStringUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for StdStringStringAsNotNullJsonbStringUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for StdStringStringAsNotNullJsonbStringUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <StdStringStringAsNotNullJsonbStringOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <StdStringStringAsNotNullJsonbStringOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for StdStringStringAsNotNullJsonbString {
        type TableTypeDeclaration = StdStringStringAsNotNullJsonbStringTableTypeDeclaration;
        type Create = StdStringStringAsNotNullJsonbStringCreate;
        type CreateForQuery = StdStringStringAsNotNullJsonbStringCreateForQuery;
        type Select = StdStringStringAsNotNullJsonbStringSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',({column_name_and_maybe_field_getter}->'{field_ident}')))"
            ))
        }
        type Where = StdStringStringAsNotNullJsonbStringWhere;
        type Read = StdStringStringAsNotNullJsonbStringRead;
        type ReadOnlyIds = StdStringStringAsNotNullJsonbStringReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = StdStringStringAsNotNullJsonbStringReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0
        }
        type Update = StdStringStringAsNotNullJsonbStringUpdate;
        type UpdateForQuery = StdStringStringAsNotNullJsonbStringUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for StdStringStringAsNotNullJsonbString {
        type PostgresJsonType = Self;
        type Select = StdStringStringAsNotNullJsonbStringSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some(
                postgres_crud_common::std_string_string_test_cases_vec()
                    .into_iter()
                    .map(<Self as postgres_crud_common::PostgresJsonType>::Create::new)
                    .collect(),
            )
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            vec![postgres_crud_common::std_string_string_test_cases_vec().into()]
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: StdStringStringAsNotNullJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: StdStringStringAsNotNullJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            StdStringStringAsNotNullJsonbStringReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                StdStringStringAsNotNullJsonbStringRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            StdStringStringAsNotNullJsonbStringRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            StdStringStringAsNotNullJsonbStringTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            StdStringStringAsNotNullJsonbStringWhere::Equal(
                where_filters::PostgresJsonTypeWhereEqual {
                    logical_operator: postgres_crud_common::LogicalOperator::Or,
                    value: StdStringStringAsNotNullJsonbStringTableTypeDeclaration::new(
                        create.0.into(),
                    ),
                },
            )
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                postgres_crud_common::SingleOrMultiple::Single(
                    StdStringStringAsNotNullJsonbStringWhere::RegularExpression(
                        where_filters::PostgresJsonTypeWhereRegularExpression {
                            logical_operator: postgres_crud_common::LogicalOperator::Or,
                            regular_expression_case:
                                where_filters::RegularExpressionCase::Sensitive,
                            value: where_filters::RegexRegex(
                                regex::Regex::new(&format!("^{}$", regex::escape(&create.0.0)))
                                    .expect("3814ff38-0e4d-4173-bf0e-971372b888f6"),
                            ),
                        },
                    ),
                ),
            ]) {
                Ok(value_75ae8964) => Some(value_75ae8964),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("b9713787-7160-4a8b-b82c-72617d446184"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionStdStringStringAsNullableJsonbString;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdStringStringAsNullableJsonbStringOrigin(
        Option<StdStringStringAsNotNullJsonbStringOrigin>,
    );
    impl OptionStdStringStringAsNullableJsonbStringOrigin {
        #[must_use]
        pub fn new(value: OptionStdStringStringAsNullableJsonbStringReadInner) -> Self {
            Self(value.map(StdStringStringAsNotNullJsonbStringOrigin::new))
        }
    }
    impl From<OptionStdStringStringAsNullableJsonbStringCreate>
        for OptionStdStringStringAsNullableJsonbStringOrigin
    {
        fn from(value: OptionStdStringStringAsNullableJsonbStringCreate) -> Self {
            value.0
        }
    }
    impl From<OptionStdStringStringAsNullableJsonbStringUpdate>
        for OptionStdStringStringAsNullableJsonbStringOrigin
    {
        fn from(value: OptionStdStringStringAsNullableJsonbStringUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionStdStringStringAsNullableJsonbStringOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for OptionStdStringStringAsNullableJsonbStringOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdStringStringAsNullableJsonbStringOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdStringStringAsNullableJsonbStringOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdStringStringAsNullableJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdStringStringAsNullableJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdStringStringAsNullableJsonbStringOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration(
        OptionStdStringStringAsNullableJsonbStringOrigin,
    );
    impl OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionStdStringStringAsNullableJsonbStringReadInner) -> Self {
            Self(OptionStdStringStringAsNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdStringStringAsNullableJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdStringStringAsNullableJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdStringStringAsNullableJsonbStringCreate(
        OptionStdStringStringAsNullableJsonbStringOrigin,
    );
    impl OptionStdStringStringAsNullableJsonbStringCreate {
        #[must_use]
        pub fn new(value: OptionStdStringStringAsNullableJsonbStringReadInner) -> Self {
            Self(OptionStdStringStringAsNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdStringStringAsNullableJsonbStringCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionStdStringStringAsNullableJsonbStringCreateForQuery(
        OptionStdStringStringAsNullableJsonbStringOrigin,
    );
    impl OptionStdStringStringAsNullableJsonbStringCreateForQuery {
        #[must_use]
        pub fn new(value: OptionStdStringStringAsNullableJsonbStringReadInner) -> Self {
            Self(OptionStdStringStringAsNullableJsonbStringOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdStringStringAsNullableJsonbStringCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdStringStringAsNullableJsonbStringCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdStringStringAsNullableJsonbStringOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdStringStringAsNullableJsonbStringOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionStdStringStringAsNullableJsonbStringCreate>
        for OptionStdStringStringAsNullableJsonbStringCreateForQuery
    {
        fn from(value: OptionStdStringStringAsNullableJsonbStringCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdStringStringAsNullableJsonbStringSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdStringStringAsNullableJsonbStringSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionStdStringStringAsNullableJsonbStringSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    pub type OptionStdStringStringAsNullableJsonbStringWhere =
        postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter<
            <StdStringStringAsNotNullJsonbString as postgres_crud_common::PostgresJsonType>::Where,
        >;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdStringStringAsNullableJsonbStringRead(
        OptionStdStringStringAsNullableJsonbStringOrigin,
    );
    impl OptionStdStringStringAsNullableJsonbStringRead {
        #[must_use]
        pub fn new(value: OptionStdStringStringAsNullableJsonbStringReadInner) -> Self {
            Self(OptionStdStringStringAsNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdStringStringAsNullableJsonbStringRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdStringStringAsNullableJsonbStringRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdStringStringAsNullableJsonbStringRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionStdStringStringAsNullableJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionStdStringStringAsNullableJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionStdStringStringAsNullableJsonbStringReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionStdStringStringAsNullableJsonbStringReadInner = Option<String>;
    impl From<OptionStdStringStringAsNullableJsonbStringOrigin>
        for OptionStdStringStringAsNullableJsonbStringReadInner
    {
        fn from(value: OptionStdStringStringAsNullableJsonbStringOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionStdStringStringAsNullableJsonbStringUpdate(
        OptionStdStringStringAsNullableJsonbStringOrigin,
    );
    impl OptionStdStringStringAsNullableJsonbStringUpdate {
        #[must_use]
        pub fn new(value: OptionStdStringStringAsNullableJsonbStringReadInner) -> Self {
            Self(OptionStdStringStringAsNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionStdStringStringAsNullableJsonbStringUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionStdStringStringAsNullableJsonbStringUpdateForQuery(
        OptionStdStringStringAsNullableJsonbStringOrigin,
    );
    impl OptionStdStringStringAsNullableJsonbStringUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionStdStringStringAsNullableJsonbStringReadInner) -> Self {
            Self(OptionStdStringStringAsNullableJsonbStringOrigin::new(value))
        }
    }
    impl From<OptionStdStringStringAsNullableJsonbStringUpdate>
        for OptionStdStringStringAsNullableJsonbStringUpdateForQuery
    {
        fn from(value: OptionStdStringStringAsNullableJsonbStringUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdStringStringAsNullableJsonbStringUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionStdStringStringAsNullableJsonbStringUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionStdStringStringAsNullableJsonbStringOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionStdStringStringAsNullableJsonbStringOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for OptionStdStringStringAsNullableJsonbString {
        type TableTypeDeclaration = OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration;
        type Create = OptionStdStringStringAsNullableJsonbStringCreate;
        type CreateForQuery = OptionStdStringStringAsNullableJsonbStringCreateForQuery;
        type Select = OptionStdStringStringAsNullableJsonbStringSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else ({column_name_and_maybe_field_getter}->'{field_ident}') end)))"
            ))
        }
        type Where = OptionStdStringStringAsNullableJsonbStringWhere;
        type Read = OptionStdStringStringAsNullableJsonbStringRead;
        type ReadOnlyIds = OptionStdStringStringAsNullableJsonbStringReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionStdStringStringAsNullableJsonbStringReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| value_3432e728.0)
        }
        type Update = OptionStdStringStringAsNullableJsonbStringUpdate;
        type UpdateForQuery = OptionStdStringStringAsNullableJsonbStringUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionStdStringStringAsNullableJsonbString
    {
        type PostgresJsonType = Self;
        type Select = OptionStdStringStringAsNullableJsonbStringSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdStringStringAsNotNullJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_97242d4d = Vec::new();
            for el_8f3646f9 in < StdStringStringAsNotNullJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdStringStringAsNotNullJsonbStringReadOnlyIds (read_only_ids . 0 . clone ())) { for el_35a4dba9 in el_8f3646f9 { acc_97242d4d . push (vec ! [Some (el_35a4dba9)]) ; } }
            acc_97242d4d.push(vec![None]);
            acc_97242d4d
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionStdStringStringAsNullableJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionStdStringStringAsNullableJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionStdStringStringAsNullableJsonbStringReadOnlyIds(postgres_crud_common::Value {
                value: None,
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionStdStringStringAsNullableJsonbStringRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionStdStringStringAsNullableJsonbStringRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter(create.0.0.map(
                |value_18544acf| {
                    postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                        StdStringStringAsNotNullJsonbStringWhere::Equal(
                            where_filters::PostgresJsonTypeWhereEqual {
                                logical_operator: postgres_crud_common::LogicalOperator::Or,
                                value: StdStringStringAsNotNullJsonbStringTableTypeDeclaration::new(
                                    value_18544acf.into(),
                                ),
                            },
                        ),
                    ])
                    .expect("88bfa095-a3ab-4d0c-be71-af63c3acd50f")
                },
            ))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfStdStringStringAsNotNullArrayOfNotNullJsonbString;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin(
        Vec<StdStringStringAsNotNullJsonbStringOrigin>,
    );
    impl VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin {
        #[must_use]
        pub fn new(value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(
                value
                    .into_iter()
                    .map(StdStringStringAsNotNullJsonbStringOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreate>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin
    {
        fn from(value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdate>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin
    {
        fn from(value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration(
        VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin,
    );
    impl VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration {
        #[must_use]
        pub fn new(value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreate(
        VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin,
    );
    impl VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreate {
        #[must_use]
        pub fn new(value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreateForQuery(
        VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin,
    );
    impl VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreate>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreateForQuery
    {
        fn from(value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                StdStringStringAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                StdStringStringAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                StdStringStringAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                StdStringStringAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                StdStringStringAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneRegularExpression(
            where_filters::PostgresJsonTypeWhereDimensionOneRegularExpression,
        ),
        ContainsElRegularExpression(
            where_filters::PostgresJsonTypeWhereContainsElRegularExpression,
        ),
        AllElementsRegularExpression(
            where_filters::PostgresJsonTypeWhereAllElementsRegularExpression,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneRegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElRegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsRegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringRead(
        VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin,
    );
    impl VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringRead {
        #[must_use]
        pub fn new(value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner = Vec<String>;
    impl From<VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner
    {
        fn from(value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdate(
        VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin,
    );
    impl VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdate {
        #[must_use]
        pub fn new(value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdateForQuery(
        VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin,
    );
    impl VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdateForQuery {
        #[must_use]
        pub fn new(value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl From<VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdate>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdateForQuery
    {
        fn from(value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbString
    {
        type TableTypeDeclaration =
            VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration;
        type Create = VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreate;
        type CreateForQuery = VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringCreateForQuery;
        type Select = VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere;
        type Read = VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringRead;
        type ReadOnlyIds = VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0)
                .collect()
        }
        type Update = VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdate;
        type UpdateForQuery = VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfStdStringStringAsNotNullArrayOfNotNullJsonbString
    {
        type PostgresJsonType = Self;
        type Select = VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < StdStringStringAsNotNullJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdStringStringAsNotNullJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdStringStringAsNotNullJsonbStringReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdStringStringAsNotNullJsonbStringTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (create . 0.0 . into_iter () . map (| el_590fca71 | { postgres_crud_common :: SingleOrMultiple :: Single (VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere :: ContainsElRegularExpression (where_filters :: PostgresJsonTypeWhereContainsElRegularExpression { logical_operator : postgres_crud_common :: LogicalOperator :: Or , regular_expression_case : where_filters :: RegularExpressionCase :: Sensitive , value : where_filters :: RegexRegex (regex :: Regex :: new (& format ! ("^{}$" , regex :: escape (& el_590fca71 . 0))) . expect ("7d01653a-e82f-4615-bbef-a8c899491f34") ,) , } ,) ,) }) . collect ()) { Ok (value_0363f494) => Some (value_0363f494) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("415a73d9-3665-4dde-9120-662a51626586") } }
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbString;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin(
        Vec<OptionStdStringStringAsNullableJsonbStringOrigin>,
    );
    impl VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(
                value
                    .into_iter()
                    .map(OptionStdStringStringAsNullableJsonbStringOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreate>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin
    {
        fn from(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdate>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin
    {
        fn from(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration(
        VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin,
    );
    impl VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreate(
        VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin,
    );
    impl VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreateForQuery(
        VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin,
    );
    impl VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreate>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreateForQuery
    {
        fn from(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneRegularExpression(
            where_filters::PostgresJsonTypeWhereDimensionOneRegularExpression,
        ),
        ContainsElRegularExpression(
            where_filters::PostgresJsonTypeWhereContainsElRegularExpression,
        ),
        AllElementsRegularExpression(
            where_filters::PostgresJsonTypeWhereAllElementsRegularExpression,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneRegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElRegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsRegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringRead(
        VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin,
    );
    impl VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringRead {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner =
        Vec<Option<String>>;
    impl From<VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner
    {
        fn from(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin,
        ) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdate(
        VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin,
    );
    impl VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdate {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdateForQuery(
        VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin,
    );
    impl VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdateForQuery {
        #[must_use]
        pub fn new(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl From<VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdate>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdateForQuery
    {
        fn from(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbString
    {
        type TableTypeDeclaration =
            VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration;
        type Create = VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreate;
        type CreateForQuery =
            VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringCreateForQuery;
        type Select = VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringWhere;
        type Read = VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringRead;
        type ReadOnlyIds = VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                .collect()
        }
        type Update = VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdate;
        type UpdateForQuery =
            VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbString
    {
        type PostgresJsonType = Self;
        type Select = VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < OptionStdStringStringAsNullableJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 . clone () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (vec ! [el_88131059 . 0 . into ()])) ; } let mut acc_27624e5e = Vec :: new () ; for el_0dcb405a in value_8de026a4 { acc_27624e5e . push (el_0dcb405a . 0 . into ()) ; } if ! acc_27624e5e . is_empty () { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (acc_27624e5e)) ; } }
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdStringStringAsNullableJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdStringStringAsNullableJsonbStringReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![vec![el_82c7dc0a.clone()]],
                                vec![vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()]],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![{
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            }]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match create . 0.0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbString;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin(
        Option<VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin>,
    );
    impl OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
        ) -> Self {
            Self(value.map(VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringOrigin::new))
        }
    }
    impl From<OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreate>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin
    {
        fn from(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdate>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin
    {
        fn from(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration(
        OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin,
    );
    impl OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
        ) -> Self {
            Self(OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreate(
        OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin,
    );
    impl OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
        ) -> Self {
            Self(OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreateForQuery(
        OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin,
    );
    impl OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
        ) -> Self {
            Self(OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreate>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreateForQuery
    {
        fn from(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfStdStringStringAsNotNullArrayOfNotNullJsonbString as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringRead(
        OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin,
    );
    impl OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
        ) -> Self {
            Self(OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner =
        Option<Vec<String>>;
    impl From<OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner
    {
        fn from(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdate(
        OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin,
    );
    impl OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
        ) -> Self {
            Self(OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdateForQuery(
        OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin,
    );
    impl OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
        ) -> Self {
            Self(OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl From<OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdate>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdateForQuery
    {
        fn from(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbString
    {
        type TableTypeDeclaration =
            OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration;
        type Create = OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreate;
        type CreateForQuery =
            OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringCreateForQuery;
        type Select = OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringWhere;
        type Read = OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringRead;
        type ReadOnlyIds = OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner = OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0)
                    .collect()
            })
        }
        type Update = OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdate;
        type UpdateForQuery =
            OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbString
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfStdStringStringAsNotNullArrayOfNotNullJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < StdStringStringAsNotNullJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& StdStringStringAsNotNullJsonbStringReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one = {
                let mut has_len_greater_than_one = false;
                for el_4a00ab02 in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if el_4a00ab02.len() > 1 {
                        has_len_greater_than_one = true;
                        break;
                    }
                }
                has_len_greater_than_one
            };
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfStdStringStringAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : StdStringStringAsNotNullJsonbStringTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfStdStringStringAsNotNullArrayOfNotNullJsonbStringWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbString;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin(
        Option<VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin>,
    );
    impl OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(
                value.map(VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringOrigin::new),
            )
        }
    }
    impl From<OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreate>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin
    {
        fn from(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdate>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin
    {
        fn from(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin
    {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringTableTypeDeclaration(
        OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin,
    );
    impl OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreate(
        OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin,
    );
    impl OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreateForQuery(
        OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin,
    );
    impl OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin::new(
                    value,
                ),
            )
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreate>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbString as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringRead(
        OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin,
    );
    impl OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadOnlyIds(
        pub postgres_crud_common::Value<Option<()>>,
    );
    pub type OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner =
        Option<Vec<Option<String>>>;
    impl From<OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner
    {
        fn from(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdate(
        OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin,
    );
    impl OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin::new(
                    value,
                ),
            )
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdateForQuery(
        OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin,
    );
    impl OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(
                OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin::new(
                    value,
                ),
            )
        }
    }
    impl From<OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdate>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdateForQuery
    {
        fn from(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbString
    {
        type TableTypeDeclaration = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringTableTypeDeclaration ;
        type Create = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreate;
        type CreateForQuery =
            OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringCreateForQuery;
        type Select = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringWhere;
        type Read = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringRead;
        type ReadOnlyIds =
            OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok("jsonb_build_object('value','null'::jsonb)".to_owned())
        }
        type ReadInner =
            OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                    .collect()
            })
        }
        type Update = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdate;
        type UpdateForQuery =
            OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(gen_postgres_json_types_common::field_ident_jsonb_build_object_value(field_ident))
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbString
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            Some({
                let mut acc_50e99088 = Vec::new();
                if let Some (value_8de026a4) = < VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: option_vec_create () { for el_88131059 in value_8de026a4 { acc_50e99088 . push (< Self as postgres_crud_common :: PostgresJsonType > :: Create :: new (Some (el_88131059 . 0 . into ()))) ; } }
                acc_50e99088
                    .push(<Self as postgres_crud_common::PostgresJsonType>::Create::new(None));
                acc_50e99088
            })
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            let mut acc_0a07db18 = Vec::new();
            let read_only_ids_to_two_dimensional_vec_read_inner = < OptionStdStringStringAsNullableJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_to_two_dimensional_vec_read_inner (& OptionStdStringStringAsNullableJsonbStringReadOnlyIds (read_only_ids . 0 . clone ())) ;
            let option_additional = {
                let mut option_additional = None;
                for el_c4f9bf8f in &read_only_ids_to_two_dimensional_vec_read_inner {
                    if option_additional.is_some() {
                        break;
                    }
                    for el_82c7dc0a in el_c4f9bf8f {
                        if option_additional.is_none() {
                            option_additional = Some((
                                vec![Some(vec![el_82c7dc0a.clone()])],
                                vec![Some(vec![el_82c7dc0a.clone(), el_82c7dc0a.clone()])],
                            ));
                        } else {
                            break;
                        }
                    }
                }
                option_additional
            };
            let has_len_greater_than_one =
                read_only_ids_to_two_dimensional_vec_read_inner.len() > 1;
            acc_0a07db18.push(vec![Some({
                let mut acc_6cd5b60a = Vec::new();
                for el_640f58e8 in read_only_ids_to_two_dimensional_vec_read_inner {
                    for el_d251d1f6 in el_640f58e8 {
                        acc_6cd5b60a.push(el_d251d1f6);
                    }
                }
                acc_6cd5b60a
            })]);
            acc_0a07db18.push(vec![None]);
            if let Some(value_3de7fba4) = option_additional {
                if has_len_greater_than_one {
                    acc_0a07db18.push(value_3de7fba4.0);
                } else {
                    acc_0a07db18.push(value_3de7fba4.1);
                }
            }
            acc_0a07db18
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringReadOnlyIds(
                postgres_crud_common::Value { value: None },
            )
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfOptionStdStringStringAsNullableArrayOfNullableJsonbStringTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionStdStringStringAsNullableJsonbStringTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionStdStringStringAsNotNullArrayOfNullableJsonbStringWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct UuidUuidAsNotNullJsonbString;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
    )]
    pub struct UuidUuidAsNotNullJsonbStringOrigin(uuid::Uuid);
    impl UuidUuidAsNotNullJsonbStringOrigin {
        #[must_use]
        pub const fn new(value: UuidUuidAsNotNullJsonbStringReadInner) -> Self {
            Self(value)
        }
    }
    impl From<UuidUuidAsNotNullJsonbStringCreate> for UuidUuidAsNotNullJsonbStringOrigin {
        fn from(value: UuidUuidAsNotNullJsonbStringCreate) -> Self {
            value.0
        }
    }
    impl From<UuidUuidAsNotNullJsonbStringUpdate> for UuidUuidAsNotNullJsonbStringOrigin {
        fn from(value: UuidUuidAsNotNullJsonbStringUpdate) -> Self {
            value.0
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    const _: () = {
        #[automatically_derived]
        #[allow(unused_braces)]
        impl schemars::JsonSchema for UuidUuidAsNotNullJsonbStringOrigin {
            fn schema_name() -> schemars::_private::alloc::borrow::Cow<'static, str> {
                schemars::_private::alloc::borrow::Cow::Borrowed(
                    "UuidUuidAsNotNullJsonbStringOrigin",
                )
            }
            fn schema_id() -> schemars::_private::alloc::borrow::Cow<'static, str> {
                schemars::_private::alloc::borrow::Cow::Borrowed(
                    "tests::UuidUuidAsNotNullJsonbStringOrigin",
                )
            }
            fn json_schema(generator: &mut schemars::SchemaGenerator) -> schemars::Schema {
                { generator.subschema_for::<String>() }
            }
            fn inline_schema() -> bool {
                false
            }
        }
    };
    impl postgres_crud_common::IsStringEmpty for UuidUuidAsNotNullJsonbStringOrigin {
        fn is_string_empty(&self) -> bool {
            self.0.to_string().is_empty()
        }
    }
    impl std::fmt::Display for UuidUuidAsNotNullJsonbStringOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for UuidUuidAsNotNullJsonbStringOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for UuidUuidAsNotNullJsonbStringOrigin {
        fn default_option_some_vec_one_el() -> Self {
            Self(uuid::Uuid::new_v4())
        }
    }
    impl sqlx::Type<sqlx::Postgres> for UuidUuidAsNotNullJsonbStringOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<UuidUuidAsNotNullJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<UuidUuidAsNotNullJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for UuidUuidAsNotNullJsonbStringOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct UuidUuidAsNotNullJsonbStringTableTypeDeclaration(UuidUuidAsNotNullJsonbStringOrigin);
    impl UuidUuidAsNotNullJsonbStringTableTypeDeclaration {
        #[must_use]
        pub const fn new(value: UuidUuidAsNotNullJsonbStringReadInner) -> Self {
            Self(UuidUuidAsNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for UuidUuidAsNotNullJsonbStringTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for UuidUuidAsNotNullJsonbStringTableTypeDeclaration {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for UuidUuidAsNotNullJsonbStringTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<UuidUuidAsNotNullJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<UuidUuidAsNotNullJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct UuidUuidAsNotNullJsonbStringCreate(UuidUuidAsNotNullJsonbStringOrigin);
    impl UuidUuidAsNotNullJsonbStringCreate {
        #[must_use]
        pub const fn new(value: UuidUuidAsNotNullJsonbStringReadInner) -> Self {
            Self(UuidUuidAsNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for UuidUuidAsNotNullJsonbStringCreate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct UuidUuidAsNotNullJsonbStringCreateForQuery(UuidUuidAsNotNullJsonbStringOrigin);
    impl UuidUuidAsNotNullJsonbStringCreateForQuery {
        #[must_use]
        pub const fn new(value: UuidUuidAsNotNullJsonbStringReadInner) -> Self {
            Self(UuidUuidAsNotNullJsonbStringOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for UuidUuidAsNotNullJsonbStringCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for UuidUuidAsNotNullJsonbStringCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <UuidUuidAsNotNullJsonbStringOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <UuidUuidAsNotNullJsonbStringOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<UuidUuidAsNotNullJsonbStringCreate> for UuidUuidAsNotNullJsonbStringCreateForQuery {
        fn from(value: UuidUuidAsNotNullJsonbStringCreate) -> Self {
            Self(value.0)
        }
    }
    impl From<UuidUuidAsNotNullJsonbStringUpdate> for UuidUuidAsNotNullJsonbStringCreateForQuery {
        fn from(value: UuidUuidAsNotNullJsonbStringUpdate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct UuidUuidAsNotNullJsonbStringSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for UuidUuidAsNotNullJsonbStringSelect {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for UuidUuidAsNotNullJsonbStringSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum UuidUuidAsNotNullJsonbStringWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                UuidUuidAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        In(
            where_filters::PostgresJsonTypeWhereIn<
                UuidUuidAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        RegularExpression(where_filters::PostgresJsonTypeWhereRegularExpression),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for UuidUuidAsNotNullJsonbStringWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::In(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::RegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::In(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::RegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString for UuidUuidAsNotNullJsonbStringWhere {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for UuidUuidAsNotNullJsonbStringWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::In(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::RegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct UuidUuidAsNotNullJsonbStringRead(UuidUuidAsNotNullJsonbStringOrigin);
    impl UuidUuidAsNotNullJsonbStringRead {
        #[must_use]
        pub const fn new(value: UuidUuidAsNotNullJsonbStringReadInner) -> Self {
            Self(UuidUuidAsNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for UuidUuidAsNotNullJsonbStringRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for UuidUuidAsNotNullJsonbStringRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for UuidUuidAsNotNullJsonbStringRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<UuidUuidAsNotNullJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<UuidUuidAsNotNullJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct UuidUuidAsNotNullJsonbStringReadOnlyIds(pub postgres_crud_common::Value<uuid::Uuid>);
    pub type UuidUuidAsNotNullJsonbStringReadInner = uuid::Uuid;
    impl From<UuidUuidAsNotNullJsonbStringOrigin> for UuidUuidAsNotNullJsonbStringReadInner {
        fn from(value: UuidUuidAsNotNullJsonbStringOrigin) -> Self {
            value.0
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct UuidUuidAsNotNullJsonbStringUpdate(UuidUuidAsNotNullJsonbStringOrigin);
    impl UuidUuidAsNotNullJsonbStringUpdate {
        #[must_use]
        pub const fn new(value: UuidUuidAsNotNullJsonbStringReadInner) -> Self {
            Self(UuidUuidAsNotNullJsonbStringOrigin::new(value))
        }
    }
    impl error_occurence_lib::ToStdStringString for UuidUuidAsNotNullJsonbStringUpdate {
        fn to_std_string_string(&self) -> String {
            format!("{self:?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for UuidUuidAsNotNullJsonbStringUpdate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct UuidUuidAsNotNullJsonbStringUpdateForQuery(UuidUuidAsNotNullJsonbStringOrigin);
    impl UuidUuidAsNotNullJsonbStringUpdateForQuery {
        #[must_use]
        pub const fn new(value: UuidUuidAsNotNullJsonbStringReadInner) -> Self {
            Self(UuidUuidAsNotNullJsonbStringOrigin::new(value))
        }
    }
    impl From<UuidUuidAsNotNullJsonbStringUpdate> for UuidUuidAsNotNullJsonbStringUpdateForQuery {
        fn from(value: UuidUuidAsNotNullJsonbStringUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for UuidUuidAsNotNullJsonbStringUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for UuidUuidAsNotNullJsonbStringUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <UuidUuidAsNotNullJsonbStringOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <UuidUuidAsNotNullJsonbStringOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for UuidUuidAsNotNullJsonbString {
        type TableTypeDeclaration = UuidUuidAsNotNullJsonbStringTableTypeDeclaration;
        type Create = UuidUuidAsNotNullJsonbStringCreate;
        type CreateForQuery = UuidUuidAsNotNullJsonbStringCreateForQuery;
        type Select = UuidUuidAsNotNullJsonbStringSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',({column_name_and_maybe_field_getter}->'{field_ident}')))"
            ))
        }
        type Where = UuidUuidAsNotNullJsonbStringWhere;
        type Read = UuidUuidAsNotNullJsonbStringRead;
        type ReadOnlyIds = UuidUuidAsNotNullJsonbStringReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('value',{column_name_and_maybe_field_getter})"
            ))
        }
        type ReadInner = UuidUuidAsNotNullJsonbStringReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0
        }
        type Update = UuidUuidAsNotNullJsonbStringUpdate;
        type UpdateForQuery = UuidUuidAsNotNullJsonbStringUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_f06128be) => Ok(format!(
                    "'{field_ident}',jsonb_build_object('value',${value_f06128be}),"
                )),
                Err(error) => Err(error),
            }
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            mut query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_f06128be) => Ok(format!(
                    "'{field_ident}',jsonb_build_object('value',${value_f06128be}),"
                )),
                Err(error) => Err(error),
            }
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            mut query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonTypeObjectVecElementId for UuidUuidAsNotNullJsonbString {
        type PostgresJsonType = Self;
        type CreateForQuery = UuidUuidAsNotNullJsonbStringCreateForQuery;
        type Update = UuidUuidAsNotNullJsonbStringUpdate;
        type ReadInner = UuidUuidAsNotNullJsonbStringReadInner;
        fn query_bind_string_as_postgres_text_create_for_query(
            value : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: CreateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value.0.0.to_string()) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn query_bind_string_as_postgres_text_update_for_query(
            value : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value.0.0.to_string()) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn get_inner(
            value : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: CreateForQuery,
        ) -> &Self::ReadInner {
            &value.0.0
        }
        fn increment_checked_add_one(
            increment: &mut u64,
        ) -> Result<u64, postgres_crud_common::QueryPartErrorNamed> {
            postgres_crud_common::increment_checked_add_one_returning_increment(increment)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for UuidUuidAsNotNullJsonbString {
        type PostgresJsonType = Self;
        type Select = UuidUuidAsNotNullJsonbStringSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            None
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            Vec::new()
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: UuidUuidAsNotNullJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: UuidUuidAsNotNullJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some(postgres_crud_common::Value {
                value: value.0.value,
            })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            UuidUuidAsNotNullJsonbStringReadOnlyIds(postgres_crud_common::Value {
                value: value.0.clone().into(),
            })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value: UuidUuidAsNotNullJsonbStringRead::new(value.0.value.clone()),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                UuidUuidAsNotNullJsonbStringRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            UuidUuidAsNotNullJsonbStringRead(UuidUuidAsNotNullJsonbStringOrigin::new(
                read_only_ids.0.value,
            ))
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            UuidUuidAsNotNullJsonbStringTableTypeDeclaration(
                UuidUuidAsNotNullJsonbStringOrigin::new(read_only_ids.0.value),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            UuidUuidAsNotNullJsonbStringWhere::Equal(where_filters::PostgresJsonTypeWhereEqual {
                logical_operator: postgres_crud_common::LogicalOperator::Or,
                value: UuidUuidAsNotNullJsonbStringTableTypeDeclaration::new(create.0.into()),
            })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionUuidUuidAsNullableJsonbString;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionUuidUuidAsNullableJsonbStringOrigin(
        Option<UuidUuidAsNotNullJsonbStringOrigin>,
    );
    impl OptionUuidUuidAsNullableJsonbStringOrigin {
        #[must_use]
        pub fn new(value: OptionUuidUuidAsNullableJsonbStringReadInner) -> Self {
            Self(value.map(UuidUuidAsNotNullJsonbStringOrigin::new))
        }
    }
    impl From<OptionUuidUuidAsNullableJsonbStringCreate> for OptionUuidUuidAsNullableJsonbStringOrigin {
        fn from(value: OptionUuidUuidAsNullableJsonbStringCreate) -> Self {
            value.0
        }
    }
    impl From<OptionUuidUuidAsNullableJsonbStringUpdate> for OptionUuidUuidAsNullableJsonbStringOrigin {
        fn from(value: OptionUuidUuidAsNullableJsonbStringUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionUuidUuidAsNullableJsonbStringOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString for OptionUuidUuidAsNullableJsonbStringOrigin {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for OptionUuidUuidAsNullableJsonbStringOrigin {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionUuidUuidAsNullableJsonbStringOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionUuidUuidAsNullableJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionUuidUuidAsNullableJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionUuidUuidAsNullableJsonbStringOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration(
        OptionUuidUuidAsNullableJsonbStringOrigin,
    );
    impl OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionUuidUuidAsNullableJsonbStringReadInner) -> Self {
            Self(OptionUuidUuidAsNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionUuidUuidAsNullableJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionUuidUuidAsNullableJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionUuidUuidAsNullableJsonbStringCreate(OptionUuidUuidAsNullableJsonbStringOrigin);
    impl OptionUuidUuidAsNullableJsonbStringCreate {
        #[must_use]
        pub fn new(value: OptionUuidUuidAsNullableJsonbStringReadInner) -> Self {
            Self(OptionUuidUuidAsNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for OptionUuidUuidAsNullableJsonbStringCreate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionUuidUuidAsNullableJsonbStringCreateForQuery(
        OptionUuidUuidAsNullableJsonbStringOrigin,
    );
    impl OptionUuidUuidAsNullableJsonbStringCreateForQuery {
        #[must_use]
        pub fn new(value: OptionUuidUuidAsNullableJsonbStringReadInner) -> Self {
            Self(OptionUuidUuidAsNullableJsonbStringOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionUuidUuidAsNullableJsonbStringCreateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionUuidUuidAsNullableJsonbStringCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionUuidUuidAsNullableJsonbStringOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionUuidUuidAsNullableJsonbStringOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl From<OptionUuidUuidAsNullableJsonbStringCreate>
        for OptionUuidUuidAsNullableJsonbStringCreateForQuery
    {
        fn from(value: OptionUuidUuidAsNullableJsonbStringCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionUuidUuidAsNullableJsonbStringSelect;
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for OptionUuidUuidAsNullableJsonbStringSelect {
        fn default_option_some_vec_one_el() -> Self {
            Self {}
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionUuidUuidAsNullableJsonbStringSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self {}
        }
    }
    pub type OptionUuidUuidAsNullableJsonbStringWhere =
        postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter<
            <UuidUuidAsNotNullJsonbString as postgres_crud_common::PostgresJsonType>::Where,
        >;
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionUuidUuidAsNullableJsonbStringRead(OptionUuidUuidAsNullableJsonbStringOrigin);
    impl OptionUuidUuidAsNullableJsonbStringRead {
        #[must_use]
        pub fn new(value: OptionUuidUuidAsNullableJsonbStringReadInner) -> Self {
            Self(OptionUuidUuidAsNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for OptionUuidUuidAsNullableJsonbStringRead {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionUuidUuidAsNullableJsonbStringRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionUuidUuidAsNullableJsonbStringRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<OptionUuidUuidAsNullableJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<OptionUuidUuidAsNullableJsonbStringReadInner> as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionUuidUuidAsNullableJsonbStringReadOnlyIds(
        pub postgres_crud_common::Value<Option<uuid::Uuid>>,
    );
    pub type OptionUuidUuidAsNullableJsonbStringReadInner = Option<uuid::Uuid>;
    impl From<OptionUuidUuidAsNullableJsonbStringOrigin>
        for OptionUuidUuidAsNullableJsonbStringReadInner
    {
        fn from(value: OptionUuidUuidAsNullableJsonbStringOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionUuidUuidAsNullableJsonbStringUpdate(OptionUuidUuidAsNullableJsonbStringOrigin);
    impl OptionUuidUuidAsNullableJsonbStringUpdate {
        #[must_use]
        pub fn new(value: OptionUuidUuidAsNullableJsonbStringReadInner) -> Self {
            Self(OptionUuidUuidAsNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl for OptionUuidUuidAsNullableJsonbStringUpdate {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, serde :: Serialize)]
    pub struct OptionUuidUuidAsNullableJsonbStringUpdateForQuery(
        OptionUuidUuidAsNullableJsonbStringOrigin,
    );
    impl OptionUuidUuidAsNullableJsonbStringUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionUuidUuidAsNullableJsonbStringReadInner) -> Self {
            Self(OptionUuidUuidAsNullableJsonbStringOrigin::new(value))
        }
    }
    impl From<OptionUuidUuidAsNullableJsonbStringUpdate>
        for OptionUuidUuidAsNullableJsonbStringUpdateForQuery
    {
        fn from(value: OptionUuidUuidAsNullableJsonbStringUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for OptionUuidUuidAsNullableJsonbStringUpdateForQuery {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionUuidUuidAsNullableJsonbStringUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionUuidUuidAsNullableJsonbStringOrigin as sqlx::Type<sqlx::Postgres>>::compatible(
                ty,
            )
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionUuidUuidAsNullableJsonbStringOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for OptionUuidUuidAsNullableJsonbString {
        type TableTypeDeclaration = OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration;
        type Create = OptionUuidUuidAsNullableJsonbStringCreate;
        type CreateForQuery = OptionUuidUuidAsNullableJsonbStringCreateForQuery;
        type Select = OptionUuidUuidAsNullableJsonbStringSelect;
        fn select_query_part(
            _: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else ({column_name_and_maybe_field_getter}->'{field_ident}') end)))"
            ))
        }
        type Where = OptionUuidUuidAsNullableJsonbStringWhere;
        type Read = OptionUuidUuidAsNullableJsonbStringRead;
        type ReadOnlyIds = OptionUuidUuidAsNullableJsonbStringReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('value',{column_name_and_maybe_field_getter})"
            ))
        }
        type ReadInner = OptionUuidUuidAsNullableJsonbStringReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| value_3432e728.0)
        }
        type Update = OptionUuidUuidAsNullableJsonbStringUpdate;
        type UpdateForQuery = OptionUuidUuidAsNullableJsonbStringUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_f06128be) => Ok(format!(
                    "'{field_ident}',jsonb_build_object('value',${value_f06128be}),"
                )),
                Err(error) => Err(error),
            }
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            mut query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_f06128be) => Ok(format!(
                    "'{field_ident}',jsonb_build_object('value',${value_f06128be}),"
                )),
                Err(error) => Err(error),
            }
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            mut query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases for OptionUuidUuidAsNullableJsonbString {
        type PostgresJsonType = Self;
        type Select = OptionUuidUuidAsNullableJsonbStringSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            None
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            Vec::new()
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionUuidUuidAsNullableJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionUuidUuidAsNullableJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionUuidUuidAsNullableJsonbStringReadOnlyIds (postgres_crud_common :: Value { value : value . 0.0 . as_ref () . map (| value_92de91cc | < UuidUuidAsNotNullJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: update_to_read_only_ids (& UuidUuidAsNotNullJsonbStringUpdate (value_92de91cc . clone ())) . 0. value) })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value: OptionUuidUuidAsNullableJsonbStringRead::new(value.0.value.clone()),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionUuidUuidAsNullableJsonbStringRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionUuidUuidAsNullableJsonbStringRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common::NullableJsonObjectPostgresTypeWhereFilter(create.0.0.map(
                |value_18544acf| {
                    postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                        UuidUuidAsNotNullJsonbStringWhere::Equal(
                            where_filters::PostgresJsonTypeWhereEqual {
                                logical_operator: postgres_crud_common::LogicalOperator::Or,
                                value: UuidUuidAsNotNullJsonbStringTableTypeDeclaration::new(
                                    value_18544acf.into(),
                                ),
                            },
                        ),
                    ])
                    .expect("88bfa095-a3ab-4d0c-be71-af63c3acd50f")
                },
            ))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfUuidUuidAsNotNullArrayOfNotNullJsonbString;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin(
        Vec<UuidUuidAsNotNullJsonbStringOrigin>,
    );
    impl VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin {
        #[must_use]
        pub fn new(value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(
                value
                    .into_iter()
                    .map(UuidUuidAsNotNullJsonbStringOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreate>
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin
    {
        fn from(value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdate>
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin
    {
        fn from(value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration(
        VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin,
    );
    impl VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration {
        #[must_use]
        pub fn new(value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin::new(
                value,
            ))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreate(
        VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin,
    );
    impl VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreate {
        #[must_use]
        pub fn new(value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin::new(
                value,
            ))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreateForQuery(
        VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin,
    );
    impl VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreateForQuery {
        #[must_use]
        pub fn new(value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin::new(
                value,
            ))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl From<VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreate>
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreateForQuery
    {
        fn from(value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                UuidUuidAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                UuidUuidAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                UuidUuidAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                UuidUuidAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                UuidUuidAsNotNullJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneRegularExpression(
            where_filters::PostgresJsonTypeWhereDimensionOneRegularExpression,
        ),
        ContainsElRegularExpression(
            where_filters::PostgresJsonTypeWhereContainsElRegularExpression,
        ),
        AllElementsRegularExpression(
            where_filters::PostgresJsonTypeWhereAllElementsRegularExpression,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneRegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElRegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsRegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringRead(
        VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin,
    );
    impl VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringRead {
        #[must_use]
        pub fn new(value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin::new(
                value,
            ))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres> for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringRead {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadOnlyIds(
        pub postgres_crud_common::Value<Vec<uuid::Uuid>>,
    );
    pub type VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner = Vec<uuid::Uuid>;
    impl From<VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin>
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner
    {
        fn from(value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdate(
        VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin,
    );
    impl VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdate {
        #[must_use]
        pub fn new(value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin::new(
                value,
            ))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdateForQuery(
        VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin,
    );
    impl VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdateForQuery {
        #[must_use]
        pub fn new(value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin::new(
                value,
            ))
        }
    }
    impl From<VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdate>
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdateForQuery
    {
        fn from(value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdateForQuery {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbString {
        type TableTypeDeclaration =
            VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration;
        type Create = VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreate;
        type CreateForQuery = VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringCreateForQuery;
        type Select = VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringWhere;
        type Read = VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringRead;
        type ReadOnlyIds = VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('value',{column_name_and_maybe_field_getter})"
            ))
        }
        type ReadInner = VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0)
                .collect()
        }
        type Update = VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdate;
        type UpdateForQuery = VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_f06128be) => Ok(format!(
                    "'{field_ident}',jsonb_build_object('value',${value_f06128be}),"
                )),
                Err(error) => Err(error),
            }
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            mut query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_f06128be) => Ok(format!(
                    "'{field_ident}',jsonb_build_object('value',${value_f06128be}),"
                )),
                Err(error) => Err(error),
            }
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            mut query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfUuidUuidAsNotNullArrayOfNotNullJsonbString
    {
        type PostgresJsonType = Self;
        type Select = VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            None
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            Vec::new()
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringReadOnlyIds (postgres_crud_common :: Value { value : value . 0.0 . iter () . map (| el_aa999306 | < UuidUuidAsNotNullJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: update_to_read_only_ids (& UuidUuidAsNotNullJsonbStringUpdate (el_aa999306 . clone ())) . 0. value) . collect () })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringRead::new(
                    value.0.value.clone(),
                ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration(create.into())
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringWhere::Equal(
                where_filters::PostgresJsonTypeWhereEqual {
                    logical_operator: postgres_crud_common::LogicalOperator::Or,
                    value: VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration::new(
                        create.0.into(),
                    ),
                },
            )
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : UuidUuidAsNotNullJsonbStringTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbString;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin(
        Vec<OptionUuidUuidAsNullableJsonbStringOrigin>,
    );
    impl VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin {
        #[must_use]
        pub fn new(value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner) -> Self {
            Self(
                value
                    .into_iter()
                    .map(OptionUuidUuidAsNullableJsonbStringOrigin::new)
                    .collect(),
            )
        }
    }
    impl From<VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreate>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin
    {
        fn from(value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreate) -> Self {
            value.0
        }
    }
    impl From<VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdate>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin
    {
        fn from(value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(vec![
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ])
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration(
        VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin,
    );
    impl VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration {
        #[must_use]
        pub fn new(value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner) -> Self {
            Self(VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreate(
        VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin,
    );
    impl VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreate {
        #[must_use]
        pub fn new(value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner) -> Self {
            Self(VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreateForQuery(
        VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin,
    );
    impl VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreateForQuery {
        #[must_use]
        pub fn new(value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner) -> Self {
            Self(VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreate>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreateForQuery
    {
        fn from(value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub enum VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringWhere {
        Equal(
            where_filters::PostgresJsonTypeWhereEqual<
                VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneEqual(
            where_filters::PostgresJsonTypeWhereDimensionOneEqual<
                OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration,
            >,
        ),
        LengthEqual(where_filters::PostgresJsonTypeWhereLengthEqual),
        DimensionOneLengthEqual(where_filters::PostgresJsonTypeWhereDimensionOneLengthEqual),
        LengthGreaterThan(where_filters::PostgresJsonTypeWhereLengthGreaterThan),
        DimensionOneLengthGreaterThan(
            where_filters::PostgresJsonTypeWhereDimensionOneLengthGreaterThan,
        ),
        DimensionOneContainsAllElementsOfArray(
            where_filters::PostgresJsonTypeWhereDimensionOneContainsAllElementsOfArray<
                OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneOverlapsWithArray(
            where_filters::PostgresJsonTypeWhereDimensionOneOverlapsWithArray<
                OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration,
            >,
        ),
        AllElementsEqual(
            where_filters::PostgresJsonTypeWhereAllElementsEqual<
                OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneIn(
            where_filters::PostgresJsonTypeWhereDimensionOneIn<
                OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration,
            >,
        ),
        DimensionOneRegularExpression(
            where_filters::PostgresJsonTypeWhereDimensionOneRegularExpression,
        ),
        ContainsElRegularExpression(
            where_filters::PostgresJsonTypeWhereContainsElRegularExpression,
        ),
        AllElementsRegularExpression(
            where_filters::PostgresJsonTypeWhereAllElementsRegularExpression,
        ),
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl<'lifetime> postgres_crud_common::PostgresTypeWhereFilter<'lifetime>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringWhere
    {
        fn query_part(
            &self,
            increment: &mut u64,
            column: &dyn std::fmt::Display,
            is_need_to_add_logical_operator: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match &self {
                Self::Equal(value) => postgres_crud_common::PostgresTypeWhereFilter::query_part(
                    value,
                    increment,
                    column,
                    is_need_to_add_logical_operator,
                ),
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::DimensionOneRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::ContainsElRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
                Self::AllElementsRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_part(
                        value,
                        increment,
                        column,
                        is_need_to_add_logical_operator,
                    )
                }
            }
        }
        fn query_bind(
            self,
            query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            match self {
                Self::Equal(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::LengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneLengthGreaterThan(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneContainsAllElementsOfArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneOverlapsWithArray(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsEqual(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneIn(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::DimensionOneRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::ContainsElRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
                Self::AllElementsRegularExpression(value) => {
                    postgres_crud_common::PostgresTypeWhereFilter::query_bind(value, query)
                }
            }
        }
    }
    impl error_occurence_lib::ToStdStringString
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringWhere
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::AllEnumVariantsArrayDefaultOptionSomeVecOneEl
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringWhere
    {
        fn all_variants_default_option_some_vec_one_el() -> Vec<Self> {
            vec![
                Self::Equal(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::LengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneLengthGreaterThan(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneContainsAllElementsOfArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneOverlapsWithArray(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsEqual(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneIn(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::DimensionOneRegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::ContainsElRegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
                Self::AllElementsRegularExpression(
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
                ),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringRead(
        VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin,
    );
    impl VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringRead {
        #[must_use]
        pub fn new(value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner) -> Self {
            Self(VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadOnlyIds(
        pub postgres_crud_common::Value<Vec<Option<uuid::Uuid>>>,
    );
    pub type VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner =
        Vec<Option<uuid::Uuid>>;
    impl From<VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner
    {
        fn from(value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin) -> Self {
            value.0.into_iter().map(Into::into).collect()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdate(
        VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin,
    );
    impl VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdate {
        #[must_use]
        pub fn new(value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner) -> Self {
            Self(VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdateForQuery(
        VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin,
    );
    impl VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdateForQuery {
        #[must_use]
        pub fn new(value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner) -> Self {
            Self(VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl From<VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdate>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdateForQuery
    {
        fn from(value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbString
    {
        type TableTypeDeclaration =
            VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration;
        type Create = VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreate;
        type CreateForQuery = VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringCreateForQuery;
        type Select = VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end})))"
            ))
        }
        type Where = VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringWhere;
        type Read = VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringRead;
        type ReadOnlyIds = VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('value',{column_name_and_maybe_field_getter})"
            ))
        }
        type ReadInner = VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value
                .0
                .0
                .into_iter()
                .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                .collect()
        }
        type Update = VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdate;
        type UpdateForQuery = VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_f06128be) => Ok(format!(
                    "'{field_ident}',jsonb_build_object('value',${value_f06128be}),"
                )),
                Err(error) => Err(error),
            }
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            mut query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_f06128be) => Ok(format!(
                    "'{field_ident}',jsonb_build_object('value',${value_f06128be}),"
                )),
                Err(error) => Err(error),
            }
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            mut query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbString
    {
        type PostgresJsonType = Self;
        type Select = VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            None
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            Vec::new()
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringReadOnlyIds (postgres_crud_common :: Value { value : value . 0.0 . iter () . map (| el_aa999306 | < OptionUuidUuidAsNullableJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: update_to_read_only_ids (& OptionUuidUuidAsNullableJsonbStringUpdate (el_aa999306 . clone ())) . 0. value) . collect () })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value: VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringRead::new(
                    value.0.value.clone(),
                ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration :: new (create . 0 . into ()) })
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; for (index_0 , value0) in create . 0 . 0 . into_iter () . enumerate () { acc_049ff0b3 . push (VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration :: new (value0 . into ()) , })) ; } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringWhere::LengthEqual(
                    where_filters::PostgresJsonTypeWhereLengthEqual {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                            i32::try_from(create.0.0.len())
                                .expect("64d3424f-86fb-4b44-a437-75aea9997f47"),
                        )
                        .expect("081f4463-0430-4901-8a76-83afcfb3f856"),
                    },
                ),
            ]) {
                Ok(value_e196e86d) => Some(value_e196e86d),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("e9f9b021-e884-412e-bc02-7c1dafd35fdc"),
                },
            }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common::NotEmptyUniqueVec::try_new(vec![
                VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringWhere::LengthGreaterThan(
                    where_filters::PostgresJsonTypeWhereLengthGreaterThan {
                        logical_operator: postgres_crud_common::LogicalOperator::Or,
                        value: if let Ok(value_762dae1f) =
                            postgres_crud_common::UnsignedPartOfStdPrimitiveI32::try_from(
                                if let Ok(value_9dca0200) =
                                    i32::try_from(match create.0.0.len().checked_sub(1) {
                                        Some(value_92860143) => value_92860143,
                                        None => {
                                            return None;
                                        }
                                    })
                                {
                                    value_9dca0200
                                } else {
                                    return None;
                                },
                            ) {
                            value_762dae1f
                        } else {
                            return None;
                        },
                    },
                ),
            ]) {
                Ok(value_cee8d0ab) => Some(value_cee8d0ab),
                Err(error) => match error {
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::IsEmpty { .. } => None,
                    postgres_crud_common::NotEmptyUniqueVecTryNewErrorNamed::NotUnique {
                        ..
                    } => panic!("497359a5-49fb-4152-a9f4-5d1bbda2f926"),
                },
            }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbString;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin(
        Option<VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin>,
    );
    impl OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin {
        #[must_use]
        pub fn new(value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(value.map(VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringOrigin::new))
        }
    }
    impl From<OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreate>
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin
    {
        fn from(value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreate) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdate>
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin
    {
        fn from(value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdate) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration(
        OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin,
    );
    impl OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration {
        #[must_use]
        pub fn new(value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreate(
        OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin,
    );
    impl OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreate {
        #[must_use]
        pub fn new(value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreateForQuery(
        OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin,
    );
    impl OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreateForQuery {
        #[must_use]
        pub fn new(value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreate>
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreateForQuery
    {
        fn from(value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreate) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfUuidUuidAsNotNullArrayOfNotNullJsonbString as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringRead(
        OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin,
    );
    impl OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringRead {
        #[must_use]
        pub fn new(value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres> for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringRead {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            < sqlx :: types :: Json < OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: compatible (ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            < sqlx :: types :: Json < OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner > as sqlx :: Type < sqlx :: Postgres >> :: type_info ()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadOnlyIds(
        pub postgres_crud_common::Value<Option<Vec<uuid::Uuid>>>,
    );
    pub type OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner =
        Option<Vec<uuid::Uuid>>;
    impl From<OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin>
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner
    {
        fn from(value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdate(
        OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin,
    );
    impl OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdate {
        #[must_use]
        pub fn new(value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdateForQuery(
        OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin,
    );
    impl OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdateForQuery {
        #[must_use]
        pub fn new(value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner) -> Self {
            Self(OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin::new(value))
        }
    }
    impl From<OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdate>
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdateForQuery
    {
        fn from(value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdate) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbString
    {
        type TableTypeDeclaration =
            OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration;
        type Create = OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreate;
        type CreateForQuery = OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringCreateForQuery;
        type Select = OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringWhere;
        type Read = OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringRead;
        type ReadOnlyIds = OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('value',{column_name_and_maybe_field_getter})"
            ))
        }
        type ReadInner = OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0)
                    .collect()
            })
        }
        type Update = OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdate;
        type UpdateForQuery = OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_f06128be) => Ok(format!(
                    "'{field_ident}',jsonb_build_object('value',${value_f06128be}),"
                )),
                Err(error) => Err(error),
            }
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            mut query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_f06128be) => Ok(format!(
                    "'{field_ident}',jsonb_build_object('value',${value_f06128be}),"
                )),
                Err(error) => Err(error),
            }
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            mut query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbString
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            None
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            Vec::new()
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringReadOnlyIds (postgres_crud_common :: Value { value : value . 0.0 . as_ref () . map (| value_92de91cc | < VecOfUuidUuidAsNotNullArrayOfNotNullJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: update_to_read_only_ids (& VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringUpdate (value_92de91cc . clone ())) . 0. value) })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value: OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringRead::new(
                    value.0.value.clone(),
                ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringRead(value_f6e37412.into())
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfUuidUuidAsNullableArrayOfNotNullJsonbStringTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : UuidUuidAsNotNullJsonbStringTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfUuidUuidAsNotNullArrayOfNotNullJsonbStringWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
    #[derive(Debug, Clone, Copy)]
    pub struct OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbString;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin(
        Option<VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin>,
    );
    impl OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(value.map(VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringOrigin::new))
        }
    }
    impl From<OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreate>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin
    {
        fn from(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreate,
        ) -> Self {
            value.0
        }
    }
    impl From<OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdate>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin
    {
        fn from(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdate,
        ) -> Self {
            value.0
        }
    }
    impl std::fmt::Display for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{self:?}")
        }
    }
    impl error_occurence_lib::ToStdStringString
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin
    {
        fn to_std_string_string(&self) -> String {
            format!("{self:#?}")
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(Some(
                postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(),
            ))
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringTableTypeDeclaration(
        OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin,
    );
    impl OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringTableTypeDeclaration {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringTableTypeDeclaration
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringTableTypeDeclaration
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringTableTypeDeclaration
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreate(
        OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin,
    );
    impl OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreateForQuery(
        OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin,
    );
    impl OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    impl From<OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreate>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreateForQuery
    {
        fn from(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreate,
        ) -> Self {
            Self(value.0)
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringSelect {
        dimension1_pagination: postgres_crud_common::PaginationStartsWithZero,
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringSelect
    {
        fn default_option_some_vec_one_el() -> Self {
            Self {
                dimension1_pagination:
                    postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el(
                    ),
            }
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneElMaxPageSize
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringSelect
    {
        fn default_option_some_vec_one_el_max_page_size() -> Self {
            Self { dimension1_pagination : postgres_crud_common :: DefaultOptionSomeVecOneElMaxPageSize :: default_option_some_vec_one_el_max_page_size () }
        }
    }
    pub type OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringWhere = postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter < < VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbString as postgres_crud_common :: PostgresJsonType > :: Where > ;
    #[derive(
        Debug,
        Clone,
        PartialEq,
        PartialOrd,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringRead(
        OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin,
    );
    impl OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringRead {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringRead
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringRead
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&&self.0, buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringRead
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <sqlx::types::Json<
                OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <sqlx::types::Json<
                OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
            > as sqlx::Type<sqlx::Postgres>>::type_info()
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
    pub struct OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadOnlyIds(
        pub postgres_crud_common::Value<Option<Vec<Option<uuid::Uuid>>>>,
    );
    pub type OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner =
        Option<Vec<Option<uuid::Uuid>>>;
    impl From<OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner
    {
        fn from(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin,
        ) -> Self {
            value.0.map(Into::into)
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        serde :: Serialize,
        serde :: Deserialize,
        utoipa :: ToSchema,
        schemars :: JsonSchema,
    )]
    pub struct OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdate(
        OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin,
    );
    impl OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdate {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl postgres_crud_common::DefaultOptionSomeVecOneEl
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdate
    {
        fn default_option_some_vec_one_el() -> Self {
            Self(postgres_crud_common::DefaultOptionSomeVecOneEl::default_option_some_vec_one_el())
        }
    }
    #[derive(Debug, Clone, PartialEq, serde :: Serialize)]
    pub struct OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdateForQuery(
        OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin,
    );
    impl OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdateForQuery {
        #[must_use]
        pub fn new(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> Self {
            Self(OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin::new(value))
        }
    }
    impl From<OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdate>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdateForQuery
    {
        fn from(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdate,
        ) -> Self {
            Self(value.0)
        }
    }
    impl sqlx::Encode<'_, sqlx::Postgres>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdateForQuery
    {
        fn encode_by_ref(
            &self,
            buf: &mut sqlx::postgres::PgArgumentBuffer,
        ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
            sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&sqlx::types::Json(&self.0), buf)
        }
    }
    impl sqlx::Type<sqlx::Postgres>
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdateForQuery
    {
        fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
            <OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::compatible(ty)
        }
        fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
            <OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringOrigin as sqlx::Type<
                sqlx::Postgres,
            >>::type_info()
        }
    }
    #[allow(clippy::arbitrary_source_item_ordering)]
    impl postgres_crud_common::PostgresJsonType
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbString
    {
        type TableTypeDeclaration =
            OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringTableTypeDeclaration;
        type Create = OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreate;
        type CreateForQuery =
            OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringCreateForQuery;
        type Select = OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringSelect;
        fn select_query_part(
            value: &Self::Select,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            _: &str,
            _: bool,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            let dimension1_start = value.dimension1_pagination.start();
            let dimension1_end = value.dimension1_pagination.end();
            Ok(format!(
                "jsonb_build_object('{field_ident}',jsonb_build_object('value',(case when jsonb_typeof({column_name_and_maybe_field_getter}->'{field_ident}')='null' then 'null'::jsonb else (select jsonb_agg((value)) from jsonb_array_elements((select {column_name_and_maybe_field_getter}->'{field_ident}')) with ordinality where ordinality between {dimension1_start} and {dimension1_end}) end)))"
            ))
        }
        type Where = OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringWhere;
        type Read = OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringRead;
        type ReadOnlyIds = OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadOnlyIds;
        fn select_only_ids_query_part(
            column_name_and_maybe_field_getter: &str,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            Ok(format!(
                "jsonb_build_object('value',{column_name_and_maybe_field_getter})"
            ))
        }
        type ReadInner = OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner;
        fn into_inner(value: Self::Read) -> Self::ReadInner {
            value.0.0.map(|value_3432e728| {
                value_3432e728
                    .0
                    .into_iter()
                    .map(|el_0fdb74a5| el_0fdb74a5.0.map(|value_f8b0b01d| value_f8b0b01d.0))
                    .collect()
            })
        }
        type Update = OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdate;
        type UpdateForQuery =
            OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringUpdateForQuery;
        fn update_query_part(
            _: &Self::UpdateForQuery,
            jsonb_set_accumulator: &str,
            _: &str,
            jsonb_set_path: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_26526e0f) => Ok(format!(
                    "jsonb_set({jsonb_set_accumulator},'{{{jsonb_set_path}}}',${value_26526e0f})"
                )),
                Err(error) => Err(error),
            }
        }
        fn update_query_bind(
            value: Self::UpdateForQuery,
            mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>, String>
        {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_updated_ids_query_part(
            value: &Self::UpdateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_f06128be) => Ok(format!(
                    "'{field_ident}',jsonb_build_object('value',${value_f06128be}),"
                )),
                Err(error) => Err(error),
            }
        }
        fn select_only_updated_ids_query_bind<'lifetime>(
            value: &'lifetime Self::UpdateForQuery,
            mut query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
        fn select_only_created_ids_query_part(
            value: &Self::CreateForQuery,
            field_ident: &str,
            column_name_and_maybe_field_getter: &str,
            increment: &mut u64,
        ) -> Result<String, postgres_crud_common::QueryPartErrorNamed> {
            match postgres_crud_common::increment_checked_add_one_returning_increment(increment) {
                Ok(value_f06128be) => Ok(format!(
                    "'{field_ident}',jsonb_build_object('value',${value_f06128be}),"
                )),
                Err(error) => Err(error),
            }
        }
        fn select_only_created_ids_query_bind<'lifetime>(
            value: &'lifetime Self::CreateForQuery,
            mut query: sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
        ) -> Result<
            sqlx::query::Query<'lifetime, sqlx::Postgres, sqlx::postgres::PgArguments>,
            String,
        > {
            if let Err(error) = query.try_bind(value) {
                return Err(error.to_string());
            }
            Ok(query)
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::absolute_paths)]
    #[allow(clippy::arbitrary_source_item_ordering)]
    #[cfg(feature = "test-utils")]
    #[allow(clippy::float_arithmetic)]
    impl postgres_crud_common::PostgresJsonTypeTestCases
        for OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbString
    {
        type PostgresJsonType = Self;
        type Select = OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringSelect;
        fn option_vec_create()
        -> Option<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create>>
        {
            None
        }
        fn read_only_ids_to_two_dimensional_vec_read_inner(
            read_only_ids : & < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
        ) -> Vec<Vec<<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner>>
        {
            Vec::new()
        }
        fn read_inner_into_read_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read::new(value)
        }
        fn read_inner_into_update_with_new_or_try_new_unwraped(
            value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadInner,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update {
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update::new(value)
        }
        fn read_only_ids_into_option_value_read_inner(
            value: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadInner,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonType > :: into_inner (< < Self as postgres_crud_common :: PostgresJsonType > :: Read as postgres_crud_common :: DefaultOptionSomeVecOneEl > :: default_option_some_vec_one_el ()) })
        }
        fn update_to_read_only_ids(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds
        {
            OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringReadOnlyIds (postgres_crud_common :: Value { value : value . 0.0 . as_ref () . map (| value_92de91cc | < VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbString as postgres_crud_common :: PostgresJsonTypeTestCases > :: update_to_read_only_ids (& VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringUpdate (value_92de91cc . clone ())) . 0. value) })
        }
        fn read_only_ids_to_option_value_read_default_option_some_vec_one_el(
            value: &<Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::ReadOnlyIds,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some(postgres_crud_common::Value {
                value: OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringRead::new(
                    value.0.value.clone(),
                ),
            })
        }
        fn previous_read_merged_with_option_update_into_read(
            read: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            option_update: Option<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Update,
            >,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            option_update.map_or(read, |value_f6e37412| {
                OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringRead(
                    value_f6e37412.into(),
                )
            })
        }
        fn read_only_ids_merged_with_create_into_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read {
            OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringRead(create.into())
        }
        fn read_only_ids_merged_with_create_into_option_value_read(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::Value<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Read,
            >,
        > {
            Some (postgres_crud_common :: Value { value : < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_read (read_only_ids , create) })
        }
        fn read_only_ids_merged_with_create_into_table_type_declaration(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::TableTypeDeclaration
        {
            OptionVecOfOptionUuidUuidAsNullableArrayOfNullableJsonbStringTableTypeDeclaration(
                create.into(),
            )
        }
        fn read_only_ids_merged_with_create_into_where_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where {
            postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (create . 0.0 . map (| value_18544acf | postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringWhere :: Equal (where_filters :: PostgresJsonTypeWhereEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringTableTypeDeclaration :: new (value_18544acf . into ()) })]) . expect ("88bfa095-a3ab-4d0c-be71-af63c3acd50f")))
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [< Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_where_equal (read_only_ids , create)]) . expect ("56eb9ad4-8f4f-4833-9618-7327f42b0014")
        }
        fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> postgres_crud_common::NotEmptyUniqueVec<
            <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
        > {
            < Self as postgres_crud_common :: PostgresJsonTypeTestCases > :: read_only_ids_merged_with_create_into_vec_where_equal_using_fields (read_only_ids , create)
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_one_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            Some (postgres_crud_common :: NotEmptyUniqueVec :: try_new ({ let mut acc_049ff0b3 = Vec :: new () ; if let Some (value0) = create . 0 . 0 { for (index_0 , value1) in value0 . 0 . into_iter () . enumerate () { match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringWhere :: DimensionOneEqual (where_filters :: PostgresJsonTypeWhereDimensionOneEqual { logical_operator : postgres_crud_common :: LogicalOperator :: And , dimensions : where_filters :: BoundedStdVecVec :: try_from (vec ! [postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (index_0) . expect ("5a1818e7-3865-4222-bf6b-31486bd721d2")) . expect ("ad1ab73f-fd3b-4162-adb0-bb09a19d31a0")]) . expect ("82cc0a3c-3e8d-47c4-b317-2795362a9b37") , value : OptionUuidUuidAsNullableJsonbStringTableTypeDeclaration :: new (value1 . into ()) , })]) { Ok (value_9328b66f) => { acc_049ff0b3 . push (postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (Some (value_9328b66f))) ; } , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => () , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("2f5f648a-4dc6-4699-8656-33870b2c629f") } } } } acc_049ff0b3 }) . expect ("e99ecd08-0aec-4a25-931d-163319bb8179"))
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_two_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_three_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_dimension_four_equal(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            None
        }
        fn create_into_postgres_json_type_option_vec_where_length_equal(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_1bbf74bc) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringWhere :: LengthEqual (where_filters :: PostgresJsonTypeWhereLengthEqual { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (i32 :: try_from (value_1bbf74bc . 0 . len ()) . expect ("64d3424f-86fb-4b44-a437-75aea9997f47")) . expect ("081f4463-0430-4901-8a76-83afcfb3f856") , })]) { Ok (value_d82bbdbe) => Some (value_d82bbdbe) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("3d7ce854-db39-493c-bde3-a3dec5a8a9c3") } } , None => None , })]) { Ok (value_e196e86d) => Some (value_e196e86d) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("e9f9b021-e884-412e-bc02-7c1dafd35fdc") } }
        }
        fn create_into_postgres_json_type_option_vec_where_length_greater_than(
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
            >,
        > {
            match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [postgres_crud_common :: NullableJsonObjectPostgresTypeWhereFilter (match create . 0.0 { Some (value_68880991) => match postgres_crud_common :: NotEmptyUniqueVec :: try_new (vec ! [VecOfOptionUuidUuidAsNotNullArrayOfNullableJsonbStringWhere :: LengthGreaterThan (where_filters :: PostgresJsonTypeWhereLengthGreaterThan { logical_operator : postgres_crud_common :: LogicalOperator :: Or , value : if let Ok (value_762dae1f) = postgres_crud_common :: UnsignedPartOfStdPrimitiveI32 :: try_from (if let Ok (value_9dca0200) = i32 :: try_from (match value_68880991 . 0 . len () . checked_sub (1) { Some (value_92860143) => value_92860143 , None => { return None ; } }) { value_9dca0200 } else { return None ; }) { value_762dae1f } else { return None ; } })]) { Ok (value_cdc120a8) => Some (value_cdc120a8) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => { return None ; } , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("584f801e-e26d-486b-8814-758cd421bee4") } } , None => None , })]) { Ok (value_cee8d0ab) => Some (value_cee8d0ab) , Err (error) => match error { postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: IsEmpty { .. } => None , postgres_crud_common :: NotEmptyUniqueVecTryNewErrorNamed :: NotUnique { .. } => panic ! ("497359a5-49fb-4152-a9f4-5d1bbda2f926") } , }
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_between(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_in(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_greater_than(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
        fn read_only_ids_merged_with_create_into_postgres_json_type_option_vec_where_contains_el_regular_expression(
            read_only_ids : < Self :: PostgresJsonType as postgres_crud_common :: PostgresJsonType > :: ReadOnlyIds,
            create: <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Create,
        ) -> Option<
            postgres_crud_common::NotEmptyUniqueVec<
                postgres_crud_common::SingleOrMultiple<
                    <Self::PostgresJsonType as postgres_crud_common::PostgresJsonType>::Where,
                >,
            >,
        > {
            None
        }
    }
}
pub use gen_postgres_json_types_mod::*;
