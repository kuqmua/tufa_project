// generate_postgresql_types::generate_postgresql_types!("All");
// generate_postgresql_types::generate_postgresql_types!({
//     "Concrete": [
//         // {
//         //     "postgresql_type": "StdPrimitiveI64AsInt8",
//         //     "not_null_or_nullable": "NotNull",
//         //     "postgresql_type_pattern": "Standart"
//         // },
//         {
//             "postgresql_type": "StdStringStringAsText",
//             "not_null_or_nullable": "NotNull",
//             "postgresql_type_pattern": "Standart"
//         }
//         ,
//         {
//             "postgresql_type": "StdPrimitiveI16AsInt2",
//             "not_null_or_nullable": "NotNull",
//             "postgresql_type_pattern": "Standart"
//         },
//         {
//             "postgresql_type": "StdPrimitiveI32AsInt4",
//             "not_null_or_nullable": "NotNull",
//             "postgresql_type_pattern": "Standart"
//         },
//         {
//             "postgresql_type": "StdPrimitiveI16AsInt2",
//             "not_null_or_nullable": "Nullable",
//             "postgresql_type_pattern": "Standart"
//         },
//         {
//             "postgresql_type": "StdPrimitiveI16AsInt2",
//             "not_null_or_nullable": "NotNull",
//             "postgresql_type_pattern": {
//                 "ArrayDimension1": {
//                     "dimension1_not_null_or_nullable": "NotNull"
//                 }
//             }
//         },
//         {
//             "postgresql_type": "StdPrimitiveI16AsInt2",
//             "not_null_or_nullable": "NotNull",
//             "postgresql_type_pattern": {
//                 "ArrayDimension1": {
//                     "dimension1_not_null_or_nullable": "Nullable"
//                 }
//             }
//         },
//         {
//             "postgresql_type": "StdPrimitiveI16AsInt2",
//             "not_null_or_nullable": "Nullable",
//             "postgresql_type_pattern": {
//                 "ArrayDimension1": {
//                     "dimension1_not_null_or_nullable": "NotNull"
//                 }
//             }
//         },
//         {
//             "postgresql_type": "StdPrimitiveI16AsInt2",
//             "not_null_or_nullable": "Nullable",
//             "postgresql_type_pattern": {
//                 "ArrayDimension1": {
//                     "dimension1_not_null_or_nullable": "Nullable"
//                 }
//             }
//         },
//         // {
//         //     "postgresql_type": "StdPrimitiveI64AsBigSerialInitializedByPostgresql",
//         //     "not_null_or_nullable": "NotNull",
//         //     "postgresql_type_pattern": "Standart"
//         // },
//         // {
//         //     "postgresql_type": "StdStringStringAsText",
//         //     "not_null_or_nullable": "NotNull",
//         //     "postgresql_type_pattern": {
//         //         "ArrayDimension1": {
//         //             "dimension1_not_null_or_nullable": "NotNull"
//         //         }
//         //     }
//         // },
//         // {
//         //     "postgresql_type": "SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsTimestampTz",
//         //     "not_null_or_nullable": "NotNull",
//         //     "postgresql_type_pattern": {
//         //         "ArrayDimension1": {
//         //             "dimension1_not_null_or_nullable": "NotNull"
//         //         }
//         //     }
//         // },
//         // {
//         //     "postgresql_type": "SqlxTypesTimeDateAsDate",
//         //     "not_null_or_nullable": "NotNull",
//         //     "postgresql_type_pattern": {
//         //         "ArrayDimension1": {
//         //             "dimension1_not_null_or_nullable": "NotNull"
//         //         }
//         //     }
//         // },
//         // {
//         //     "postgresql_type": "SqlxTypesChronoNaiveDateTimeAsTimestamp",
//         //     "not_null_or_nullable": "NotNull",
//         //     "postgresql_type_pattern": {
//         //         "ArrayDimension1": {
//         //             "dimension1_not_null_or_nullable": "NotNull"
//         //         }
//         //     }
//         // },
//         // {
//         //     "postgresql_type": "SqlxTypesChronoNaiveTimeAsTime",
//         //     "not_null_or_nullable": "NotNull",
//         //     "postgresql_type_pattern": {
//         //         "ArrayDimension1": {
//         //             "dimension1_not_null_or_nullable": "NotNull"
//         //         }
//         //     }
//         // },
//         // {
//         //     "postgresql_type": "StdVecVecStdPrimitiveU8AsBytea",
//         //     "not_null_or_nullable": "NotNull",
//         //     "postgresql_type_pattern": {
//         //         "ArrayDimension1": {
//         //             "dimension1_not_null_or_nullable": "NotNull"
//         //         }
//         //     }
//         // }
//         // ,
//         // {
//         //     "postgresql_type": "SqlxPostgresTypesPgRangeStdPrimitiveI32AsInt4Range",
//         //     "not_null_or_nullable": "NotNull",
//         //     "postgresql_type_pattern": {
//         //         "ArrayDimension1": {
//         //             "dimension1_not_null_or_nullable": "NotNull"
//         //         }
//         //     }
//         // },
//         // {
//         //     "postgresql_type": "SqlxPostgresTypesPgRangeStdPrimitiveI64AsInt8Range",
//         //     "not_null_or_nullable": "NotNull",
//         //     "postgresql_type_pattern": {
//         //         "ArrayDimension1": {
//         //             "dimension1_not_null_or_nullable": "NotNull"
//         //         }
//         //     }
//         // },
//         {
//             "postgresql_type": "SqlxTypesUuidUuidAsUuidV4InitializedByPostgresql",
//             "not_null_or_nullable": "NotNull",
//             "postgresql_type_pattern": "Standart"
//         }
//     ]
// });

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, schemars::JsonSchema)]
pub enum EncodeFormat {
    Base64,
    Hex,
    Escape,
}
impl std::fmt::Display for EncodeFormat {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            Self::Base64 => write!(formatter, "base64"),
            Self::Hex => write!(formatter, "hex"),
            Self::Escape => write!(formatter, "escape"),
        }
    }
}
impl std::default::Default for EncodeFormat {
    fn default() -> Self {
        Self::Base64
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for EncodeFormat {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self::default()
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, utoipa::ToSchema)]
pub struct SqlxTypesTimeUtcOffset(pub sqlx::types::time::UtcOffset);
impl serde::Serialize for SqlxTypesTimeUtcOffset {
    fn serialize<__S>(&self, __serializer: __S) -> serde::__private::Result<__S::Ok, __S::Error>
    where
        __S: serde::Serializer,
    {
        let mut __serde_state = serde::Serializer::serialize_struct(__serializer, "SqlxTypesTimeUtcOffset", usize::from(false) + 1 + 1 + 1)?;
        serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "hours", &self.0.whole_hours())?;
        serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "minutes", &self.0.minutes_past_hour())?;
        serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "seconds", &self.0.seconds_past_minute())?;
        serde::ser::SerializeStruct::end(__serde_state)
    }
}
impl<'de> serde::Deserialize<'de> for SqlxTypesTimeUtcOffset {
    fn deserialize<__D>(__deserializer: __D) -> serde::__private::Result<Self, __D::Error>
    where
        __D: serde::Deserializer<'de>,
    {
        #[expect(non_camel_case_types)]
        #[doc(hidden)]
        enum __Field {
            __field0,
            __field1,
            __field2,
            __ignore,
        }
        #[doc(hidden)]
        struct __FieldVisitor;
        impl serde::de::Visitor<'_> for __FieldVisitor {
            type Value = __Field;
            fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                serde::__private::Formatter::write_str(__f, "field identifier")
            }
            fn visit_u64<__E>(self, __value: u64) -> serde::__private::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    0u64 => serde::__private::Ok(__Field::__field0),
                    1u64 => serde::__private::Ok(__Field::__field1),
                    2u64 => serde::__private::Ok(__Field::__field2),
                    _ => serde::__private::Ok(__Field::__ignore),
                }
            }
            fn visit_str<__E>(self, __value: &str) -> serde::__private::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    "hours" => serde::__private::Ok(__Field::__field0),
                    "minutes" => serde::__private::Ok(__Field::__field1),
                    "seconds" => serde::__private::Ok(__Field::__field2),
                    _ => serde::__private::Ok(__Field::__ignore),
                }
            }
            fn visit_bytes<__E>(self, __value: &[u8]) -> serde::__private::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    b"hours" => serde::__private::Ok(__Field::__field0),
                    b"minutes" => serde::__private::Ok(__Field::__field1),
                    b"seconds" => serde::__private::Ok(__Field::__field2),
                    _ => serde::__private::Ok(__Field::__ignore),
                }
            }
        }
        impl<'de> serde::Deserialize<'de> for __Field {
            #[inline]
            fn deserialize<__D>(__deserializer: __D) -> serde::__private::Result<Self, __D::Error>
            where
                __D: serde::Deserializer<'de>,
            {
                serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
            }
        }
        #[doc(hidden)]
        struct __Visitor<'de> {
            marker: serde::__private::PhantomData<SqlxTypesTimeUtcOffset>,
            lifetime: serde::__private::PhantomData<&'de ()>,
        }
        impl<'de> serde::de::Visitor<'de> for __Visitor<'de> {
            type Value = SqlxTypesTimeUtcOffset;
            fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                serde::__private::Formatter::write_str(__f, "struct SqlxTypesTimeUtcOffset")
            }
            #[inline]
            fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
            where
                __A: serde::de::SeqAccess<'de>,
            {
                let __field0 = match serde::de::SeqAccess::next_element::<std::primitive::i8>(&mut __seq)? {
                    serde::__private::Some(__value) => __value,
                    serde::__private::None => {
                        return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxTypesTimeUtcOffset with 3 elements"));
                    }
                };
                let __field1 = match serde::de::SeqAccess::next_element::<std::primitive::i8>(&mut __seq)? {
                    serde::__private::Some(__value) => __value,
                    serde::__private::None => {
                        return serde::__private::Err(serde::de::Error::invalid_length(1usize, &"struct SqlxTypesTimeUtcOffset with 3 elements"));
                    }
                };
                let __field2 = match serde::de::SeqAccess::next_element::<std::primitive::i8>(&mut __seq)? {
                    serde::__private::Some(__value) => __value,
                    serde::__private::None => {
                        return serde::__private::Err(serde::de::Error::invalid_length(2usize, &"struct SqlxTypesTimeUtcOffset with 3 elements"));
                    }
                };
                serde::__private::Ok(SqlxTypesTimeUtcOffset(match sqlx::types::time::UtcOffset::from_hms(__field0, __field1, __field2) {
                    Ok(value) => value,
                    Err(error) => {
                        return Err(serde::de::Error::custom(error));
                    }
                }))
            }
            #[inline]
            fn visit_map<__A>(self, mut __map: __A) -> serde::__private::Result<Self::Value, __A::Error>
            where
                __A: serde::de::MapAccess<'de>,
            {
                let mut __field0: serde::__private::Option<std::primitive::i8> = serde::__private::None;
                let mut __field1: serde::__private::Option<std::primitive::i8> = serde::__private::None;
                let mut __field2: serde::__private::Option<std::primitive::i8> = serde::__private::None;
                while let serde::__private::Some(__key) = serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                    match __key {
                        __Field::__field0 => {
                            if serde::__private::Option::is_some(&__field0) {
                                return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("hours"));
                            }
                            __field0 = serde::__private::Some(serde::de::MapAccess::next_value::<std::primitive::i8>(&mut __map)?);
                        }
                        __Field::__field1 => {
                            if serde::__private::Option::is_some(&__field1) {
                                return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("minutes"));
                            }
                            __field1 = serde::__private::Some(serde::de::MapAccess::next_value::<std::primitive::i8>(&mut __map)?);
                        }
                        __Field::__field2 => {
                            if serde::__private::Option::is_some(&__field2) {
                                return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("seconds"));
                            }
                            __field2 = serde::__private::Some(serde::de::MapAccess::next_value::<std::primitive::i8>(&mut __map)?);
                        }
                        _ => {
                            let _ = serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(&mut __map)?;
                        }
                    }
                }
                let __field0 = match __field0 {
                    serde::__private::Some(__field0) => __field0,
                    serde::__private::None => serde::__private::de::missing_field("hours")?,
                };
                let __field1 = match __field1 {
                    serde::__private::Some(__field1) => __field1,
                    serde::__private::None => serde::__private::de::missing_field("minutes")?,
                };
                let __field2 = match __field2 {
                    serde::__private::Some(__field2) => __field2,
                    serde::__private::None => serde::__private::de::missing_field("seconds")?,
                };
                serde::__private::Ok(SqlxTypesTimeUtcOffset(match sqlx::types::time::UtcOffset::from_hms(__field0, __field1, __field2) {
                    Ok(value) => value,
                    Err(error) => {
                        return Err(serde::de::Error::custom(error));
                    }
                }))
            }
        }
        #[doc(hidden)]
        const FIELDS: &[&str] = &["hours", "minutes", "seconds"];
        serde::Deserializer::deserialize_struct(
            __deserializer,
            "SqlxTypesTimeUtcOffset",
            FIELDS,
            __Visitor {
                marker: serde::__private::PhantomData::<Self>,
                lifetime: serde::__private::PhantomData,
            },
        )
    }
}
#[derive(Debug, Clone, PartialEq, Eq, utoipa::ToSchema)]
pub struct NumBigintBigInt(pub num_bigint::BigInt);
impl serde::Serialize for NumBigintBigInt {
    fn serialize<__S>(&self, __serializer: __S) -> serde::__private::Result<__S::Ok, __S::Error>
    where
        __S: serde::Serializer,
    {
        let (sign, digits) = self.0.to_u32_digits();
        let mut __serde_state = serde::Serializer::serialize_struct(__serializer, "NumBigintBigInt", usize::from(false) + 1 + 1)?;
        serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "sign", &NumBigintSign(sign))?;
        serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "digits", &digits)?;
        serde::ser::SerializeStruct::end(__serde_state)
    }
}
impl<'de> serde::Deserialize<'de> for NumBigintBigInt {
    fn deserialize<__D>(__deserializer: __D) -> serde::__private::Result<Self, __D::Error>
    where
        __D: serde::Deserializer<'de>,
    {
        #[expect(non_camel_case_types)]
        #[doc(hidden)]
        enum __Field {
            __field0,
            __field1,
            __ignore,
        }
        #[doc(hidden)]
        struct __FieldVisitor;
        impl serde::de::Visitor<'_> for __FieldVisitor {
            type Value = __Field;
            fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                serde::__private::Formatter::write_str(__f, "field identifier")
            }
            fn visit_u64<__E>(self, __value: u64) -> serde::__private::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    0u64 => serde::__private::Ok(__Field::__field0),
                    1u64 => serde::__private::Ok(__Field::__field1),
                    _ => serde::__private::Ok(__Field::__ignore),
                }
            }
            fn visit_str<__E>(self, __value: &str) -> serde::__private::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    "sign" => serde::__private::Ok(__Field::__field0),
                    "digits" => serde::__private::Ok(__Field::__field1),
                    _ => serde::__private::Ok(__Field::__ignore),
                }
            }
            fn visit_bytes<__E>(self, __value: &[u8]) -> serde::__private::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    b"sign" => serde::__private::Ok(__Field::__field0),
                    b"digits" => serde::__private::Ok(__Field::__field1),
                    _ => serde::__private::Ok(__Field::__ignore),
                }
            }
        }
        impl<'de> serde::Deserialize<'de> for __Field {
            #[inline]
            fn deserialize<__D>(__deserializer: __D) -> serde::__private::Result<Self, __D::Error>
            where
                __D: serde::Deserializer<'de>,
            {
                serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
            }
        }
        #[doc(hidden)]
        struct __Visitor<'de> {
            marker: serde::__private::PhantomData<NumBigintBigInt>,
            lifetime: serde::__private::PhantomData<&'de ()>,
        }
        impl<'de> serde::de::Visitor<'de> for __Visitor<'de> {
            type Value = NumBigintBigInt;
            fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                serde::__private::Formatter::write_str(__f, "struct NumBigintBigInt")
            }
            #[inline]
            fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
            where
                __A: serde::de::SeqAccess<'de>,
            {
                let __field0 = match serde::de::SeqAccess::next_element::<NumBigintSign>(&mut __seq)? {
                    serde::__private::Some(__value) => __value,
                    serde::__private::None => return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct NumBigintBigInt with 2 elements")),
                };
                let __field1 = match serde::de::SeqAccess::next_element::<std::vec::Vec<std::primitive::u32>>(&mut __seq)? {
                    serde::__private::Some(__value) => __value,
                    serde::__private::None => return serde::__private::Err(serde::de::Error::invalid_length(1usize, &"struct NumBigintBigInt with 2 elements")),
                };
                serde::__private::Ok(NumBigintBigInt(num_bigint::BigInt::new(__field0.0, __field1)))
            }
            #[inline]
            fn visit_map<__A>(self, mut __map: __A) -> serde::__private::Result<Self::Value, __A::Error>
            where
                __A: serde::de::MapAccess<'de>,
            {
                let mut __field0: serde::__private::Option<NumBigintSign> = serde::__private::None;
                let mut __field1: serde::__private::Option<std::vec::Vec<std::primitive::u32>> = serde::__private::None;
                while let serde::__private::Some(__key) = serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                    match __key {
                        __Field::__field0 => {
                            if serde::__private::Option::is_some(&__field0) {
                                return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("sign"));
                            }
                            __field0 = serde::__private::Some(serde::de::MapAccess::next_value::<NumBigintSign>(&mut __map)?);
                        }
                        __Field::__field1 => {
                            if serde::__private::Option::is_some(&__field1) {
                                return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("digits"));
                            }
                            __field1 = serde::__private::Some(serde::de::MapAccess::next_value::<std::vec::Vec<std::primitive::u32>>(&mut __map)?);
                        }
                        _ => {
                            let _ = serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(&mut __map)?;
                        }
                    }
                }
                let __field0 = match __field0 {
                    serde::__private::Some(__field0) => __field0,
                    serde::__private::None => serde::__private::de::missing_field("sign")?,
                };
                let __field1 = match __field1 {
                    serde::__private::Some(__field1) => __field1,
                    serde::__private::None => serde::__private::de::missing_field("digits")?,
                };
                serde::__private::Ok(NumBigintBigInt(num_bigint::BigInt::new(__field0.0, __field1)))
            }
        }
        #[doc(hidden)]
        const FIELDS: &[&str] = &["sign", "digits"];
        serde::Deserializer::deserialize_struct(
            __deserializer,
            "NumBigintBigInt",
            FIELDS,
            __Visitor {
                marker: serde::__private::PhantomData::<Self>,
                lifetime: serde::__private::PhantomData,
            },
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, utoipa::ToSchema)]
pub struct NumBigintSign(pub num_bigint::Sign);
impl serde::Serialize for NumBigintSign {
    fn serialize<__S>(&self, __serializer: __S) -> serde::__private::Result<__S::Ok, __S::Error>
    where
        __S: serde::Serializer,
    {
        serde::Serializer::serialize_newtype_struct(
            __serializer,
            "NumBigintSign",
            match self.0 {
                num_bigint::Sign::Minus => "Minus",
                num_bigint::Sign::NoSign => "NoSign",
                num_bigint::Sign::Plus => "Plus",
            },
        )
    }
}
impl<'de> serde::Deserialize<'de> for NumBigintSign {
    fn deserialize<__D>(__deserializer: __D) -> serde::__private::Result<Self, __D::Error>
    where
        __D: serde::Deserializer<'de>,
    {
        #[doc(hidden)]
        struct __Visitor<'de> {
            marker: serde::__private::PhantomData<NumBigintSign>,
            lifetime: serde::__private::PhantomData<&'de ()>,
        }
        impl<'de> serde::de::Visitor<'de> for __Visitor<'de> {
            type Value = NumBigintSign;
            fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                serde::__private::Formatter::write_str(__f, "tuple struct NumBigintSign")
            }
            #[inline]
            fn visit_newtype_struct<__E>(self, __e: __E) -> serde::__private::Result<Self::Value, __E::Error>
            where
                __E: serde::Deserializer<'de>,
            {
                let __field0: std::string::String = <std::string::String as serde::Deserialize>::deserialize(__e)?;
                serde::__private::Ok(NumBigintSign(match __field0.as_str() {
                    "Minus" => num_bigint::Sign::Minus,
                    "NoSign" => num_bigint::Sign::NoSign,
                    "Plus" => num_bigint::Sign::Plus,
                    _ => {
                        return Err(serde::de::Error::custom("unsupported value, supported: Minus, NoSign, Plus"));
                    }
                }))
            }
            #[inline]
            fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
            where
                __A: serde::de::SeqAccess<'de>,
            {
                let __field0 = match serde::de::SeqAccess::next_element::<std::string::String>(&mut __seq)? {
                    serde::__private::Some(__value) => __value,
                    serde::__private::None => {
                        return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"tuple struct NumBigintSign with 1 element"));
                    }
                };
                serde::__private::Ok(NumBigintSign(match __field0.as_str() {
                    "Minus" => num_bigint::Sign::Minus,
                    "NoSign" => num_bigint::Sign::NoSign,
                    "Plus" => num_bigint::Sign::Plus,
                    _ => {
                        return Err(serde::de::Error::custom("unsupported value, supported: Minus, NoSign, Plus"));
                    }
                }))
            }
        }
        serde::Deserializer::deserialize_newtype_struct(
            __deserializer,
            "NumBigintSign",
            __Visitor {
                marker: serde::__private::PhantomData::<Self>,
                lifetime: serde::__private::PhantomData,
            },
        )
    }
}


////////////
#[derive(Debug)]
pub struct StdPrimitiveI16AsNotNullInt2;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI16AsNotNullInt2Origin(std::primitive::i16);
impl StdPrimitiveI16AsNotNullInt2Origin {
    pub fn new(value: std::primitive::i16) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::i16) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for StdPrimitiveI16AsNotNullInt2Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI16AsNotNullInt2Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI16AsNotNullInt2Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI16AsNotNullInt2Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::primitive::i16 as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::primitive::i16 as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI16AsNotNullInt2Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveI16AsNotNullInt2Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::primitive::i16 as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for StdPrimitiveI16AsNotNullInt2Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i16 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl StdPrimitiveI16AsNotNullInt2Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int2 not null")
    }
}
pub type StdPrimitiveI16AsNotNullInt2TableTypeDeclaration = StdPrimitiveI16AsNotNullInt2Origin;
pub type StdPrimitiveI16AsNotNullInt2Create = StdPrimitiveI16AsNotNullInt2Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI16AsNotNullInt2Select;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI16AsNotNullInt2Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum StdPrimitiveI16AsNotNullInt2WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<StdPrimitiveI16AsNotNullInt2Origin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdPrimitiveI16AsNotNullInt2WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI16AsNotNullInt2WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI16AsNotNullInt2WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI16AsNotNullInt2Read(StdPrimitiveI16AsNotNullInt2Origin);
impl StdPrimitiveI16AsNotNullInt2Read {
    pub fn new(value: std::primitive::i16) -> Self {
        Self(StdPrimitiveI16AsNotNullInt2Origin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::i16) -> Self {
        Self(StdPrimitiveI16AsNotNullInt2Origin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI16AsNotNullInt2Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI16AsNotNullInt2Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI16AsNotNullInt2Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveI16AsNotNullInt2Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <StdPrimitiveI16AsNotNullInt2Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI16AsNotNullInt2Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <StdPrimitiveI16AsNotNullInt2Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <StdPrimitiveI16AsNotNullInt2Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type StdPrimitiveI16AsNotNullInt2ReadInner = std::primitive::i16;
pub type StdPrimitiveI16AsNotNullInt2Update = StdPrimitiveI16AsNotNullInt2Origin;
impl crate::PostgresqlType for StdPrimitiveI16AsNotNullInt2 {
    type TableTypeDeclaration = StdPrimitiveI16AsNotNullInt2TableTypeDeclaration;
    type Create = StdPrimitiveI16AsNotNullInt2Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = StdPrimitiveI16AsNotNullInt2Select;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = StdPrimitiveI16AsNotNullInt2WhereElement;
    type Read = StdPrimitiveI16AsNotNullInt2Read;
    type ReadInner = StdPrimitiveI16AsNotNullInt2ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = StdPrimitiveI16AsNotNullInt2Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![std::primitive::i16::MIN, -1, 0, 1, std::primitive::i16::MAX]
    }
}
#[derive(Debug)]
pub struct OptionStdPrimitiveI16AsNullableInt2;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveI16AsNullableInt2Origin(std::option::Option<StdPrimitiveI16AsNotNullInt2Origin>);
impl OptionStdPrimitiveI16AsNullableInt2Origin {
    pub fn new(value: std::option::Option<std::primitive::i16>) -> Self {
        Self(match value {
            Some(value) => Some(StdPrimitiveI16AsNotNullInt2Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::primitive::i16>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionStdPrimitiveI16AsNullableInt2Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveI16AsNullableInt2Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveI16AsNullableInt2Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI16AsNullableInt2Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<StdPrimitiveI16AsNotNullInt2Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<StdPrimitiveI16AsNotNullInt2Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI16AsNullableInt2Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdPrimitiveI16AsNullableInt2Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<StdPrimitiveI16AsNotNullInt2Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionStdPrimitiveI16AsNullableInt2Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i16 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionStdPrimitiveI16AsNullableInt2Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int2")
    }
}
pub type OptionStdPrimitiveI16AsNullableInt2TableTypeDeclaration = OptionStdPrimitiveI16AsNullableInt2Origin;
pub type OptionStdPrimitiveI16AsNullableInt2Create = OptionStdPrimitiveI16AsNullableInt2Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveI16AsNullableInt2Select;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveI16AsNullableInt2Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionStdPrimitiveI16AsNullableInt2WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionStdPrimitiveI16AsNullableInt2Origin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<OptionStdPrimitiveI16AsNullableInt2TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionStdPrimitiveI16AsNullableInt2WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveI16AsNullableInt2WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveI16AsNullableInt2WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveI16AsNullableInt2Read(OptionStdPrimitiveI16AsNullableInt2Origin);
impl OptionStdPrimitiveI16AsNullableInt2Read {
    pub fn new(value: std::option::Option<std::primitive::i16>) -> Self {
        Self(OptionStdPrimitiveI16AsNullableInt2Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveI16AsNullableInt2Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveI16AsNullableInt2Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI16AsNullableInt2Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdPrimitiveI16AsNullableInt2Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionStdPrimitiveI16AsNullableInt2Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI16AsNullableInt2Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionStdPrimitiveI16AsNullableInt2Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionStdPrimitiveI16AsNullableInt2Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionStdPrimitiveI16AsNullableInt2ReadInner = std::option::Option<std::primitive::i16>;
pub type OptionStdPrimitiveI16AsNullableInt2Update = OptionStdPrimitiveI16AsNullableInt2Origin;
impl crate::PostgresqlType for OptionStdPrimitiveI16AsNullableInt2 {
    type TableTypeDeclaration = OptionStdPrimitiveI16AsNullableInt2TableTypeDeclaration;
    type Create = OptionStdPrimitiveI16AsNullableInt2Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionStdPrimitiveI16AsNullableInt2Select;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionStdPrimitiveI16AsNullableInt2WhereElement;
    type Read = OptionStdPrimitiveI16AsNullableInt2Read;
    type ReadInner = OptionStdPrimitiveI16AsNullableInt2ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionStdPrimitiveI16AsNullableInt2Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveI16AsNotNullInt2 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<StdPrimitiveI16AsNotNullInt2 as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin(std::vec::Vec<StdPrimitiveI16AsNotNullInt2Origin>);
impl VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin {
    pub fn new(value: std::vec::Vec<std::primitive::i16>) -> Self {
        Self(value.into_iter().map(|element| StdPrimitiveI16AsNotNullInt2Origin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::primitive::i16>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<StdPrimitiveI16AsNotNullInt2Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<StdPrimitiveI16AsNotNullInt2Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<StdPrimitiveI16AsNotNullInt2Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i16 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int2[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2TableTypeDeclaration = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin;
pub type VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Create = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Read(VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin);
impl VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Read {
    pub fn new(value: std::vec::Vec<std::primitive::i16>) -> Self {
        Self(VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2ReadInner = std::vec::Vec<std::primitive::i16>;
pub type VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Update = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin;
impl crate::PostgresqlType for VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2 {
    type TableTypeDeclaration = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2TableTypeDeclaration;
    type Create = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2WhereElement;
    type Read = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Read;
    type ReadInner = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <StdPrimitiveI16AsNotNullInt2 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<StdPrimitiveI16AsNotNullInt2 as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin(std::option::Option<VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin>);
impl OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::i16>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::primitive::i16>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfStdPrimitiveI16AsNotNullArrayOfNotNullInt2Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i16 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int2[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2TableTypeDeclaration = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin;
pub type OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Create = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdPrimitiveI16AsNullableInt2TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<OptionStdPrimitiveI16AsNullableInt2TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Read(OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin);
impl OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Read {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::i16>>) -> Self {
        Self(OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2ReadInner = std::option::Option<std::vec::Vec<std::primitive::i16>>;
pub type OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Update = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Origin;
impl crate::PostgresqlType for OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2 {
    type TableTypeDeclaration = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2TableTypeDeclaration;
    type Create = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2WhereElement;
    type Read = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Read;
    type ReadInner = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfStdPrimitiveI16AsNullableArrayOfNotNullInt2Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveI16AsNotNullInt2 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<StdPrimitiveI16AsNotNullInt2 as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin(std::vec::Vec<OptionStdPrimitiveI16AsNullableInt2Origin>);
impl VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin {
    pub fn new(value: std::vec::Vec<std::option::Option<std::primitive::i16>>) -> Self {
        Self(value.into_iter().map(|element| OptionStdPrimitiveI16AsNullableInt2Origin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<std::primitive::i16>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionStdPrimitiveI16AsNullableInt2Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionStdPrimitiveI16AsNullableInt2Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionStdPrimitiveI16AsNullableInt2Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i16 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int2[] not null")
    }
}
pub type VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2TableTypeDeclaration = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin;
pub type VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Create = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Read(VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin);
impl VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Read {
    pub fn new(value: std::vec::Vec<std::option::Option<std::primitive::i16>>) -> Self {
        Self(VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2ReadInner = std::vec::Vec<std::option::Option<std::primitive::i16>>;
pub type VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Update = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin;
impl crate::PostgresqlType for VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2 {
    type TableTypeDeclaration = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2TableTypeDeclaration;
    type Create = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2WhereElement;
    type Read = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Read;
    type ReadInner = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveI16AsNotNullInt2 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<StdPrimitiveI16AsNotNullInt2 as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin(std::option::Option<VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin>);
impl OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::i16>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::i16>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionStdPrimitiveI16AsNotNullArrayOfNullableInt2Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i16 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int2[]")
    }
}
pub type OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2TableTypeDeclaration = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin;
pub type OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Create = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdPrimitiveI16AsNullableInt2TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveI16AsNotNullInt2TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<OptionStdPrimitiveI16AsNullableInt2TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Read(OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin);
impl OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Read {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::i16>>>) -> Self {
        Self(OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2ReadInner = std::option::Option<std::vec::Vec<std::option::Option<std::primitive::i16>>>;
pub type OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Update = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Origin;
impl crate::PostgresqlType for OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2 {
    type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2TableTypeDeclaration;
    type Create = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2WhereElement;
    type Read = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Read;
    type ReadInner = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionStdPrimitiveI16AsNullableArrayOfNullableInt2Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveI16AsNotNullInt2 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<StdPrimitiveI16AsNotNullInt2 as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct StdPrimitiveI32AsNotNullInt4;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI32AsNotNullInt4Origin(std::primitive::i32);
impl StdPrimitiveI32AsNotNullInt4Origin {
    pub fn new(value: std::primitive::i32) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::i32) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for StdPrimitiveI32AsNotNullInt4Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI32AsNotNullInt4Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI32AsNotNullInt4Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI32AsNotNullInt4Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::primitive::i32 as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::primitive::i32 as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI32AsNotNullInt4Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveI32AsNotNullInt4Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::primitive::i32 as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for StdPrimitiveI32AsNotNullInt4Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i32 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl StdPrimitiveI32AsNotNullInt4Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int4 not null")
    }
}
pub type StdPrimitiveI32AsNotNullInt4TableTypeDeclaration = StdPrimitiveI32AsNotNullInt4Origin;
pub type StdPrimitiveI32AsNotNullInt4Create = StdPrimitiveI32AsNotNullInt4Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI32AsNotNullInt4Select;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI32AsNotNullInt4Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum StdPrimitiveI32AsNotNullInt4WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<StdPrimitiveI32AsNotNullInt4Origin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdPrimitiveI32AsNotNullInt4WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI32AsNotNullInt4WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI32AsNotNullInt4WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI32AsNotNullInt4Read(StdPrimitiveI32AsNotNullInt4Origin);
impl StdPrimitiveI32AsNotNullInt4Read {
    pub fn new(value: std::primitive::i32) -> Self {
        Self(StdPrimitiveI32AsNotNullInt4Origin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::i32) -> Self {
        Self(StdPrimitiveI32AsNotNullInt4Origin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI32AsNotNullInt4Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI32AsNotNullInt4Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI32AsNotNullInt4Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveI32AsNotNullInt4Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <StdPrimitiveI32AsNotNullInt4Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI32AsNotNullInt4Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <StdPrimitiveI32AsNotNullInt4Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <StdPrimitiveI32AsNotNullInt4Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type StdPrimitiveI32AsNotNullInt4ReadInner = std::primitive::i32;
pub type StdPrimitiveI32AsNotNullInt4Update = StdPrimitiveI32AsNotNullInt4Origin;
impl crate::PostgresqlType for StdPrimitiveI32AsNotNullInt4 {
    type TableTypeDeclaration = StdPrimitiveI32AsNotNullInt4TableTypeDeclaration;
    type Create = StdPrimitiveI32AsNotNullInt4Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = StdPrimitiveI32AsNotNullInt4Select;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = StdPrimitiveI32AsNotNullInt4WhereElement;
    type Read = StdPrimitiveI32AsNotNullInt4Read;
    type ReadInner = StdPrimitiveI32AsNotNullInt4ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = StdPrimitiveI32AsNotNullInt4Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![std::primitive::i32::MIN, -1, 0, 1, std::primitive::i32::MAX]
    }
}
#[derive(Debug)]
pub struct OptionStdPrimitiveI32AsNullableInt4;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveI32AsNullableInt4Origin(std::option::Option<StdPrimitiveI32AsNotNullInt4Origin>);
impl OptionStdPrimitiveI32AsNullableInt4Origin {
    pub fn new(value: std::option::Option<std::primitive::i32>) -> Self {
        Self(match value {
            Some(value) => Some(StdPrimitiveI32AsNotNullInt4Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::primitive::i32>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionStdPrimitiveI32AsNullableInt4Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveI32AsNullableInt4Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveI32AsNullableInt4Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI32AsNullableInt4Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<StdPrimitiveI32AsNotNullInt4Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<StdPrimitiveI32AsNotNullInt4Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI32AsNullableInt4Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdPrimitiveI32AsNullableInt4Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<StdPrimitiveI32AsNotNullInt4Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionStdPrimitiveI32AsNullableInt4Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i32 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionStdPrimitiveI32AsNullableInt4Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int4")
    }
}
pub type OptionStdPrimitiveI32AsNullableInt4TableTypeDeclaration = OptionStdPrimitiveI32AsNullableInt4Origin;
pub type OptionStdPrimitiveI32AsNullableInt4Create = OptionStdPrimitiveI32AsNullableInt4Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveI32AsNullableInt4Select;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveI32AsNullableInt4Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionStdPrimitiveI32AsNullableInt4WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionStdPrimitiveI32AsNullableInt4Origin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<OptionStdPrimitiveI32AsNullableInt4TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionStdPrimitiveI32AsNullableInt4WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveI32AsNullableInt4WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveI32AsNullableInt4WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveI32AsNullableInt4Read(OptionStdPrimitiveI32AsNullableInt4Origin);
impl OptionStdPrimitiveI32AsNullableInt4Read {
    pub fn new(value: std::option::Option<std::primitive::i32>) -> Self {
        Self(OptionStdPrimitiveI32AsNullableInt4Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveI32AsNullableInt4Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveI32AsNullableInt4Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI32AsNullableInt4Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdPrimitiveI32AsNullableInt4Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionStdPrimitiveI32AsNullableInt4Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI32AsNullableInt4Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionStdPrimitiveI32AsNullableInt4Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionStdPrimitiveI32AsNullableInt4Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionStdPrimitiveI32AsNullableInt4ReadInner = std::option::Option<std::primitive::i32>;
pub type OptionStdPrimitiveI32AsNullableInt4Update = OptionStdPrimitiveI32AsNullableInt4Origin;
impl crate::PostgresqlType for OptionStdPrimitiveI32AsNullableInt4 {
    type TableTypeDeclaration = OptionStdPrimitiveI32AsNullableInt4TableTypeDeclaration;
    type Create = OptionStdPrimitiveI32AsNullableInt4Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionStdPrimitiveI32AsNullableInt4Select;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionStdPrimitiveI32AsNullableInt4WhereElement;
    type Read = OptionStdPrimitiveI32AsNullableInt4Read;
    type ReadInner = OptionStdPrimitiveI32AsNullableInt4ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionStdPrimitiveI32AsNullableInt4Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin(std::vec::Vec<StdPrimitiveI32AsNotNullInt4Origin>);
impl VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin {
    pub fn new(value: std::vec::Vec<std::primitive::i32>) -> Self {
        Self(value.into_iter().map(|element| StdPrimitiveI32AsNotNullInt4Origin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::primitive::i32>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<StdPrimitiveI32AsNotNullInt4Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<StdPrimitiveI32AsNotNullInt4Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<StdPrimitiveI32AsNotNullInt4Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i32 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int4[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4TableTypeDeclaration = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin;
pub type VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Create = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Read(VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin);
impl VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Read {
    pub fn new(value: std::vec::Vec<std::primitive::i32>) -> Self {
        Self(VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4ReadInner = std::vec::Vec<std::primitive::i32>;
pub type VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Update = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin;
impl crate::PostgresqlType for VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4 {
    type TableTypeDeclaration = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4TableTypeDeclaration;
    type Create = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4WhereElement;
    type Read = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Read;
    type ReadInner = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin(std::option::Option<VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin>);
impl OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::i32>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::primitive::i32>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfStdPrimitiveI32AsNotNullArrayOfNotNullInt4Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i32 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int4[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4TableTypeDeclaration = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin;
pub type OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Create = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdPrimitiveI32AsNullableInt4TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<OptionStdPrimitiveI32AsNullableInt4TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Read(OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin);
impl OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Read {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::i32>>) -> Self {
        Self(OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4ReadInner = std::option::Option<std::vec::Vec<std::primitive::i32>>;
pub type OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Update = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Origin;
impl crate::PostgresqlType for OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4 {
    type TableTypeDeclaration = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4TableTypeDeclaration;
    type Create = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4WhereElement;
    type Read = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Read;
    type ReadInner = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfStdPrimitiveI32AsNullableArrayOfNotNullInt4Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin(std::vec::Vec<OptionStdPrimitiveI32AsNullableInt4Origin>);
impl VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin {
    pub fn new(value: std::vec::Vec<std::option::Option<std::primitive::i32>>) -> Self {
        Self(value.into_iter().map(|element| OptionStdPrimitiveI32AsNullableInt4Origin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<std::primitive::i32>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionStdPrimitiveI32AsNullableInt4Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionStdPrimitiveI32AsNullableInt4Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionStdPrimitiveI32AsNullableInt4Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i32 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int4[] not null")
    }
}
pub type VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4TableTypeDeclaration = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin;
pub type VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Create = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Read(VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin);
impl VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Read {
    pub fn new(value: std::vec::Vec<std::option::Option<std::primitive::i32>>) -> Self {
        Self(VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4ReadInner = std::vec::Vec<std::option::Option<std::primitive::i32>>;
pub type VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Update = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin;
impl crate::PostgresqlType for VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4 {
    type TableTypeDeclaration = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4TableTypeDeclaration;
    type Create = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4WhereElement;
    type Read = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Read;
    type ReadInner = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin(std::option::Option<VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin>);
impl OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::i32>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::i32>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionStdPrimitiveI32AsNotNullArrayOfNullableInt4Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i32 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int4[]")
    }
}
pub type OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4TableTypeDeclaration = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin;
pub type OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Create = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdPrimitiveI32AsNullableInt4TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveI32AsNotNullInt4TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<OptionStdPrimitiveI32AsNullableInt4TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Read(OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin);
impl OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Read {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::i32>>>) -> Self {
        Self(OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4ReadInner = std::option::Option<std::vec::Vec<std::option::Option<std::primitive::i32>>>;
pub type OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Update = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Origin;
impl crate::PostgresqlType for OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4 {
    type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4TableTypeDeclaration;
    type Create = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4WhereElement;
    type Read = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Read;
    type ReadInner = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionStdPrimitiveI32AsNullableArrayOfNullableInt4Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct StdPrimitiveI64AsNotNullInt8;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI64AsNotNullInt8Origin(std::primitive::i64);
impl StdPrimitiveI64AsNotNullInt8Origin {
    pub fn new(value: std::primitive::i64) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::i64) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for StdPrimitiveI64AsNotNullInt8Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI64AsNotNullInt8Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI64AsNotNullInt8Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI64AsNotNullInt8Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::primitive::i64 as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::primitive::i64 as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI64AsNotNullInt8Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveI64AsNotNullInt8Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::primitive::i64 as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for StdPrimitiveI64AsNotNullInt8Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i64 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl StdPrimitiveI64AsNotNullInt8Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int8 not null")
    }
}
pub type StdPrimitiveI64AsNotNullInt8TableTypeDeclaration = StdPrimitiveI64AsNotNullInt8Origin;
pub type StdPrimitiveI64AsNotNullInt8Create = StdPrimitiveI64AsNotNullInt8Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI64AsNotNullInt8Select;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI64AsNotNullInt8Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum StdPrimitiveI64AsNotNullInt8WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<StdPrimitiveI64AsNotNullInt8Origin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdPrimitiveI64AsNotNullInt8WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI64AsNotNullInt8WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI64AsNotNullInt8WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI64AsNotNullInt8Read(StdPrimitiveI64AsNotNullInt8Origin);
impl StdPrimitiveI64AsNotNullInt8Read {
    pub fn new(value: std::primitive::i64) -> Self {
        Self(StdPrimitiveI64AsNotNullInt8Origin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::i64) -> Self {
        Self(StdPrimitiveI64AsNotNullInt8Origin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI64AsNotNullInt8Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI64AsNotNullInt8Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI64AsNotNullInt8Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveI64AsNotNullInt8Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <StdPrimitiveI64AsNotNullInt8Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI64AsNotNullInt8Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <StdPrimitiveI64AsNotNullInt8Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <StdPrimitiveI64AsNotNullInt8Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type StdPrimitiveI64AsNotNullInt8ReadInner = std::primitive::i64;
pub type StdPrimitiveI64AsNotNullInt8Update = StdPrimitiveI64AsNotNullInt8Origin;
impl crate::PostgresqlType for StdPrimitiveI64AsNotNullInt8 {
    type TableTypeDeclaration = StdPrimitiveI64AsNotNullInt8TableTypeDeclaration;
    type Create = StdPrimitiveI64AsNotNullInt8Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = StdPrimitiveI64AsNotNullInt8Select;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = StdPrimitiveI64AsNotNullInt8WhereElement;
    type Read = StdPrimitiveI64AsNotNullInt8Read;
    type ReadInner = StdPrimitiveI64AsNotNullInt8ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = StdPrimitiveI64AsNotNullInt8Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![std::primitive::i64::MIN, -1, 0, 1, std::primitive::i64::MAX]
    }
}
#[derive(Debug)]
pub struct OptionStdPrimitiveI64AsNullableInt8;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveI64AsNullableInt8Origin(std::option::Option<StdPrimitiveI64AsNotNullInt8Origin>);
impl OptionStdPrimitiveI64AsNullableInt8Origin {
    pub fn new(value: std::option::Option<std::primitive::i64>) -> Self {
        Self(match value {
            Some(value) => Some(StdPrimitiveI64AsNotNullInt8Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::primitive::i64>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionStdPrimitiveI64AsNullableInt8Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveI64AsNullableInt8Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveI64AsNullableInt8Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI64AsNullableInt8Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<StdPrimitiveI64AsNotNullInt8Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<StdPrimitiveI64AsNotNullInt8Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI64AsNullableInt8Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdPrimitiveI64AsNullableInt8Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<StdPrimitiveI64AsNotNullInt8Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionStdPrimitiveI64AsNullableInt8Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i64 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionStdPrimitiveI64AsNullableInt8Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int8")
    }
}
pub type OptionStdPrimitiveI64AsNullableInt8TableTypeDeclaration = OptionStdPrimitiveI64AsNullableInt8Origin;
pub type OptionStdPrimitiveI64AsNullableInt8Create = OptionStdPrimitiveI64AsNullableInt8Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveI64AsNullableInt8Select;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveI64AsNullableInt8Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionStdPrimitiveI64AsNullableInt8WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionStdPrimitiveI64AsNullableInt8Origin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<OptionStdPrimitiveI64AsNullableInt8TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionStdPrimitiveI64AsNullableInt8WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveI64AsNullableInt8WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveI64AsNullableInt8WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveI64AsNullableInt8Read(OptionStdPrimitiveI64AsNullableInt8Origin);
impl OptionStdPrimitiveI64AsNullableInt8Read {
    pub fn new(value: std::option::Option<std::primitive::i64>) -> Self {
        Self(OptionStdPrimitiveI64AsNullableInt8Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveI64AsNullableInt8Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveI64AsNullableInt8Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveI64AsNullableInt8Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdPrimitiveI64AsNullableInt8Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionStdPrimitiveI64AsNullableInt8Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveI64AsNullableInt8Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionStdPrimitiveI64AsNullableInt8Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionStdPrimitiveI64AsNullableInt8Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionStdPrimitiveI64AsNullableInt8ReadInner = std::option::Option<std::primitive::i64>;
pub type OptionStdPrimitiveI64AsNullableInt8Update = OptionStdPrimitiveI64AsNullableInt8Origin;
impl crate::PostgresqlType for OptionStdPrimitiveI64AsNullableInt8 {
    type TableTypeDeclaration = OptionStdPrimitiveI64AsNullableInt8TableTypeDeclaration;
    type Create = OptionStdPrimitiveI64AsNullableInt8Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionStdPrimitiveI64AsNullableInt8Select;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionStdPrimitiveI64AsNullableInt8WhereElement;
    type Read = OptionStdPrimitiveI64AsNullableInt8Read;
    type ReadInner = OptionStdPrimitiveI64AsNullableInt8ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionStdPrimitiveI64AsNullableInt8Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin(std::vec::Vec<StdPrimitiveI64AsNotNullInt8Origin>);
impl VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin {
    pub fn new(value: std::vec::Vec<std::primitive::i64>) -> Self {
        Self(value.into_iter().map(|element| StdPrimitiveI64AsNotNullInt8Origin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::primitive::i64>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<StdPrimitiveI64AsNotNullInt8Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<StdPrimitiveI64AsNotNullInt8Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<StdPrimitiveI64AsNotNullInt8Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i64 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int8[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8TableTypeDeclaration = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin;
pub type VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Create = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Read(VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin);
impl VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Read {
    pub fn new(value: std::vec::Vec<std::primitive::i64>) -> Self {
        Self(VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8ReadInner = std::vec::Vec<std::primitive::i64>;
pub type VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Update = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin;
impl crate::PostgresqlType for VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8 {
    type TableTypeDeclaration = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8TableTypeDeclaration;
    type Create = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8WhereElement;
    type Read = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Read;
    type ReadInner = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin(std::option::Option<VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin>);
impl OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::i64>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::primitive::i64>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfStdPrimitiveI64AsNotNullArrayOfNotNullInt8Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i64 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int8[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8TableTypeDeclaration = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin;
pub type OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Create = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdPrimitiveI64AsNullableInt8TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<OptionStdPrimitiveI64AsNullableInt8TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Read(OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin);
impl OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Read {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::i64>>) -> Self {
        Self(OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8ReadInner = std::option::Option<std::vec::Vec<std::primitive::i64>>;
pub type OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Update = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Origin;
impl crate::PostgresqlType for OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8 {
    type TableTypeDeclaration = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8TableTypeDeclaration;
    type Create = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8WhereElement;
    type Read = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Read;
    type ReadInner = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfStdPrimitiveI64AsNullableArrayOfNotNullInt8Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin(std::vec::Vec<OptionStdPrimitiveI64AsNullableInt8Origin>);
impl VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin {
    pub fn new(value: std::vec::Vec<std::option::Option<std::primitive::i64>>) -> Self {
        Self(value.into_iter().map(|element| OptionStdPrimitiveI64AsNullableInt8Origin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<std::primitive::i64>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionStdPrimitiveI64AsNullableInt8Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionStdPrimitiveI64AsNullableInt8Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionStdPrimitiveI64AsNullableInt8Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i64 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int8[] not null")
    }
}
pub type VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8TableTypeDeclaration = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin;
pub type VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Create = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Read(VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin);
impl VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Read {
    pub fn new(value: std::vec::Vec<std::option::Option<std::primitive::i64>>) -> Self {
        Self(VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8ReadInner = std::vec::Vec<std::option::Option<std::primitive::i64>>;
pub type VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Update = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin;
impl crate::PostgresqlType for VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8 {
    type TableTypeDeclaration = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8TableTypeDeclaration;
    type Create = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8WhereElement;
    type Read = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Read;
    type ReadInner = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin(std::option::Option<VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin>);
impl OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::i64>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::i64>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionStdPrimitiveI64AsNotNullArrayOfNullableInt8Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i64 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int8[]")
    }
}
pub type OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8TableTypeDeclaration = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin;
pub type OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Create = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdPrimitiveI64AsNullableInt8TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveI64AsNotNullInt8TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<OptionStdPrimitiveI64AsNullableInt8TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Read(OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin);
impl OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Read {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::i64>>>) -> Self {
        Self(OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8ReadInner = std::option::Option<std::vec::Vec<std::option::Option<std::primitive::i64>>>;
pub type OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Update = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Origin;
impl crate::PostgresqlType for OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8 {
    type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8TableTypeDeclaration;
    type Create = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8WhereElement;
    type Read = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Read;
    type ReadInner = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionStdPrimitiveI64AsNullableArrayOfNullableInt8Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct StdPrimitiveF32AsNotNullFloat4;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveF32AsNotNullFloat4Origin(std::primitive::f32);
impl StdPrimitiveF32AsNotNullFloat4Origin {
    pub fn new(value: std::primitive::f32) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::f32) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for StdPrimitiveF32AsNotNullFloat4Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveF32AsNotNullFloat4Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveF32AsNotNullFloat4Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF32AsNotNullFloat4Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::primitive::f32 as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::primitive::f32 as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF32AsNotNullFloat4Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveF32AsNotNullFloat4Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::primitive::f32 as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for StdPrimitiveF32AsNotNullFloat4Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::f32 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl StdPrimitiveF32AsNotNullFloat4Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} float4 not null")
    }
}
pub type StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration = StdPrimitiveF32AsNotNullFloat4Origin;
pub type StdPrimitiveF32AsNotNullFloat4Create = StdPrimitiveF32AsNotNullFloat4Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveF32AsNotNullFloat4Select;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveF32AsNotNullFloat4Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum StdPrimitiveF32AsNotNullFloat4WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<StdPrimitiveF32AsNotNullFloat4Origin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdPrimitiveF32AsNotNullFloat4WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveF32AsNotNullFloat4WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveF32AsNotNullFloat4WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveF32AsNotNullFloat4Read(StdPrimitiveF32AsNotNullFloat4Origin);
impl StdPrimitiveF32AsNotNullFloat4Read {
    pub fn new(value: std::primitive::f32) -> Self {
        Self(StdPrimitiveF32AsNotNullFloat4Origin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::f32) -> Self {
        Self(StdPrimitiveF32AsNotNullFloat4Origin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveF32AsNotNullFloat4Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveF32AsNotNullFloat4Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF32AsNotNullFloat4Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveF32AsNotNullFloat4Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <StdPrimitiveF32AsNotNullFloat4Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF32AsNotNullFloat4Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <StdPrimitiveF32AsNotNullFloat4Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <StdPrimitiveF32AsNotNullFloat4Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type StdPrimitiveF32AsNotNullFloat4ReadInner = std::primitive::f32;
pub type StdPrimitiveF32AsNotNullFloat4Update = StdPrimitiveF32AsNotNullFloat4Origin;
impl crate::PostgresqlType for StdPrimitiveF32AsNotNullFloat4 {
    type TableTypeDeclaration = StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration;
    type Create = StdPrimitiveF32AsNotNullFloat4Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = StdPrimitiveF32AsNotNullFloat4Select;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = StdPrimitiveF32AsNotNullFloat4WhereElement;
    type Read = StdPrimitiveF32AsNotNullFloat4Read;
    type ReadInner = StdPrimitiveF32AsNotNullFloat4ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = StdPrimitiveF32AsNotNullFloat4Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![
            std::primitive::f32::EPSILON,
            std::primitive::f32::MAX,
            std::primitive::f32::MIN,
            std::primitive::f32::MIN_POSITIVE,
            -1e30,
            -1e-30,
            -1.0,
            -0.0,
            0.0,
            1.0,
            3.1415,
            -3.1415,
            1e-30,
            1e30,
        ]
    }
}
#[derive(Debug)]
pub struct OptionStdPrimitiveF32AsNullableFloat4;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveF32AsNullableFloat4Origin(std::option::Option<StdPrimitiveF32AsNotNullFloat4Origin>);
impl OptionStdPrimitiveF32AsNullableFloat4Origin {
    pub fn new(value: std::option::Option<std::primitive::f32>) -> Self {
        Self(match value {
            Some(value) => Some(StdPrimitiveF32AsNotNullFloat4Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::primitive::f32>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionStdPrimitiveF32AsNullableFloat4Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveF32AsNullableFloat4Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveF32AsNullableFloat4Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF32AsNullableFloat4Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<StdPrimitiveF32AsNotNullFloat4Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<StdPrimitiveF32AsNotNullFloat4Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveF32AsNullableFloat4Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdPrimitiveF32AsNullableFloat4Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<StdPrimitiveF32AsNotNullFloat4Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionStdPrimitiveF32AsNullableFloat4Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::f32 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionStdPrimitiveF32AsNullableFloat4Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} float4")
    }
}
pub type OptionStdPrimitiveF32AsNullableFloat4TableTypeDeclaration = OptionStdPrimitiveF32AsNullableFloat4Origin;
pub type OptionStdPrimitiveF32AsNullableFloat4Create = OptionStdPrimitiveF32AsNullableFloat4Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveF32AsNullableFloat4Select;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveF32AsNullableFloat4Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionStdPrimitiveF32AsNullableFloat4WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionStdPrimitiveF32AsNullableFloat4Origin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<OptionStdPrimitiveF32AsNullableFloat4TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionStdPrimitiveF32AsNullableFloat4WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveF32AsNullableFloat4WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveF32AsNullableFloat4WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveF32AsNullableFloat4Read(OptionStdPrimitiveF32AsNullableFloat4Origin);
impl OptionStdPrimitiveF32AsNullableFloat4Read {
    pub fn new(value: std::option::Option<std::primitive::f32>) -> Self {
        Self(OptionStdPrimitiveF32AsNullableFloat4Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveF32AsNullableFloat4Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveF32AsNullableFloat4Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveF32AsNullableFloat4Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdPrimitiveF32AsNullableFloat4Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionStdPrimitiveF32AsNullableFloat4Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF32AsNullableFloat4Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionStdPrimitiveF32AsNullableFloat4Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionStdPrimitiveF32AsNullableFloat4Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionStdPrimitiveF32AsNullableFloat4ReadInner = std::option::Option<std::primitive::f32>;
pub type OptionStdPrimitiveF32AsNullableFloat4Update = OptionStdPrimitiveF32AsNullableFloat4Origin;
impl crate::PostgresqlType for OptionStdPrimitiveF32AsNullableFloat4 {
    type TableTypeDeclaration = OptionStdPrimitiveF32AsNullableFloat4TableTypeDeclaration;
    type Create = OptionStdPrimitiveF32AsNullableFloat4Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionStdPrimitiveF32AsNullableFloat4Select;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionStdPrimitiveF32AsNullableFloat4WhereElement;
    type Read = OptionStdPrimitiveF32AsNullableFloat4Read;
    type ReadInner = OptionStdPrimitiveF32AsNullableFloat4ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionStdPrimitiveF32AsNullableFloat4Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveF32AsNotNullFloat4 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<StdPrimitiveF32AsNotNullFloat4 as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin(std::vec::Vec<StdPrimitiveF32AsNotNullFloat4Origin>);
impl VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin {
    pub fn new(value: std::vec::Vec<std::primitive::f32>) -> Self {
        Self(value.into_iter().map(|element| StdPrimitiveF32AsNotNullFloat4Origin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::primitive::f32>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<StdPrimitiveF32AsNotNullFloat4Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<StdPrimitiveF32AsNotNullFloat4Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<StdPrimitiveF32AsNotNullFloat4Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::f32 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} float4[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4TableTypeDeclaration = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin;
pub type VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Create = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Read(VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin);
impl VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Read {
    pub fn new(value: std::vec::Vec<std::primitive::f32>) -> Self {
        Self(VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4ReadInner = std::vec::Vec<std::primitive::f32>;
pub type VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Update = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin;
impl crate::PostgresqlType for VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4 {
    type TableTypeDeclaration = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4TableTypeDeclaration;
    type Create = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4WhereElement;
    type Read = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Read;
    type ReadInner = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <StdPrimitiveF32AsNotNullFloat4 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<StdPrimitiveF32AsNotNullFloat4 as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin(std::option::Option<VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin>);
impl OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::f32>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::primitive::f32>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfStdPrimitiveF32AsNotNullArrayOfNotNullFloat4Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::f32 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} float4[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4TableTypeDeclaration = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin;
pub type OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Create = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdPrimitiveF32AsNullableFloat4TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<OptionStdPrimitiveF32AsNullableFloat4TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Read(OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin);
impl OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Read {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::f32>>) -> Self {
        Self(OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4ReadInner = std::option::Option<std::vec::Vec<std::primitive::f32>>;
pub type OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Update = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Origin;
impl crate::PostgresqlType for OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4 {
    type TableTypeDeclaration = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4TableTypeDeclaration;
    type Create = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4WhereElement;
    type Read = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Read;
    type ReadInner = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfStdPrimitiveF32AsNullableArrayOfNotNullFloat4Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveF32AsNotNullFloat4 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<StdPrimitiveF32AsNotNullFloat4 as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin(std::vec::Vec<OptionStdPrimitiveF32AsNullableFloat4Origin>);
impl VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin {
    pub fn new(value: std::vec::Vec<std::option::Option<std::primitive::f32>>) -> Self {
        Self(value.into_iter().map(|element| OptionStdPrimitiveF32AsNullableFloat4Origin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<std::primitive::f32>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionStdPrimitiveF32AsNullableFloat4Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionStdPrimitiveF32AsNullableFloat4Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionStdPrimitiveF32AsNullableFloat4Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::f32 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} float4[] not null")
    }
}
pub type VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4TableTypeDeclaration = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin;
pub type VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Create = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Read(VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin);
impl VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Read {
    pub fn new(value: std::vec::Vec<std::option::Option<std::primitive::f32>>) -> Self {
        Self(VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4ReadInner = std::vec::Vec<std::option::Option<std::primitive::f32>>;
pub type VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Update = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin;
impl crate::PostgresqlType for VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4 {
    type TableTypeDeclaration = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4TableTypeDeclaration;
    type Create = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4WhereElement;
    type Read = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Read;
    type ReadInner = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveF32AsNotNullFloat4 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<StdPrimitiveF32AsNotNullFloat4 as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin(std::option::Option<VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin>);
impl OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::f32>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::f32>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionStdPrimitiveF32AsNotNullArrayOfNullableFloat4Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::f32 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} float4[]")
    }
}
pub type OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4TableTypeDeclaration = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin;
pub type OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Create = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdPrimitiveF32AsNullableFloat4TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveF32AsNotNullFloat4TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<OptionStdPrimitiveF32AsNullableFloat4TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Read(OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin);
impl OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Read {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::f32>>>) -> Self {
        Self(OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4ReadInner = std::option::Option<std::vec::Vec<std::option::Option<std::primitive::f32>>>;
pub type OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Update = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Origin;
impl crate::PostgresqlType for OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4 {
    type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4TableTypeDeclaration;
    type Create = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4WhereElement;
    type Read = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Read;
    type ReadInner = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionStdPrimitiveF32AsNullableArrayOfNullableFloat4Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveF32AsNotNullFloat4 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<StdPrimitiveF32AsNotNullFloat4 as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct StdPrimitiveF64AsNotNullFloat8;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveF64AsNotNullFloat8Origin(std::primitive::f64);
impl StdPrimitiveF64AsNotNullFloat8Origin {
    pub fn new(value: std::primitive::f64) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::f64) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for StdPrimitiveF64AsNotNullFloat8Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveF64AsNotNullFloat8Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveF64AsNotNullFloat8Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF64AsNotNullFloat8Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::primitive::f64 as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::primitive::f64 as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF64AsNotNullFloat8Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveF64AsNotNullFloat8Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::primitive::f64 as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for StdPrimitiveF64AsNotNullFloat8Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::f64 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl StdPrimitiveF64AsNotNullFloat8Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} float8 not null")
    }
}
pub type StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration = StdPrimitiveF64AsNotNullFloat8Origin;
pub type StdPrimitiveF64AsNotNullFloat8Create = StdPrimitiveF64AsNotNullFloat8Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveF64AsNotNullFloat8Select;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveF64AsNotNullFloat8Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum StdPrimitiveF64AsNotNullFloat8WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<StdPrimitiveF64AsNotNullFloat8Origin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdPrimitiveF64AsNotNullFloat8WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveF64AsNotNullFloat8WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveF64AsNotNullFloat8WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveF64AsNotNullFloat8Read(StdPrimitiveF64AsNotNullFloat8Origin);
impl StdPrimitiveF64AsNotNullFloat8Read {
    pub fn new(value: std::primitive::f64) -> Self {
        Self(StdPrimitiveF64AsNotNullFloat8Origin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::f64) -> Self {
        Self(StdPrimitiveF64AsNotNullFloat8Origin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveF64AsNotNullFloat8Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveF64AsNotNullFloat8Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveF64AsNotNullFloat8Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveF64AsNotNullFloat8Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <StdPrimitiveF64AsNotNullFloat8Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveF64AsNotNullFloat8Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <StdPrimitiveF64AsNotNullFloat8Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <StdPrimitiveF64AsNotNullFloat8Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type StdPrimitiveF64AsNotNullFloat8ReadInner = std::primitive::f64;
pub type StdPrimitiveF64AsNotNullFloat8Update = StdPrimitiveF64AsNotNullFloat8Origin;
impl crate::PostgresqlType for StdPrimitiveF64AsNotNullFloat8 {
    type TableTypeDeclaration = StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration;
    type Create = StdPrimitiveF64AsNotNullFloat8Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = StdPrimitiveF64AsNotNullFloat8Select;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = StdPrimitiveF64AsNotNullFloat8WhereElement;
    type Read = StdPrimitiveF64AsNotNullFloat8Read;
    type ReadInner = StdPrimitiveF64AsNotNullFloat8ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = StdPrimitiveF64AsNotNullFloat8Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![std::primitive::f64::MAX, std::primitive::f64::MIN, std::primitive::f64::MIN_POSITIVE, -1e300, -1e-300, -1.0, -0.0, 0.0, 1.0, 1e-300, 1e300]
    }
}
#[derive(Debug)]
pub struct OptionStdPrimitiveF64AsNullableFloat8;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveF64AsNullableFloat8Origin(std::option::Option<StdPrimitiveF64AsNotNullFloat8Origin>);
impl OptionStdPrimitiveF64AsNullableFloat8Origin {
    pub fn new(value: std::option::Option<std::primitive::f64>) -> Self {
        Self(match value {
            Some(value) => Some(StdPrimitiveF64AsNotNullFloat8Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::primitive::f64>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionStdPrimitiveF64AsNullableFloat8Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveF64AsNullableFloat8Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveF64AsNullableFloat8Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF64AsNullableFloat8Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<StdPrimitiveF64AsNotNullFloat8Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<StdPrimitiveF64AsNotNullFloat8Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveF64AsNullableFloat8Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdPrimitiveF64AsNullableFloat8Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<StdPrimitiveF64AsNotNullFloat8Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionStdPrimitiveF64AsNullableFloat8Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::f64 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionStdPrimitiveF64AsNullableFloat8Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} float8")
    }
}
pub type OptionStdPrimitiveF64AsNullableFloat8TableTypeDeclaration = OptionStdPrimitiveF64AsNullableFloat8Origin;
pub type OptionStdPrimitiveF64AsNullableFloat8Create = OptionStdPrimitiveF64AsNullableFloat8Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveF64AsNullableFloat8Select;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveF64AsNullableFloat8Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionStdPrimitiveF64AsNullableFloat8WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionStdPrimitiveF64AsNullableFloat8Origin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<OptionStdPrimitiveF64AsNullableFloat8TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionStdPrimitiveF64AsNullableFloat8WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveF64AsNullableFloat8WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveF64AsNullableFloat8WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveF64AsNullableFloat8Read(OptionStdPrimitiveF64AsNullableFloat8Origin);
impl OptionStdPrimitiveF64AsNullableFloat8Read {
    pub fn new(value: std::option::Option<std::primitive::f64>) -> Self {
        Self(OptionStdPrimitiveF64AsNullableFloat8Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveF64AsNullableFloat8Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveF64AsNullableFloat8Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveF64AsNullableFloat8Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdPrimitiveF64AsNullableFloat8Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionStdPrimitiveF64AsNullableFloat8Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveF64AsNullableFloat8Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionStdPrimitiveF64AsNullableFloat8Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionStdPrimitiveF64AsNullableFloat8Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionStdPrimitiveF64AsNullableFloat8ReadInner = std::option::Option<std::primitive::f64>;
pub type OptionStdPrimitiveF64AsNullableFloat8Update = OptionStdPrimitiveF64AsNullableFloat8Origin;
impl crate::PostgresqlType for OptionStdPrimitiveF64AsNullableFloat8 {
    type TableTypeDeclaration = OptionStdPrimitiveF64AsNullableFloat8TableTypeDeclaration;
    type Create = OptionStdPrimitiveF64AsNullableFloat8Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionStdPrimitiveF64AsNullableFloat8Select;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionStdPrimitiveF64AsNullableFloat8WhereElement;
    type Read = OptionStdPrimitiveF64AsNullableFloat8Read;
    type ReadInner = OptionStdPrimitiveF64AsNullableFloat8ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionStdPrimitiveF64AsNullableFloat8Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveF64AsNotNullFloat8 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<StdPrimitiveF64AsNotNullFloat8 as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin(std::vec::Vec<StdPrimitiveF64AsNotNullFloat8Origin>);
impl VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin {
    pub fn new(value: std::vec::Vec<std::primitive::f64>) -> Self {
        Self(value.into_iter().map(|element| StdPrimitiveF64AsNotNullFloat8Origin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::primitive::f64>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<StdPrimitiveF64AsNotNullFloat8Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<StdPrimitiveF64AsNotNullFloat8Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<StdPrimitiveF64AsNotNullFloat8Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::f64 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} float8[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8TableTypeDeclaration = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin;
pub type VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Create = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Read(VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin);
impl VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Read {
    pub fn new(value: std::vec::Vec<std::primitive::f64>) -> Self {
        Self(VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8ReadInner = std::vec::Vec<std::primitive::f64>;
pub type VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Update = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin;
impl crate::PostgresqlType for VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8 {
    type TableTypeDeclaration = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8TableTypeDeclaration;
    type Create = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8WhereElement;
    type Read = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Read;
    type ReadInner = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <StdPrimitiveF64AsNotNullFloat8 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<StdPrimitiveF64AsNotNullFloat8 as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin(std::option::Option<VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin>);
impl OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::f64>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::primitive::f64>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfStdPrimitiveF64AsNotNullArrayOfNotNullFloat8Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::f64 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} float8[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8TableTypeDeclaration = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin;
pub type OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Create = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdPrimitiveF64AsNullableFloat8TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<OptionStdPrimitiveF64AsNullableFloat8TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Read(OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin);
impl OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Read {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::f64>>) -> Self {
        Self(OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8ReadInner = std::option::Option<std::vec::Vec<std::primitive::f64>>;
pub type OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Update = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Origin;
impl crate::PostgresqlType for OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8 {
    type TableTypeDeclaration = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8TableTypeDeclaration;
    type Create = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8WhereElement;
    type Read = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Read;
    type ReadInner = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfStdPrimitiveF64AsNullableArrayOfNotNullFloat8Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveF64AsNotNullFloat8 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<StdPrimitiveF64AsNotNullFloat8 as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin(std::vec::Vec<OptionStdPrimitiveF64AsNullableFloat8Origin>);
impl VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin {
    pub fn new(value: std::vec::Vec<std::option::Option<std::primitive::f64>>) -> Self {
        Self(value.into_iter().map(|element| OptionStdPrimitiveF64AsNullableFloat8Origin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<std::primitive::f64>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionStdPrimitiveF64AsNullableFloat8Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionStdPrimitiveF64AsNullableFloat8Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionStdPrimitiveF64AsNullableFloat8Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::f64 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} float8[] not null")
    }
}
pub type VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8TableTypeDeclaration = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin;
pub type VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Create = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Read(VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin);
impl VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Read {
    pub fn new(value: std::vec::Vec<std::option::Option<std::primitive::f64>>) -> Self {
        Self(VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8ReadInner = std::vec::Vec<std::option::Option<std::primitive::f64>>;
pub type VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Update = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin;
impl crate::PostgresqlType for VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8 {
    type TableTypeDeclaration = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8TableTypeDeclaration;
    type Create = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8WhereElement;
    type Read = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Read;
    type ReadInner = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveF64AsNotNullFloat8 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<StdPrimitiveF64AsNotNullFloat8 as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin(std::option::Option<VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin>);
impl OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::f64>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::f64>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionStdPrimitiveF64AsNotNullArrayOfNullableFloat8Origin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::f64 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} float8[]")
    }
}
pub type OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8TableTypeDeclaration = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin;
pub type OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Create = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Select {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Select {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8WhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdPrimitiveF64AsNullableFloat8TableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<StdPrimitiveF64AsNotNullFloat8TableTypeDeclaration>),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<OptionStdPrimitiveF64AsNullableFloat8TableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8WhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8WhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8WhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Read(OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin);
impl OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Read {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::f64>>>) -> Self {
        Self(OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Read {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Read {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Read {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Read {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Read {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8ReadInner = std::option::Option<std::vec::Vec<std::option::Option<std::primitive::f64>>>;
pub type OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Update = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Origin;
impl crate::PostgresqlType for OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8 {
    type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8TableTypeDeclaration;
    type Create = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Create;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Select;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8WhereElement;
    type Read = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Read;
    type ReadInner = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8ReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionStdPrimitiveF64AsNullableArrayOfNullableFloat8Update;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveF64AsNotNullFloat8 as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<StdPrimitiveF64AsNotNullFloat8 as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresql;
#[derive(Debug, Clone, PartialEq, PartialOrd, Ord, Eq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin(std::primitive::i16);
impl StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin {
    pub fn new(value: std::primitive::i16) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::i16) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::primitive::i16 as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::primitive::i16 as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::primitive::i16 as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i16 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, is_primary_key: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} smallserial not null {}", crate::maybe_primary_key(is_primary_key))
    }
}
impl std::convert::From<StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlRead> for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin {
    fn from(value: StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlRead) -> Self {
        Self::new(<StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresql as crate::PostgresqlType>::into_inner(value))
    }
}
pub type StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlTableTypeDeclaration = StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlCreate(());
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlCreate {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlTableTypeDeclaration>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, PartialOrd, Ord, Eq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlRead(StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin);
impl StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlRead {
    pub fn new(value: std::primitive::i16) -> Self {
        Self(StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::i16) -> Self {
        Self(StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlRead {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, _: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                Ok(format!("({} = ${})", column, increment))
            }
            None => Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() }),
        }
    }
    fn query_bind(self, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(self);
        query
    }
}
impl crate::PostgresqlTypePrimaryKey for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresql {
    type PrimaryKey = StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlRead;
}
pub type StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlReadInner = std::primitive::i16;
pub type StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlUpdate = StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlOrigin;
impl crate::PostgresqlType for StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresql {
    type TableTypeDeclaration = StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlTableTypeDeclaration;
    type Create = StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlCreate;
    fn create_query_part(_: &Self::Create, _: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        Ok(std::string::String::from("default"))
    }
    fn create_query_bind(_: Self::Create, query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query
    }
    type Select = StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlWhereElement;
    type Read = StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlRead;
    type ReadInner = StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = StdPrimitiveI16AsNotNullSmallSerialInitializedByPostgresqlUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct StdPrimitiveI32AsNotNullSerialInitializedByPostgresql;
#[derive(Debug, Clone, PartialEq, PartialOrd, Ord, Eq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin(std::primitive::i32);
impl StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin {
    pub fn new(value: std::primitive::i32) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::i32) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::primitive::i32 as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::primitive::i32 as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::primitive::i32 as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i32 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, is_primary_key: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} serial not null {}", crate::maybe_primary_key(is_primary_key))
    }
}
impl std::convert::From<StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlRead> for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin {
    fn from(value: StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlRead) -> Self {
        Self::new(<StdPrimitiveI32AsNotNullSerialInitializedByPostgresql as crate::PostgresqlType>::into_inner(value))
    }
}
pub type StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlTableTypeDeclaration = StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlCreate(());
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlCreate {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlTableTypeDeclaration>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, PartialOrd, Ord, Eq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlRead(StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin);
impl StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlRead {
    pub fn new(value: std::primitive::i32) -> Self {
        Self(StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::i32) -> Self {
        Self(StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlRead {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, _: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                Ok(format!("({} = ${})", column, increment))
            }
            None => Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() }),
        }
    }
    fn query_bind(self, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(self);
        query
    }
}
impl crate::PostgresqlTypePrimaryKey for StdPrimitiveI32AsNotNullSerialInitializedByPostgresql {
    type PrimaryKey = StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlRead;
}
pub type StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlReadInner = std::primitive::i32;
pub type StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlUpdate = StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlOrigin;
impl crate::PostgresqlType for StdPrimitiveI32AsNotNullSerialInitializedByPostgresql {
    type TableTypeDeclaration = StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlTableTypeDeclaration;
    type Create = StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlCreate;
    fn create_query_part(_: &Self::Create, _: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        Ok(std::string::String::from("default"))
    }
    fn create_query_bind(_: Self::Create, query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query
    }
    type Select = StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlWhereElement;
    type Read = StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlRead;
    type ReadInner = StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = StdPrimitiveI32AsNotNullSerialInitializedByPostgresqlUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresql;
#[derive(Debug, Clone, PartialEq, PartialOrd, Ord, Eq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin(std::primitive::i64);
impl StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin {
    pub fn new(value: std::primitive::i64) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::i64) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::primitive::i64 as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::primitive::i64 as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::primitive::i64 as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::i64 as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, is_primary_key: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} bigserial not null {}", crate::maybe_primary_key(is_primary_key))
    }
}
impl std::convert::From<StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlRead> for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin {
    fn from(value: StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlRead) -> Self {
        Self::new(<StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresql as crate::PostgresqlType>::into_inner(value))
    }
}
pub type StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlTableTypeDeclaration = StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlCreate(());
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlCreate {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlTableTypeDeclaration>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, PartialOrd, Ord, Eq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlRead(StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin);
impl StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlRead {
    pub fn new(value: std::primitive::i64) -> Self {
        Self(StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::i64) -> Self {
        Self(StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlRead {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, _: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                Ok(format!("({} = ${})", column, increment))
            }
            None => Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() }),
        }
    }
    fn query_bind(self, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(self);
        query
    }
}
impl crate::PostgresqlTypePrimaryKey for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresql {
    type PrimaryKey = StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlRead;
}
pub type StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlReadInner = std::primitive::i64;
pub type StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlUpdate = StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlOrigin;
impl crate::PostgresqlType for StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresql {
    type TableTypeDeclaration = StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlTableTypeDeclaration;
    type Create = StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlCreate;
    fn create_query_part(_: &Self::Create, _: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        Ok(std::string::String::from("default"))
    }
    fn create_query_bind(_: Self::Create, query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query
    }
    type Select = StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlWhereElement;
    type Read = StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlRead;
    type ReadInner = StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = StdPrimitiveI64AsNotNullBigSerialInitializedByPostgresqlUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct SqlxPostgresTypesPgMoneyAsNotNullMoney;
#[derive(Debug, Clone, PartialEq)]
pub struct SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin(sqlx::postgres::types::PgMoney);
impl SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin {
    pub fn new(value: sqlx::postgres::types::PgMoney) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgMoney) -> Self {
        Self::new(value)
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            _serde::Serializer::serialize_newtype_struct(__serializer, "SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin", &self.0.0)
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: serde::__private::PhantomData<SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin>,
                lifetime: serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin")
                }
                #[inline]
                fn visit_newtype_struct<__E>(self, __e: __E) -> serde::__private::Result<Self::Value, __E::Error>
                where
                    __E: serde::Deserializer<'de>,
                {
                    let __field0 = <std::primitive::i64 as serde::Deserialize>::deserialize(__e)?;
                    serde::__private::Ok(SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin(sqlx::postgres::types::PgMoney(__field0)))
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = match serde::de::SeqAccess::next_element::<std::primitive::i64>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin with 1 elements"));
                        }
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin(sqlx::postgres::types::PgMoney(__field0)))
                }
            }
            _serde::Deserializer::deserialize_newtype_struct(
                __deserializer,
                "SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin",
                __Visitor {
                    marker: serde::__private::PhantomData::<SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin>,
                    lifetime: serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::postgres::types::PgMoney(::core::default::Default::default()))
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::postgres::types::PgMoney as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::postgres::types::PgMoney as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::postgres::types::PgMoney as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgMoney as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} money not null")
    }
}
pub type SqlxPostgresTypesPgMoneyAsNotNullMoneyTableTypeDeclaration = SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin;
pub type SqlxPostgresTypesPgMoneyAsNotNullMoneyCreate = SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgMoneyAsNotNullMoneySelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgMoneyAsNotNullMoneySelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxPostgresTypesPgMoneyAsNotNullMoneyWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<SqlxPostgresTypesPgMoneyAsNotNullMoneyTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxPostgresTypesPgMoneyAsNotNullMoneyWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgMoneyAsNotNullMoneyWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgMoneyAsNotNullMoneyWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgMoneyAsNotNullMoneyRead(SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin);
impl SqlxPostgresTypesPgMoneyAsNotNullMoneyRead {
    pub fn new(value: sqlx::postgres::types::PgMoney) -> Self {
        Self(SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgMoney) -> Self {
        Self(SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgMoneyAsNotNullMoneyRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgMoneyAsNotNullMoneyRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgMoneyAsNotNullMoneyRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgMoneyAsNotNullMoneyRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgMoneyAsNotNullMoneyRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxPostgresTypesPgMoneyAsNotNullMoneyReadInner = sqlx::postgres::types::PgMoney;
pub type SqlxPostgresTypesPgMoneyAsNotNullMoneyUpdate = SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin;
impl crate::PostgresqlType for SqlxPostgresTypesPgMoneyAsNotNullMoney {
    type TableTypeDeclaration = SqlxPostgresTypesPgMoneyAsNotNullMoneyTableTypeDeclaration;
    type Create = SqlxPostgresTypesPgMoneyAsNotNullMoneyCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxPostgresTypesPgMoneyAsNotNullMoneySelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxPostgresTypesPgMoneyAsNotNullMoneyWhereElement;
    type Read = SqlxPostgresTypesPgMoneyAsNotNullMoneyRead;
    type ReadInner = SqlxPostgresTypesPgMoneyAsNotNullMoneyReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxPostgresTypesPgMoneyAsNotNullMoneyUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![
            sqlx::postgres::types::PgMoney(std::primitive::i64::MIN),
            sqlx::postgres::types::PgMoney(-1),
            sqlx::postgres::types::PgMoney(0),
            sqlx::postgres::types::PgMoney(1),
            sqlx::postgres::types::PgMoney(std::primitive::i64::MAX),
        ]
    }
}
#[derive(Debug)]
pub struct OptionSqlxPostgresTypesPgMoneyAsNullableMoney;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin(std::option::Option<SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin>);
impl OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgMoney>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::postgres::types::PgMoney>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgMoney as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} money")
    }
}
pub type OptionSqlxPostgresTypesPgMoneyAsNullableMoneyTableTypeDeclaration = OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin;
pub type OptionSqlxPostgresTypesPgMoneyAsNullableMoneyCreate = OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgMoneyAsNullableMoneySelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgMoneyAsNullableMoneySelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxPostgresTypesPgMoneyAsNullableMoneyWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin>),
    In(crate::where_element_filters::PostgresqlTypeWhereElementIn<OptionSqlxPostgresTypesPgMoneyAsNullableMoneyTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::In(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::In(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgMoneyAsNullableMoneyRead(OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin);
impl OptionSqlxPostgresTypesPgMoneyAsNullableMoneyRead {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgMoney>) -> Self {
        Self(OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgMoneyAsNullableMoneyRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxPostgresTypesPgMoneyAsNullableMoneyReadInner = std::option::Option<sqlx::postgres::types::PgMoney>;
pub type OptionSqlxPostgresTypesPgMoneyAsNullableMoneyUpdate = OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin;
impl crate::PostgresqlType for OptionSqlxPostgresTypesPgMoneyAsNullableMoney {
    type TableTypeDeclaration = OptionSqlxPostgresTypesPgMoneyAsNullableMoneyTableTypeDeclaration;
    type Create = OptionSqlxPostgresTypesPgMoneyAsNullableMoneyCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxPostgresTypesPgMoneyAsNullableMoneySelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxPostgresTypesPgMoneyAsNullableMoneyWhereElement;
    type Read = OptionSqlxPostgresTypesPgMoneyAsNullableMoneyRead;
    type ReadInner = OptionSqlxPostgresTypesPgMoneyAsNullableMoneyReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxPostgresTypesPgMoneyAsNullableMoneyUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgMoneyAsNotNullMoney as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgMoneyAsNotNullMoney as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoney;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin(std::vec::Vec<SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin>);
impl VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgMoney>) -> Self {
        Self(value.into_iter().map(|element| SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::postgres::types::PgMoney>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxPostgresTypesPgMoneyAsNotNullMoneyOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgMoney as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} money[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyTableTypeDeclaration = VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin;
pub type VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyCreate = VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneySelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneySelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgMoneyAsNotNullMoneyTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<SqlxPostgresTypesPgMoneyAsNotNullMoneyTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyRead(VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin);
impl VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyRead {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgMoney>) -> Self {
        Self(VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyReadInner = std::vec::Vec<sqlx::postgres::types::PgMoney>;
pub type VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyUpdate = VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin;
impl crate::PostgresqlType for VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoney {
    type TableTypeDeclaration = VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyTableTypeDeclaration;
    type Create = VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneySelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyWhereElement;
    type Read = VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyRead;
    type ReadInner = VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxPostgresTypesPgMoneyAsNotNullMoney as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxPostgresTypesPgMoneyAsNotNullMoney as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoney;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin(std::option::Option<VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin>);
impl OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgMoney>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgMoney>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxPostgresTypesPgMoneyAsNotNullArrayOfNotNullMoneyOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgMoney as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} money[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyTableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin;
pub type OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyCreate = OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneySelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneySelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgMoneyAsNullableMoneyTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<OptionSqlxPostgresTypesPgMoneyAsNullableMoneyTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyRead(OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin);
impl OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgMoney>>) -> Self {
        Self(OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyReadInner = std::option::Option<std::vec::Vec<sqlx::postgres::types::PgMoney>>;
pub type OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyUpdate = OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoney {
    type TableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyTableTypeDeclaration;
    type Create = OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneySelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyWhereElement;
    type Read = OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyRead;
    type ReadInner = OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxPostgresTypesPgMoneyAsNullableArrayOfNotNullMoneyUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgMoneyAsNotNullMoney as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxPostgresTypesPgMoneyAsNotNullMoney as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoney;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin(std::vec::Vec<OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin>);
impl VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgMoney>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgMoney>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxPostgresTypesPgMoneyAsNullableMoneyOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgMoney as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} money[] not null")
    }
}
pub type VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyTableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin;
pub type VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyCreate = VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneySelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneySelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgMoneyAsNotNullMoneyTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<SqlxPostgresTypesPgMoneyAsNotNullMoneyTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyRead(VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin);
impl VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgMoney>>) -> Self {
        Self(VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyReadInner = std::vec::Vec<std::option::Option<sqlx::postgres::types::PgMoney>>;
pub type VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyUpdate = VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoney {
    type TableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyTableTypeDeclaration;
    type Create = VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneySelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyWhereElement;
    type Read = VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyRead;
    type ReadInner = VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgMoneyAsNotNullMoney as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgMoneyAsNotNullMoney as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoney;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin(std::option::Option<VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin>);
impl OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgMoney>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgMoney>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxPostgresTypesPgMoneyAsNotNullArrayOfNullableMoneyOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgMoney as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} money[]")
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyTableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin;
pub type OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyCreate = OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneySelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneySelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgMoneyAsNullableMoneyTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneIn(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIn<OptionSqlxPostgresTypesPgMoneyAsNullableMoneyTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIn(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIn(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyRead(OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin);
impl OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgMoney>>>) -> Self {
        Self(OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgMoney>>>;
pub type OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyUpdate = OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoney {
    type TableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneySelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyWhereElement;
    type Read = OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyRead;
    type ReadInner = OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxPostgresTypesPgMoneyAsNullableArrayOfNullableMoneyUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgMoneyAsNotNullMoney as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgMoneyAsNotNullMoney as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxTypesBigDecimalAsNotNullNumeric;
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct SqlxTypesBigDecimalAsNotNullNumericOrigin(sqlx::types::BigDecimal);
impl SqlxTypesBigDecimalAsNotNullNumericOrigin {
    pub fn new(value: sqlx::types::BigDecimal) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::BigDecimal) -> Self {
        Self::new(value)
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxTypesBigDecimalAsNotNullNumericOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let (bigint, exponent) = self.0.clone().into_bigint_and_exponent();
            let mut __serde_state = _serde::Serializer::serialize_struct(__serializer, "SqlxTypesBigDecimalAsNotNullNumericOrigin", false as std::primitive::usize + 1 + 1)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "digits", &crate::postgresql_type::NumBigintBigInt(bigint))?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "scale", &exponent)?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxTypesBigDecimalAsNotNullNumericOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        0u64 => serde::__private::Ok(__Field::__field0),
                        1u64 => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(self, __value: &str) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "digits" => _serde::__private::Ok(__Field::__field0),
                        "scale" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(self, __value: &[u8]) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        b"digits" => serde::__private::Ok(__Field::__field0),
                        b"scale" => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: serde::__private::PhantomData<SqlxTypesBigDecimalAsNotNullNumericOrigin>,
                lifetime: serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SqlxTypesBigDecimalAsNotNullNumericOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxTypesBigDecimalAsNotNullNumericOrigin")
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = match serde::de::SeqAccess::next_element::<crate::postgresql_type::NumBigintBigInt>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxTypesBigDecimalAsNotNullNumericOrigin with 2 elements"));
                        }
                    };
                    let __field1 = match serde::de::SeqAccess::next_element::<std::primitive::i64>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(1usize, &"struct SqlxTypesBigDecimalAsNotNullNumericOrigin with 2 elements"));
                        }
                    };
                    serde::__private::Ok(SqlxTypesBigDecimalAsNotNullNumericOrigin(sqlx::types::BigDecimal::new(__field0.0, __field1)))
                }
                #[inline]
                fn visit_map<__A>(self, mut __map: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::MapAccess<'de>,
                {
                    let mut __field0: serde::__private::Option<crate::postgresql_type::NumBigintBigInt> = serde::__private::None;
                    let mut __field1: serde::__private::Option<std::primitive::i64> = serde::__private::None;
                    while let serde::__private::Some(__key) = serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if serde::__private::Option::is_some(&__field0) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"digits\""));
                                }
                                __field0 = serde::__private::Some(serde::de::MapAccess::next_value::<crate::postgresql_type::NumBigintBigInt>(&mut __map)?);
                            }
                            __Field::__field1 => {
                                if serde::__private::Option::is_some(&__field1) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"scale\""));
                                }
                                __field1 = serde::__private::Some(serde::de::MapAccess::next_value::<std::primitive::i64>(&mut __map)?);
                            }
                            _ => {
                                let _ = serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        serde::__private::Some(__field0) => __field0,
                        serde::__private::None => serde::__private::de::missing_field("\"digits\"")?,
                    };
                    let __field1 = match __field1 {
                        serde::__private::Some(__field1) => __field1,
                        serde::__private::None => serde::__private::de::missing_field("\"scale\"")?,
                    };
                    serde::__private::Ok(SqlxTypesBigDecimalAsNotNullNumericOrigin(sqlx::types::BigDecimal::new(__field0.0, __field1)))
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["digits", "scale"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "SqlxTypesBigDecimalAsNotNullNumeric",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<SqlxTypesBigDecimalAsNotNullNumericOrigin>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for SqlxTypesBigDecimalAsNotNullNumericOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesBigDecimalAsNotNullNumericOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesBigDecimalAsNotNullNumericOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesBigDecimalAsNotNullNumericOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::types::BigDecimal as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::types::BigDecimal as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesBigDecimalAsNotNullNumericOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesBigDecimalAsNotNullNumericOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::types::BigDecimal as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxTypesBigDecimalAsNotNullNumericOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::BigDecimal as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxTypesBigDecimalAsNotNullNumericOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} numeric not null")
    }
}
pub type SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration = SqlxTypesBigDecimalAsNotNullNumericOrigin;
pub type SqlxTypesBigDecimalAsNotNullNumericCreate = SqlxTypesBigDecimalAsNotNullNumericOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesBigDecimalAsNotNullNumericSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesBigDecimalAsNotNullNumericSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxTypesBigDecimalAsNotNullNumericWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxTypesBigDecimalAsNotNullNumericOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesBigDecimalAsNotNullNumericWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesBigDecimalAsNotNullNumericWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesBigDecimalAsNotNullNumericWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesBigDecimalAsNotNullNumericRead(SqlxTypesBigDecimalAsNotNullNumericOrigin);
impl SqlxTypesBigDecimalAsNotNullNumericRead {
    pub fn new(value: sqlx::types::BigDecimal) -> Self {
        Self(SqlxTypesBigDecimalAsNotNullNumericOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::BigDecimal) -> Self {
        Self(SqlxTypesBigDecimalAsNotNullNumericOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesBigDecimalAsNotNullNumericRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesBigDecimalAsNotNullNumericRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesBigDecimalAsNotNullNumericRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesBigDecimalAsNotNullNumericRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxTypesBigDecimalAsNotNullNumericOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesBigDecimalAsNotNullNumericRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxTypesBigDecimalAsNotNullNumericOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxTypesBigDecimalAsNotNullNumericOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxTypesBigDecimalAsNotNullNumericReadInner = sqlx::types::BigDecimal;
pub type SqlxTypesBigDecimalAsNotNullNumericUpdate = SqlxTypesBigDecimalAsNotNullNumericOrigin;
impl crate::PostgresqlType for SqlxTypesBigDecimalAsNotNullNumeric {
    type TableTypeDeclaration = SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration;
    type Create = SqlxTypesBigDecimalAsNotNullNumericCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxTypesBigDecimalAsNotNullNumericSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxTypesBigDecimalAsNotNullNumericWhereElement;
    type Read = SqlxTypesBigDecimalAsNotNullNumericRead;
    type ReadInner = SqlxTypesBigDecimalAsNotNullNumericReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxTypesBigDecimalAsNotNullNumericUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![
            sqlx::types::BigDecimal::from(0),
            sqlx::types::BigDecimal::from(1),
            sqlx::types::BigDecimal::from(-1),
            sqlx::types::BigDecimal::from(1000),
            sqlx::types::BigDecimal::from(-1000),
            <sqlx::types::BigDecimal as std::str::FromStr>::from_str("0.00000001").unwrap(),
            <sqlx::types::BigDecimal as std::str::FromStr>::from_str("-0.00000001").unwrap(),
            <sqlx::types::BigDecimal as std::str::FromStr>::from_str("12345678901234567890.123456789").unwrap(),
            <sqlx::types::BigDecimal as std::str::FromStr>::from_str("-98765432109876543210.987654321").unwrap(),
            <sqlx::types::BigDecimal as std::str::FromStr>::from_str("1.000000000000000000").unwrap(),
            <sqlx::types::BigDecimal as std::str::FromStr>::from_str("1e-100").unwrap(),
            <sqlx::types::BigDecimal as std::str::FromStr>::from_str("1e100").unwrap(),
        ]
    }
}
#[derive(Debug)]
pub struct OptionSqlxTypesBigDecimalAsNullableNumeric;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesBigDecimalAsNullableNumericOrigin(std::option::Option<SqlxTypesBigDecimalAsNotNullNumericOrigin>);
impl OptionSqlxTypesBigDecimalAsNullableNumericOrigin {
    pub fn new(value: std::option::Option<sqlx::types::BigDecimal>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxTypesBigDecimalAsNotNullNumericOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::types::BigDecimal>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxTypesBigDecimalAsNullableNumericOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesBigDecimalAsNullableNumericOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesBigDecimalAsNullableNumericOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesBigDecimalAsNullableNumericOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxTypesBigDecimalAsNotNullNumericOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxTypesBigDecimalAsNotNullNumericOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesBigDecimalAsNullableNumericOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesBigDecimalAsNullableNumericOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxTypesBigDecimalAsNotNullNumericOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxTypesBigDecimalAsNullableNumericOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::BigDecimal as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxTypesBigDecimalAsNullableNumericOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} numeric")
    }
}
pub type OptionSqlxTypesBigDecimalAsNullableNumericTableTypeDeclaration = OptionSqlxTypesBigDecimalAsNullableNumericOrigin;
pub type OptionSqlxTypesBigDecimalAsNullableNumericCreate = OptionSqlxTypesBigDecimalAsNullableNumericOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesBigDecimalAsNullableNumericSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesBigDecimalAsNullableNumericSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxTypesBigDecimalAsNullableNumericWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxTypesBigDecimalAsNullableNumericOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxTypesBigDecimalAsNullableNumericWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesBigDecimalAsNullableNumericWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesBigDecimalAsNullableNumericWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesBigDecimalAsNullableNumericRead(OptionSqlxTypesBigDecimalAsNullableNumericOrigin);
impl OptionSqlxTypesBigDecimalAsNullableNumericRead {
    pub fn new(value: std::option::Option<sqlx::types::BigDecimal>) -> Self {
        Self(OptionSqlxTypesBigDecimalAsNullableNumericOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesBigDecimalAsNullableNumericRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesBigDecimalAsNullableNumericRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesBigDecimalAsNullableNumericRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesBigDecimalAsNullableNumericRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxTypesBigDecimalAsNullableNumericOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesBigDecimalAsNullableNumericRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxTypesBigDecimalAsNullableNumericOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxTypesBigDecimalAsNullableNumericOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxTypesBigDecimalAsNullableNumericReadInner = std::option::Option<sqlx::types::BigDecimal>;
pub type OptionSqlxTypesBigDecimalAsNullableNumericUpdate = OptionSqlxTypesBigDecimalAsNullableNumericOrigin;
impl crate::PostgresqlType for OptionSqlxTypesBigDecimalAsNullableNumeric {
    type TableTypeDeclaration = OptionSqlxTypesBigDecimalAsNullableNumericTableTypeDeclaration;
    type Create = OptionSqlxTypesBigDecimalAsNullableNumericCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxTypesBigDecimalAsNullableNumericSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxTypesBigDecimalAsNullableNumericWhereElement;
    type Read = OptionSqlxTypesBigDecimalAsNullableNumericRead;
    type ReadInner = OptionSqlxTypesBigDecimalAsNullableNumericReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxTypesBigDecimalAsNullableNumericUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumeric;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin(std::vec::Vec<SqlxTypesBigDecimalAsNotNullNumericOrigin>);
impl VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin {
    pub fn new(value: std::vec::Vec<sqlx::types::BigDecimal>) -> Self {
        Self(value.into_iter().map(|element| SqlxTypesBigDecimalAsNotNullNumericOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::types::BigDecimal>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxTypesBigDecimalAsNotNullNumericOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxTypesBigDecimalAsNotNullNumericOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxTypesBigDecimalAsNotNullNumericOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::BigDecimal as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} numeric[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericTableTypeDeclaration = VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin;
pub type VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericCreate = VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericRead(VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin);
impl VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericRead {
    pub fn new(value: std::vec::Vec<sqlx::types::BigDecimal>) -> Self {
        Self(VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericReadInner = std::vec::Vec<sqlx::types::BigDecimal>;
pub type VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericUpdate = VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin;
impl crate::PostgresqlType for VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumeric {
    type TableTypeDeclaration = VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericTableTypeDeclaration;
    type Create = VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericWhereElement;
    type Read = VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericRead;
    type ReadInner = VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumeric;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin(std::option::Option<VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin>);
impl OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::BigDecimal>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::types::BigDecimal>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumericOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::BigDecimal as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} numeric[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericTableTypeDeclaration = OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin;
pub type OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericCreate = OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesBigDecimalAsNullableNumericTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericRead(OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin);
impl OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::BigDecimal>>) -> Self {
        Self(OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericReadInner = std::option::Option<std::vec::Vec<sqlx::types::BigDecimal>>;
pub type OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericUpdate = OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumeric {
    type TableTypeDeclaration = OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericTableTypeDeclaration;
    type Create = OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericWhereElement;
    type Read = OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericRead;
    type ReadInner = OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxTypesBigDecimalAsNullableArrayOfNotNullNumericUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumeric;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin(std::vec::Vec<OptionSqlxTypesBigDecimalAsNullableNumericOrigin>);
impl VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::BigDecimal>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxTypesBigDecimalAsNullableNumericOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::types::BigDecimal>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxTypesBigDecimalAsNullableNumericOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxTypesBigDecimalAsNullableNumericOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxTypesBigDecimalAsNullableNumericOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::BigDecimal as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} numeric[] not null")
    }
}
pub type VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericTableTypeDeclaration = VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin;
pub type VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericCreate = VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericRead(VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin);
impl VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::BigDecimal>>) -> Self {
        Self(VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericReadInner = std::vec::Vec<std::option::Option<sqlx::types::BigDecimal>>;
pub type VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericUpdate = VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumeric {
    type TableTypeDeclaration = VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericTableTypeDeclaration;
    type Create = VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericWhereElement;
    type Read = VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericRead;
    type ReadInner = VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumeric;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin(std::option::Option<VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin>);
impl OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::BigDecimal>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::BigDecimal>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxTypesBigDecimalAsNotNullArrayOfNullableNumericOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::BigDecimal as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} numeric[]")
    }
}
pub type OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericTableTypeDeclaration = OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin;
pub type OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericCreate = OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesBigDecimalAsNullableNumericTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesBigDecimalAsNotNullNumericTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericRead(OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin);
impl OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::BigDecimal>>>) -> Self {
        Self(OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::BigDecimal>>>;
pub type OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericUpdate = OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumeric {
    type TableTypeDeclaration = OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericWhereElement;
    type Read = OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericRead;
    type ReadInner = OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxTypesBigDecimalAsNullableArrayOfNullableNumericUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct StdPrimitiveBoolAsNotNullBool;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveBoolAsNotNullBoolOrigin(std::primitive::bool);
impl StdPrimitiveBoolAsNotNullBoolOrigin {
    pub fn new(value: std::primitive::bool) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::bool) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for StdPrimitiveBoolAsNotNullBoolOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveBoolAsNotNullBoolOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveBoolAsNotNullBoolOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveBoolAsNotNullBoolOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::primitive::bool as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::primitive::bool as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveBoolAsNotNullBoolOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveBoolAsNotNullBoolOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::primitive::bool as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for StdPrimitiveBoolAsNotNullBoolOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::bool as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl StdPrimitiveBoolAsNotNullBoolOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} bool not null")
    }
}
pub type StdPrimitiveBoolAsNotNullBoolTableTypeDeclaration = StdPrimitiveBoolAsNotNullBoolOrigin;
pub type StdPrimitiveBoolAsNotNullBoolCreate = StdPrimitiveBoolAsNotNullBoolOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveBoolAsNotNullBoolSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveBoolAsNotNullBoolSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum StdPrimitiveBoolAsNotNullBoolWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<StdPrimitiveBoolAsNotNullBoolOrigin>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdPrimitiveBoolAsNotNullBoolWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveBoolAsNotNullBoolWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveBoolAsNotNullBoolWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdPrimitiveBoolAsNotNullBoolRead(StdPrimitiveBoolAsNotNullBoolOrigin);
impl StdPrimitiveBoolAsNotNullBoolRead {
    pub fn new(value: std::primitive::bool) -> Self {
        Self(StdPrimitiveBoolAsNotNullBoolOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::primitive::bool) -> Self {
        Self(StdPrimitiveBoolAsNotNullBoolOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for StdPrimitiveBoolAsNotNullBoolRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdPrimitiveBoolAsNotNullBoolRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdPrimitiveBoolAsNotNullBoolRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdPrimitiveBoolAsNotNullBoolRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <StdPrimitiveBoolAsNotNullBoolOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for StdPrimitiveBoolAsNotNullBoolRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <StdPrimitiveBoolAsNotNullBoolOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <StdPrimitiveBoolAsNotNullBoolOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type StdPrimitiveBoolAsNotNullBoolReadInner = std::primitive::bool;
pub type StdPrimitiveBoolAsNotNullBoolUpdate = StdPrimitiveBoolAsNotNullBoolOrigin;
impl crate::PostgresqlType for StdPrimitiveBoolAsNotNullBool {
    type TableTypeDeclaration = StdPrimitiveBoolAsNotNullBoolTableTypeDeclaration;
    type Create = StdPrimitiveBoolAsNotNullBoolCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = StdPrimitiveBoolAsNotNullBoolSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = StdPrimitiveBoolAsNotNullBoolWhereElement;
    type Read = StdPrimitiveBoolAsNotNullBoolRead;
    type ReadInner = StdPrimitiveBoolAsNotNullBoolReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = StdPrimitiveBoolAsNotNullBoolUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![true, false]
    }
}
#[derive(Debug)]
pub struct OptionStdPrimitiveBoolAsNullableBool;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveBoolAsNullableBoolOrigin(std::option::Option<StdPrimitiveBoolAsNotNullBoolOrigin>);
impl OptionStdPrimitiveBoolAsNullableBoolOrigin {
    pub fn new(value: std::option::Option<std::primitive::bool>) -> Self {
        Self(match value {
            Some(value) => Some(StdPrimitiveBoolAsNotNullBoolOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::primitive::bool>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionStdPrimitiveBoolAsNullableBoolOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveBoolAsNullableBoolOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveBoolAsNullableBoolOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveBoolAsNullableBoolOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<StdPrimitiveBoolAsNotNullBoolOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<StdPrimitiveBoolAsNotNullBoolOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveBoolAsNullableBoolOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdPrimitiveBoolAsNullableBoolOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<StdPrimitiveBoolAsNotNullBoolOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionStdPrimitiveBoolAsNullableBoolOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::bool as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionStdPrimitiveBoolAsNullableBoolOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} bool")
    }
}
pub type OptionStdPrimitiveBoolAsNullableBoolTableTypeDeclaration = OptionStdPrimitiveBoolAsNullableBoolOrigin;
pub type OptionStdPrimitiveBoolAsNullableBoolCreate = OptionStdPrimitiveBoolAsNullableBoolOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveBoolAsNullableBoolSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveBoolAsNullableBoolSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionStdPrimitiveBoolAsNullableBoolWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionStdPrimitiveBoolAsNullableBoolOrigin>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionStdPrimitiveBoolAsNullableBoolWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveBoolAsNullableBoolWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveBoolAsNullableBoolWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdPrimitiveBoolAsNullableBoolRead(OptionStdPrimitiveBoolAsNullableBoolOrigin);
impl OptionStdPrimitiveBoolAsNullableBoolRead {
    pub fn new(value: std::option::Option<std::primitive::bool>) -> Self {
        Self(OptionStdPrimitiveBoolAsNullableBoolOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdPrimitiveBoolAsNullableBoolRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdPrimitiveBoolAsNullableBoolRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdPrimitiveBoolAsNullableBoolRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdPrimitiveBoolAsNullableBoolRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionStdPrimitiveBoolAsNullableBoolOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdPrimitiveBoolAsNullableBoolRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionStdPrimitiveBoolAsNullableBoolOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionStdPrimitiveBoolAsNullableBoolOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionStdPrimitiveBoolAsNullableBoolReadInner = std::option::Option<std::primitive::bool>;
pub type OptionStdPrimitiveBoolAsNullableBoolUpdate = OptionStdPrimitiveBoolAsNullableBoolOrigin;
impl crate::PostgresqlType for OptionStdPrimitiveBoolAsNullableBool {
    type TableTypeDeclaration = OptionStdPrimitiveBoolAsNullableBoolTableTypeDeclaration;
    type Create = OptionStdPrimitiveBoolAsNullableBoolCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionStdPrimitiveBoolAsNullableBoolSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionStdPrimitiveBoolAsNullableBoolWhereElement;
    type Read = OptionStdPrimitiveBoolAsNullableBoolRead;
    type ReadInner = OptionStdPrimitiveBoolAsNullableBoolReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionStdPrimitiveBoolAsNullableBoolUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveBoolAsNotNullBool as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<StdPrimitiveBoolAsNotNullBool as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBool;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin(std::vec::Vec<StdPrimitiveBoolAsNotNullBoolOrigin>);
impl VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin {
    pub fn new(value: std::vec::Vec<std::primitive::bool>) -> Self {
        Self(value.into_iter().map(|element| StdPrimitiveBoolAsNotNullBoolOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::primitive::bool>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<StdPrimitiveBoolAsNotNullBoolOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<StdPrimitiveBoolAsNotNullBoolOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<StdPrimitiveBoolAsNotNullBoolOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::bool as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} bool[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolTableTypeDeclaration = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin;
pub type VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolCreate = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdPrimitiveBoolAsNotNullBoolTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolRead(VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin);
impl VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolRead {
    pub fn new(value: std::vec::Vec<std::primitive::bool>) -> Self {
        Self(VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolReadInner = std::vec::Vec<std::primitive::bool>;
pub type VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolUpdate = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin;
impl crate::PostgresqlType for VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBool {
    type TableTypeDeclaration = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolTableTypeDeclaration;
    type Create = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolWhereElement;
    type Read = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolRead;
    type ReadInner = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <StdPrimitiveBoolAsNotNullBool as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<StdPrimitiveBoolAsNotNullBool as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBool;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin(std::option::Option<VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin>);
impl OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::bool>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::primitive::bool>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfStdPrimitiveBoolAsNotNullArrayOfNotNullBoolOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::bool as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} bool[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolTableTypeDeclaration = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin;
pub type OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolCreate = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdPrimitiveBoolAsNullableBoolTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolRead(OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin);
impl OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::bool>>) -> Self {
        Self(OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolReadInner = std::option::Option<std::vec::Vec<std::primitive::bool>>;
pub type OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolUpdate = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolOrigin;
impl crate::PostgresqlType for OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBool {
    type TableTypeDeclaration = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolTableTypeDeclaration;
    type Create = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolWhereElement;
    type Read = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolRead;
    type ReadInner = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfStdPrimitiveBoolAsNullableArrayOfNotNullBoolUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveBoolAsNotNullBool as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<StdPrimitiveBoolAsNotNullBool as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBool;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin(std::vec::Vec<OptionStdPrimitiveBoolAsNullableBoolOrigin>);
impl VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<std::primitive::bool>>) -> Self {
        Self(value.into_iter().map(|element| OptionStdPrimitiveBoolAsNullableBoolOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<std::primitive::bool>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionStdPrimitiveBoolAsNullableBoolOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionStdPrimitiveBoolAsNullableBoolOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionStdPrimitiveBoolAsNullableBoolOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::bool as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} bool[] not null")
    }
}
pub type VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolTableTypeDeclaration = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin;
pub type VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolCreate = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdPrimitiveBoolAsNotNullBoolTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolRead(VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin);
impl VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolRead {
    pub fn new(value: std::vec::Vec<std::option::Option<std::primitive::bool>>) -> Self {
        Self(VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolReadInner = std::vec::Vec<std::option::Option<std::primitive::bool>>;
pub type VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolUpdate = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin;
impl crate::PostgresqlType for VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBool {
    type TableTypeDeclaration = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolTableTypeDeclaration;
    type Create = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolWhereElement;
    type Read = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolRead;
    type ReadInner = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveBoolAsNotNullBool as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<StdPrimitiveBoolAsNotNullBool as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBool;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin(std::option::Option<VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin>);
impl OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::bool>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::bool>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionStdPrimitiveBoolAsNotNullArrayOfNullableBoolOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::primitive::bool as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} bool[]")
    }
}
pub type OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolTableTypeDeclaration = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin;
pub type OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolCreate = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdPrimitiveBoolAsNullableBoolTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolRead(OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin);
impl OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::primitive::bool>>>) -> Self {
        Self(OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolReadInner = std::option::Option<std::vec::Vec<std::option::Option<std::primitive::bool>>>;
pub type OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolUpdate = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolOrigin;
impl crate::PostgresqlType for OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBool {
    type TableTypeDeclaration = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolTableTypeDeclaration;
    type Create = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolWhereElement;
    type Read = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolRead;
    type ReadInner = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionStdPrimitiveBoolAsNullableArrayOfNullableBoolUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdPrimitiveBoolAsNotNullBool as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<StdPrimitiveBoolAsNotNullBool as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct StdStringStringAsNotNullText;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize)]
pub struct StdStringStringAsNotNullTextOrigin(std::string::String);
#[derive(Debug, serde :: Serialize, serde :: Deserialize, thiserror :: Error, error_occurence_lib :: ErrorOccurence)]
pub enum StdStringStringAsNotNullTextOriginTryNewErrorNamed {
    ContainsNullByte {
        #[eo_to_std_string_string_serialize_deserialize]
        value: std::string::String,
        code_occurence: error_occurence_lib::code_occurence::CodeOccurence,
    },
}
impl StdStringStringAsNotNullTextOrigin {
    pub fn try_new(value: std::string::String) -> Result<Self, StdStringStringAsNotNullTextOriginTryNewErrorNamed> {
        if value.find('\0').is_some() {
            Err(StdStringStringAsNotNullTextOriginTryNewErrorNamed::ContainsNullByte {
                value,
                code_occurence: error_occurence_lib::code_occurence!(),
            })
        } else {
            Ok(Self(value))
        }
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::string::String) -> Self {
        Self::try_new(value).unwrap()
    }
}
impl crate::IsStringEmpty for StdStringStringAsNotNullTextOrigin {
    fn is_string_empty(&self) -> std::primitive::bool {
        self.0.to_string().is_empty()
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for StdStringStringAsNotNullTextOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<StdStringStringAsNotNullTextOrigin>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = StdStringStringAsNotNullTextOrigin;
                fn expecting(&self, __formatter: &mut _serde::__private::Formatter<'_>) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "tuple struct StdStringStringAsNotNullTextOrigin")
                }
                #[inline]
                fn visit_newtype_struct<__E>(self, __e: __E) -> _serde::__private::Result<Self::Value, __E::Error>
                where
                    __E: _serde::Deserializer<'de>,
                {
                    let __field0: std::string::String = <std::string::String as _serde::Deserialize>::deserialize(__e)?;
                    match StdStringStringAsNotNullTextOrigin::try_new(__field0) {
                        Ok(value) => _serde::__private::Ok(value),
                        Err(error) => Err(_serde::de::Error::custom(format!("{error:?}"))),
                    }
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<std::string::String>(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize, &"tuple struct StdStringStringAsNotNullTextOrigin with 1 element"));
                        }
                    };
                    match StdStringStringAsNotNullTextOrigin::try_new(__field0) {
                        Ok(value) => _serde::__private::Ok(value),
                        Err(error) => Err(_serde::de::Error::custom(format!("{error:?}"))),
                    }
                }
            }
            _serde::Deserializer::deserialize_newtype_struct(
                __deserializer,
                "StdStringStringAsNotNullTextOrigin",
                __Visitor {
                    marker: _serde::__private::PhantomData::<StdStringStringAsNotNullTextOrigin>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for StdStringStringAsNotNullTextOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for StdStringStringAsNotNullTextOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdStringStringAsNotNullTextOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for StdStringStringAsNotNullTextOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::string::String as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::string::String as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdStringStringAsNotNullTextOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdStringStringAsNotNullTextOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::string::String as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for StdStringStringAsNotNullTextOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::string::String as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl StdStringStringAsNotNullTextOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} text not null")
    }
}
pub type StdStringStringAsNotNullTextTableTypeDeclaration = StdStringStringAsNotNullTextOrigin;
pub type StdStringStringAsNotNullTextCreate = StdStringStringAsNotNullTextOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdStringStringAsNotNullTextSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdStringStringAsNotNullTextSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum StdStringStringAsNotNullTextWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<StdStringStringAsNotNullTextOrigin>),
    RegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdStringStringAsNotNullTextWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for StdStringStringAsNotNullTextWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdStringStringAsNotNullTextWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdStringStringAsNotNullTextRead(StdStringStringAsNotNullTextOrigin);
impl StdStringStringAsNotNullTextRead {
    pub fn try_new(value: std::string::String) -> Result<Self, StdStringStringAsNotNullTextOriginTryNewErrorNamed> {
        match StdStringStringAsNotNullTextOrigin::try_new(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::string::String) -> Self {
        Self(StdStringStringAsNotNullTextOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for StdStringStringAsNotNullTextRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdStringStringAsNotNullTextRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdStringStringAsNotNullTextRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdStringStringAsNotNullTextRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <StdStringStringAsNotNullTextOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for StdStringStringAsNotNullTextRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <StdStringStringAsNotNullTextOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <StdStringStringAsNotNullTextOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type StdStringStringAsNotNullTextReadInner = std::string::String;
pub type StdStringStringAsNotNullTextUpdate = StdStringStringAsNotNullTextOrigin;
impl crate::PostgresqlType for StdStringStringAsNotNullText {
    type TableTypeDeclaration = StdStringStringAsNotNullTextTableTypeDeclaration;
    type Create = StdStringStringAsNotNullTextCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = StdStringStringAsNotNullTextSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = StdStringStringAsNotNullTextWhereElement;
    type Read = StdStringStringAsNotNullTextRead;
    type ReadInner = StdStringStringAsNotNullTextReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = StdStringStringAsNotNullTextUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![
            "".to_string(),
            "a".to_string(),
            "Hello, world!".to_string(),
            "   ".to_string(),
            "\n\r\t".to_string(),
            "1234567890".to_string(),
            "".to_string(),
            "".to_string(),
            " Rust ".to_string(),
            "a".repeat(1024),
            "line1\nline2\nline3".to_string(),
            String::from_utf8_lossy(&[0xF0, 0x9F, 0x92, 0x96]).to_string(),
        ]
    }
}
#[derive(Debug)]
pub struct OptionStdStringStringAsNullableText;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdStringStringAsNullableTextOrigin(std::option::Option<StdStringStringAsNotNullTextOrigin>);
impl OptionStdStringStringAsNullableTextOrigin {
    pub fn new(value: std::option::Option<std::string::String>) -> Self {
        Self(match value {
            Some(value) => Some(StdStringStringAsNotNullTextOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::string::String>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionStdStringStringAsNullableTextOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdStringStringAsNullableTextOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdStringStringAsNullableTextOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdStringStringAsNullableTextOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<StdStringStringAsNotNullTextOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<StdStringStringAsNotNullTextOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdStringStringAsNullableTextOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdStringStringAsNullableTextOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<StdStringStringAsNotNullTextOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionStdStringStringAsNullableTextOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::string::String as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionStdStringStringAsNullableTextOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} text")
    }
}
pub type OptionStdStringStringAsNullableTextTableTypeDeclaration = OptionStdStringStringAsNullableTextOrigin;
pub type OptionStdStringStringAsNullableTextCreate = OptionStdStringStringAsNullableTextOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdStringStringAsNullableTextSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdStringStringAsNullableTextSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionStdStringStringAsNullableTextWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionStdStringStringAsNullableTextOrigin>),
    RegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionStdStringStringAsNullableTextWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdStringStringAsNullableTextWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdStringStringAsNullableTextWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdStringStringAsNullableTextRead(OptionStdStringStringAsNullableTextOrigin);
impl OptionStdStringStringAsNullableTextRead {
    pub fn new(value: std::option::Option<std::string::String>) -> Self {
        Self(OptionStdStringStringAsNullableTextOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdStringStringAsNullableTextRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdStringStringAsNullableTextRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdStringStringAsNullableTextRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdStringStringAsNullableTextRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionStdStringStringAsNullableTextOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdStringStringAsNullableTextRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionStdStringStringAsNullableTextOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionStdStringStringAsNullableTextOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionStdStringStringAsNullableTextReadInner = std::option::Option<std::string::String>;
pub type OptionStdStringStringAsNullableTextUpdate = OptionStdStringStringAsNullableTextOrigin;
impl crate::PostgresqlType for OptionStdStringStringAsNullableText {
    type TableTypeDeclaration = OptionStdStringStringAsNullableTextTableTypeDeclaration;
    type Create = OptionStdStringStringAsNullableTextCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionStdStringStringAsNullableTextSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionStdStringStringAsNullableTextWhereElement;
    type Read = OptionStdStringStringAsNullableTextRead;
    type ReadInner = OptionStdStringStringAsNullableTextReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionStdStringStringAsNullableTextUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdStringStringAsNotNullText as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<StdStringStringAsNotNullText as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfStdStringStringAsNotNullArrayOfNotNullText;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin(std::vec::Vec<StdStringStringAsNotNullTextOrigin>);
impl VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin {
    pub fn new(value: std::vec::Vec<std::string::String>) -> Self {
        Self(value.into_iter().map(|element| StdStringStringAsNotNullTextOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::string::String>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<StdStringStringAsNotNullTextOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<StdStringStringAsNotNullTextOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<StdStringStringAsNotNullTextOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::string::String as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} text[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfStdStringStringAsNotNullArrayOfNotNullTextTableTypeDeclaration = VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin;
pub type VecOfStdStringStringAsNotNullArrayOfNotNullTextCreate = VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdStringStringAsNotNullArrayOfNotNullTextSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdStringStringAsNotNullArrayOfNotNullTextSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfStdStringStringAsNotNullArrayOfNotNullTextWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdStringStringAsNotNullTextTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneRegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfStdStringStringAsNotNullArrayOfNotNullTextWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdStringStringAsNotNullArrayOfNotNullTextWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdStringStringAsNotNullArrayOfNotNullTextWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdStringStringAsNotNullArrayOfNotNullTextRead(VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin);
impl VecOfStdStringStringAsNotNullArrayOfNotNullTextRead {
    pub fn new(value: std::vec::Vec<std::string::String>) -> Self {
        Self(VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdStringStringAsNotNullArrayOfNotNullTextRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdStringStringAsNotNullArrayOfNotNullTextRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdStringStringAsNotNullArrayOfNotNullTextRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdStringStringAsNotNullArrayOfNotNullTextRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdStringStringAsNotNullArrayOfNotNullTextRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfStdStringStringAsNotNullArrayOfNotNullTextReadInner = std::vec::Vec<std::string::String>;
pub type VecOfStdStringStringAsNotNullArrayOfNotNullTextUpdate = VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin;
impl crate::PostgresqlType for VecOfStdStringStringAsNotNullArrayOfNotNullText {
    type TableTypeDeclaration = VecOfStdStringStringAsNotNullArrayOfNotNullTextTableTypeDeclaration;
    type Create = VecOfStdStringStringAsNotNullArrayOfNotNullTextCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfStdStringStringAsNotNullArrayOfNotNullTextSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfStdStringStringAsNotNullArrayOfNotNullTextWhereElement;
    type Read = VecOfStdStringStringAsNotNullArrayOfNotNullTextRead;
    type ReadInner = VecOfStdStringStringAsNotNullArrayOfNotNullTextReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfStdStringStringAsNotNullArrayOfNotNullTextUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <StdStringStringAsNotNullText as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<StdStringStringAsNotNullText as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullText;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin(std::option::Option<VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin>);
impl OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfStdStringStringAsNotNullArrayOfNotNullTextOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::string::String as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} text[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfStdStringStringAsNullableArrayOfNotNullTextTableTypeDeclaration = OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin;
pub type OptionVecOfStdStringStringAsNullableArrayOfNotNullTextCreate = OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullTextSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfStdStringStringAsNullableArrayOfNotNullTextWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdStringStringAsNullableTextTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneRegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdStringStringAsNullableArrayOfNotNullTextRead(OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin);
impl OptionVecOfStdStringStringAsNullableArrayOfNotNullTextRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
        Self(OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdStringStringAsNullableArrayOfNotNullTextRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfStdStringStringAsNullableArrayOfNotNullTextReadInner = std::option::Option<std::vec::Vec<std::string::String>>;
pub type OptionVecOfStdStringStringAsNullableArrayOfNotNullTextUpdate = OptionVecOfStdStringStringAsNullableArrayOfNotNullTextOrigin;
impl crate::PostgresqlType for OptionVecOfStdStringStringAsNullableArrayOfNotNullText {
    type TableTypeDeclaration = OptionVecOfStdStringStringAsNullableArrayOfNotNullTextTableTypeDeclaration;
    type Create = OptionVecOfStdStringStringAsNullableArrayOfNotNullTextCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfStdStringStringAsNullableArrayOfNotNullTextSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfStdStringStringAsNullableArrayOfNotNullTextWhereElement;
    type Read = OptionVecOfStdStringStringAsNullableArrayOfNotNullTextRead;
    type ReadInner = OptionVecOfStdStringStringAsNullableArrayOfNotNullTextReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfStdStringStringAsNullableArrayOfNotNullTextUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdStringStringAsNotNullText as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<StdStringStringAsNotNullText as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableText;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin(std::vec::Vec<OptionStdStringStringAsNullableTextOrigin>);
impl VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<std::string::String>>) -> Self {
        Self(value.into_iter().map(|element| OptionStdStringStringAsNullableTextOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<std::string::String>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionStdStringStringAsNullableTextOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionStdStringStringAsNullableTextOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionStdStringStringAsNullableTextOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::string::String as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} text[] not null")
    }
}
pub type VecOfOptionStdStringStringAsNotNullArrayOfNullableTextTableTypeDeclaration = VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin;
pub type VecOfOptionStdStringStringAsNotNullArrayOfNullableTextCreate = VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableTextSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionStdStringStringAsNotNullArrayOfNullableTextWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdStringStringAsNotNullTextTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneRegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdStringStringAsNotNullArrayOfNullableTextRead(VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin);
impl VecOfOptionStdStringStringAsNotNullArrayOfNullableTextRead {
    pub fn new(value: std::vec::Vec<std::option::Option<std::string::String>>) -> Self {
        Self(VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdStringStringAsNotNullArrayOfNullableTextRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionStdStringStringAsNotNullArrayOfNullableTextReadInner = std::vec::Vec<std::option::Option<std::string::String>>;
pub type VecOfOptionStdStringStringAsNotNullArrayOfNullableTextUpdate = VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin;
impl crate::PostgresqlType for VecOfOptionStdStringStringAsNotNullArrayOfNullableText {
    type TableTypeDeclaration = VecOfOptionStdStringStringAsNotNullArrayOfNullableTextTableTypeDeclaration;
    type Create = VecOfOptionStdStringStringAsNotNullArrayOfNullableTextCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionStdStringStringAsNotNullArrayOfNullableTextSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionStdStringStringAsNotNullArrayOfNullableTextWhereElement;
    type Read = VecOfOptionStdStringStringAsNotNullArrayOfNullableTextRead;
    type ReadInner = VecOfOptionStdStringStringAsNotNullArrayOfNullableTextReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionStdStringStringAsNotNullArrayOfNullableTextUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdStringStringAsNotNullText as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<StdStringStringAsNotNullText as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableText;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin(std::option::Option<VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin>);
impl OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::string::String>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<std::string::String>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionStdStringStringAsNotNullArrayOfNullableTextOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::string::String as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} text[]")
    }
}
pub type OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextTableTypeDeclaration = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin;
pub type OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextCreate = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdStringStringAsNullableTextTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneRegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextRead(OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin);
impl OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::string::String>>>) -> Self {
        Self(OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextReadInner = std::option::Option<std::vec::Vec<std::option::Option<std::string::String>>>;
pub type OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextUpdate = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextOrigin;
impl crate::PostgresqlType for OptionVecOfOptionStdStringStringAsNullableArrayOfNullableText {
    type TableTypeDeclaration = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextTableTypeDeclaration;
    type Create = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextWhereElement;
    type Read = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextRead;
    type ReadInner = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionStdStringStringAsNullableArrayOfNullableTextUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdStringStringAsNotNullText as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<StdStringStringAsNotNullText as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct StdVecVecStdPrimitiveU8AsNotNullBytea;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct StdVecVecStdPrimitiveU8AsNotNullByteaOrigin(std::vec::Vec<std::primitive::u8>);
impl StdVecVecStdPrimitiveU8AsNotNullByteaOrigin {
    pub fn new(value: std::vec::Vec<std::primitive::u8>) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::primitive::u8>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for StdVecVecStdPrimitiveU8AsNotNullByteaOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for StdVecVecStdPrimitiveU8AsNotNullByteaOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdVecVecStdPrimitiveU8AsNotNullByteaOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![::core::default::Default::default()])
    }
}
impl sqlx::Type<sqlx::Postgres> for StdVecVecStdPrimitiveU8AsNotNullByteaOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<std::primitive::u8> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<std::primitive::u8> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdVecVecStdPrimitiveU8AsNotNullByteaOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdVecVecStdPrimitiveU8AsNotNullByteaOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<std::primitive::u8> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for StdVecVecStdPrimitiveU8AsNotNullByteaOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::vec::Vec<std::primitive::u8> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl StdVecVecStdPrimitiveU8AsNotNullByteaOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} bytea not null")
    }
}
pub type StdVecVecStdPrimitiveU8AsNotNullByteaTableTypeDeclaration = StdVecVecStdPrimitiveU8AsNotNullByteaOrigin;
pub type StdVecVecStdPrimitiveU8AsNotNullByteaCreate = StdVecVecStdPrimitiveU8AsNotNullByteaOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdVecVecStdPrimitiveU8AsNotNullByteaSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdVecVecStdPrimitiveU8AsNotNullByteaSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum StdVecVecStdPrimitiveU8AsNotNullByteaWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<StdVecVecStdPrimitiveU8AsNotNullByteaOrigin>),
    EqualToEncodedStringRepresentation(crate::where_element_filters::PostgresqlTypeWhereElementEqualToEncodedStringRepresentation),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for StdVecVecStdPrimitiveU8AsNotNullByteaWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::EqualToEncodedStringRepresentation(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::EqualToEncodedStringRepresentation(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for StdVecVecStdPrimitiveU8AsNotNullByteaWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdVecVecStdPrimitiveU8AsNotNullByteaWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::EqualToEncodedStringRepresentation(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct StdVecVecStdPrimitiveU8AsNotNullByteaRead(StdVecVecStdPrimitiveU8AsNotNullByteaOrigin);
impl StdVecVecStdPrimitiveU8AsNotNullByteaRead {
    pub fn new(value: std::vec::Vec<std::primitive::u8>) -> Self {
        Self(StdVecVecStdPrimitiveU8AsNotNullByteaOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::primitive::u8>) -> Self {
        Self(StdVecVecStdPrimitiveU8AsNotNullByteaOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for StdVecVecStdPrimitiveU8AsNotNullByteaRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for StdVecVecStdPrimitiveU8AsNotNullByteaRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for StdVecVecStdPrimitiveU8AsNotNullByteaRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for StdVecVecStdPrimitiveU8AsNotNullByteaRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <StdVecVecStdPrimitiveU8AsNotNullByteaOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for StdVecVecStdPrimitiveU8AsNotNullByteaRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <StdVecVecStdPrimitiveU8AsNotNullByteaOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <StdVecVecStdPrimitiveU8AsNotNullByteaOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type StdVecVecStdPrimitiveU8AsNotNullByteaReadInner = std::vec::Vec<std::primitive::u8>;
pub type StdVecVecStdPrimitiveU8AsNotNullByteaUpdate = StdVecVecStdPrimitiveU8AsNotNullByteaOrigin;
impl crate::PostgresqlType for StdVecVecStdPrimitiveU8AsNotNullBytea {
    type TableTypeDeclaration = StdVecVecStdPrimitiveU8AsNotNullByteaTableTypeDeclaration;
    type Create = StdVecVecStdPrimitiveU8AsNotNullByteaCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = StdVecVecStdPrimitiveU8AsNotNullByteaSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = StdVecVecStdPrimitiveU8AsNotNullByteaWhereElement;
    type Read = StdVecVecStdPrimitiveU8AsNotNullByteaRead;
    type ReadInner = StdVecVecStdPrimitiveU8AsNotNullByteaReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = StdVecVecStdPrimitiveU8AsNotNullByteaUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![
            vec![],
            vec![0],
            vec![255],
            vec![1, 2, 3, 4, 5],
            vec![0, 0, 0, 0],
            vec![10, 20, 30, 40, 50],
            vec![b'a', b'b', b'c'],
            vec![b'\n', b'\r', b'\t'],
            b"Hello, world!".to_vec(),
            vec![0, 255, 127, 128],
            (0u8..=255).collect(),
            vec![1; 1024],
            vec![0xDE, 0xAD, 0xBE, 0xEF],
        ]
    }
}
#[derive(Debug)]
pub struct OptionStdVecVecStdPrimitiveU8AsNullableBytea;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin(std::option::Option<StdVecVecStdPrimitiveU8AsNotNullByteaOrigin>);
impl OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::u8>>) -> Self {
        Self(match value {
            Some(value) => Some(StdVecVecStdPrimitiveU8AsNotNullByteaOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::primitive::u8>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<StdVecVecStdPrimitiveU8AsNotNullByteaOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<StdVecVecStdPrimitiveU8AsNotNullByteaOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<StdVecVecStdPrimitiveU8AsNotNullByteaOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::vec::Vec<std::primitive::u8> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} bytea")
    }
}
pub type OptionStdVecVecStdPrimitiveU8AsNullableByteaTableTypeDeclaration = OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin;
pub type OptionStdVecVecStdPrimitiveU8AsNullableByteaCreate = OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdVecVecStdPrimitiveU8AsNullableByteaSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdVecVecStdPrimitiveU8AsNullableByteaSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionStdVecVecStdPrimitiveU8AsNullableByteaWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin>),
    EqualToEncodedStringRepresentation(crate::where_element_filters::PostgresqlTypeWhereElementEqualToEncodedStringRepresentation),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionStdVecVecStdPrimitiveU8AsNullableByteaWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::EqualToEncodedStringRepresentation(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::EqualToEncodedStringRepresentation(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdVecVecStdPrimitiveU8AsNullableByteaWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdVecVecStdPrimitiveU8AsNullableByteaWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::EqualToEncodedStringRepresentation(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionStdVecVecStdPrimitiveU8AsNullableByteaRead(OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin);
impl OptionStdVecVecStdPrimitiveU8AsNullableByteaRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::primitive::u8>>) -> Self {
        Self(OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionStdVecVecStdPrimitiveU8AsNullableByteaRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionStdVecVecStdPrimitiveU8AsNullableByteaRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionStdVecVecStdPrimitiveU8AsNullableByteaRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionStdVecVecStdPrimitiveU8AsNullableByteaRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionStdVecVecStdPrimitiveU8AsNullableByteaRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionStdVecVecStdPrimitiveU8AsNullableByteaReadInner = std::option::Option<std::vec::Vec<std::primitive::u8>>;
pub type OptionStdVecVecStdPrimitiveU8AsNullableByteaUpdate = OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin;
impl crate::PostgresqlType for OptionStdVecVecStdPrimitiveU8AsNullableBytea {
    type TableTypeDeclaration = OptionStdVecVecStdPrimitiveU8AsNullableByteaTableTypeDeclaration;
    type Create = OptionStdVecVecStdPrimitiveU8AsNullableByteaCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionStdVecVecStdPrimitiveU8AsNullableByteaSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionStdVecVecStdPrimitiveU8AsNullableByteaWhereElement;
    type Read = OptionStdVecVecStdPrimitiveU8AsNullableByteaRead;
    type ReadInner = OptionStdVecVecStdPrimitiveU8AsNullableByteaReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionStdVecVecStdPrimitiveU8AsNullableByteaUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdVecVecStdPrimitiveU8AsNotNullBytea as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<StdVecVecStdPrimitiveU8AsNotNullBytea as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullBytea;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin(std::vec::Vec<StdVecVecStdPrimitiveU8AsNotNullByteaOrigin>);
impl VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin {
    pub fn new(value: std::vec::Vec<std::vec::Vec<std::primitive::u8>>) -> Self {
        Self(value.into_iter().map(|element| StdVecVecStdPrimitiveU8AsNotNullByteaOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::vec::Vec<std::primitive::u8>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<StdVecVecStdPrimitiveU8AsNotNullByteaOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<StdVecVecStdPrimitiveU8AsNotNullByteaOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<StdVecVecStdPrimitiveU8AsNotNullByteaOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::vec::Vec<std::primitive::u8> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} bytea[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaTableTypeDeclaration = VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin;
pub type VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaCreate = VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdVecVecStdPrimitiveU8AsNotNullByteaTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneEqualToEncodedStringRepresentation(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqualToEncodedStringRepresentation),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqualToEncodedStringRepresentation(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqualToEncodedStringRepresentation(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqualToEncodedStringRepresentation(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaRead(VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin);
impl VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaRead {
    pub fn new(value: std::vec::Vec<std::vec::Vec<std::primitive::u8>>) -> Self {
        Self(VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaReadInner = std::vec::Vec<std::vec::Vec<std::primitive::u8>>;
pub type VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaUpdate = VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin;
impl crate::PostgresqlType for VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullBytea {
    type TableTypeDeclaration = VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaTableTypeDeclaration;
    type Create = VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaWhereElement;
    type Read = VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaRead;
    type ReadInner = VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <StdVecVecStdPrimitiveU8AsNotNullBytea as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<StdVecVecStdPrimitiveU8AsNotNullBytea as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullBytea;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin(std::option::Option<VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin>);
impl OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::vec::Vec<std::primitive::u8>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::vec::Vec<std::primitive::u8>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfStdVecVecStdPrimitiveU8AsNotNullArrayOfNotNullByteaOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::vec::Vec<std::primitive::u8> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} bytea[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaTableTypeDeclaration = OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin;
pub type OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaCreate = OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdVecVecStdPrimitiveU8AsNullableByteaTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneEqualToEncodedStringRepresentation(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqualToEncodedStringRepresentation),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqualToEncodedStringRepresentation(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqualToEncodedStringRepresentation(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqualToEncodedStringRepresentation(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaRead(OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin);
impl OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::vec::Vec<std::primitive::u8>>>) -> Self {
        Self(OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaReadInner = std::option::Option<std::vec::Vec<std::vec::Vec<std::primitive::u8>>>;
pub type OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaUpdate = OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaOrigin;
impl crate::PostgresqlType for OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullBytea {
    type TableTypeDeclaration = OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaTableTypeDeclaration;
    type Create = OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaWhereElement;
    type Read = OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaRead;
    type ReadInner = OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfStdVecVecStdPrimitiveU8AsNullableArrayOfNotNullByteaUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdVecVecStdPrimitiveU8AsNotNullBytea as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<StdVecVecStdPrimitiveU8AsNotNullBytea as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableBytea;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin(std::vec::Vec<OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin>);
impl VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<std::vec::Vec<std::primitive::u8>>>) -> Self {
        Self(value.into_iter().map(|element| OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<std::vec::Vec<std::primitive::u8>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionStdVecVecStdPrimitiveU8AsNullableByteaOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::vec::Vec<std::primitive::u8> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} bytea[] not null")
    }
}
pub type VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaTableTypeDeclaration = VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin;
pub type VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaCreate = VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<StdVecVecStdPrimitiveU8AsNotNullByteaTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneEqualToEncodedStringRepresentation(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqualToEncodedStringRepresentation),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqualToEncodedStringRepresentation(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqualToEncodedStringRepresentation(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqualToEncodedStringRepresentation(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaRead(VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin);
impl VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaRead {
    pub fn new(value: std::vec::Vec<std::option::Option<std::vec::Vec<std::primitive::u8>>>) -> Self {
        Self(VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaReadInner = std::vec::Vec<std::option::Option<std::vec::Vec<std::primitive::u8>>>;
pub type VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaUpdate = VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin;
impl crate::PostgresqlType for VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableBytea {
    type TableTypeDeclaration = VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaTableTypeDeclaration;
    type Create = VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaWhereElement;
    type Read = VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaRead;
    type ReadInner = VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdVecVecStdPrimitiveU8AsNotNullBytea as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<StdVecVecStdPrimitiveU8AsNotNullBytea as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableBytea;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin(std::option::Option<VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin>);
impl OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::vec::Vec<std::primitive::u8>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<std::vec::Vec<std::primitive::u8>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionStdVecVecStdPrimitiveU8AsNotNullArrayOfNullableByteaOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <std::vec::Vec<std::primitive::u8> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} bytea[]")
    }
}
pub type OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaTableTypeDeclaration = OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin;
pub type OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaCreate = OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionStdVecVecStdPrimitiveU8AsNullableByteaTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneEqualToEncodedStringRepresentation(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqualToEncodedStringRepresentation),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqualToEncodedStringRepresentation(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqualToEncodedStringRepresentation(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqualToEncodedStringRepresentation(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaRead(OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin);
impl OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<std::vec::Vec<std::primitive::u8>>>>) -> Self {
        Self(OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaReadInner = std::option::Option<std::vec::Vec<std::option::Option<std::vec::Vec<std::primitive::u8>>>>;
pub type OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaUpdate = OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaOrigin;
impl crate::PostgresqlType for OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableBytea {
    type TableTypeDeclaration = OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaTableTypeDeclaration;
    type Create = OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaWhereElement;
    type Read = OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaRead;
    type ReadInner = OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionStdVecVecStdPrimitiveU8AsNullableArrayOfNullableByteaUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <StdVecVecStdPrimitiveU8AsNotNullBytea as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<StdVecVecStdPrimitiveU8AsNotNullBytea as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxTypesChronoNaiveTimeAsNotNullTime;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin(sqlx::types::chrono::NaiveTime);
impl SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin {
    pub fn new(value: sqlx::types::chrono::NaiveTime) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::chrono::NaiveTime) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::types::chrono::NaiveTime as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::types::chrono::NaiveTime as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::types::chrono::NaiveTime as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} time not null")
    }
}
pub type SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration = SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin;
pub type SqlxTypesChronoNaiveTimeAsNotNullTimeCreate = SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoNaiveTimeAsNotNullTimeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoNaiveTimeAsNotNullTimeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxTypesChronoNaiveTimeAsNotNullTimeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    CurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementCurrentTime),
    GreaterThanCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanCurrentTime),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesChronoNaiveTimeAsNotNullTimeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::CurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::CurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoNaiveTimeAsNotNullTimeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoNaiveTimeAsNotNullTimeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::CurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoNaiveTimeAsNotNullTimeRead(SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin);
impl SqlxTypesChronoNaiveTimeAsNotNullTimeRead {
    pub fn new(value: sqlx::types::chrono::NaiveTime) -> Self {
        Self(SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::chrono::NaiveTime) -> Self {
        Self(SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoNaiveTimeAsNotNullTimeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoNaiveTimeAsNotNullTimeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesChronoNaiveTimeAsNotNullTimeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesChronoNaiveTimeAsNotNullTimeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesChronoNaiveTimeAsNotNullTimeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxTypesChronoNaiveTimeAsNotNullTimeReadInner = sqlx::types::chrono::NaiveTime;
pub type SqlxTypesChronoNaiveTimeAsNotNullTimeUpdate = SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin;
impl crate::PostgresqlType for SqlxTypesChronoNaiveTimeAsNotNullTime {
    type TableTypeDeclaration = SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration;
    type Create = SqlxTypesChronoNaiveTimeAsNotNullTimeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxTypesChronoNaiveTimeAsNotNullTimeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxTypesChronoNaiveTimeAsNotNullTimeWhereElement;
    type Read = SqlxTypesChronoNaiveTimeAsNotNullTimeRead;
    type ReadInner = SqlxTypesChronoNaiveTimeAsNotNullTimeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxTypesChronoNaiveTimeAsNotNullTimeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![
            sqlx::types::chrono::NaiveTime::from_hms_opt(0, 0, 0).unwrap(),
            sqlx::types::chrono::NaiveTime::from_hms_opt(12, 0, 0).unwrap(),
            sqlx::types::chrono::NaiveTime::from_hms_opt(23, 59, 59).unwrap(),
            sqlx::types::chrono::NaiveTime::from_hms_nano_opt(23, 59, 59, 999_999_999).unwrap(),
            sqlx::types::chrono::NaiveTime::from_hms_opt(6, 30, 0).unwrap(),
            sqlx::types::chrono::NaiveTime::from_hms_opt(18, 45, 15).unwrap(),
            sqlx::types::chrono::NaiveTime::from_hms_milli_opt(10, 5, 3, 250).unwrap(),
            sqlx::types::chrono::NaiveTime::from_hms_micro_opt(14, 22, 33, 123_456).unwrap(),
        ]
    }
}
#[derive(Debug)]
pub struct OptionSqlxTypesChronoNaiveTimeAsNullableTime;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin(std::option::Option<SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin>);
impl OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin {
    pub fn new(value: std::option::Option<sqlx::types::chrono::NaiveTime>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::types::chrono::NaiveTime>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} time")
    }
}
pub type OptionSqlxTypesChronoNaiveTimeAsNullableTimeTableTypeDeclaration = OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin;
pub type OptionSqlxTypesChronoNaiveTimeAsNullableTimeCreate = OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoNaiveTimeAsNullableTimeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoNaiveTimeAsNullableTimeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxTypesChronoNaiveTimeAsNullableTimeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    CurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementCurrentTime),
    GreaterThanCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanCurrentTime),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxTypesChronoNaiveTimeAsNullableTimeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::CurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::CurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoNaiveTimeAsNullableTimeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoNaiveTimeAsNullableTimeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::CurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoNaiveTimeAsNullableTimeRead(OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin);
impl OptionSqlxTypesChronoNaiveTimeAsNullableTimeRead {
    pub fn new(value: std::option::Option<sqlx::types::chrono::NaiveTime>) -> Self {
        Self(OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoNaiveTimeAsNullableTimeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoNaiveTimeAsNullableTimeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesChronoNaiveTimeAsNullableTimeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesChronoNaiveTimeAsNullableTimeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesChronoNaiveTimeAsNullableTimeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxTypesChronoNaiveTimeAsNullableTimeReadInner = std::option::Option<sqlx::types::chrono::NaiveTime>;
pub type OptionSqlxTypesChronoNaiveTimeAsNullableTimeUpdate = OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin;
impl crate::PostgresqlType for OptionSqlxTypesChronoNaiveTimeAsNullableTime {
    type TableTypeDeclaration = OptionSqlxTypesChronoNaiveTimeAsNullableTimeTableTypeDeclaration;
    type Create = OptionSqlxTypesChronoNaiveTimeAsNullableTimeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxTypesChronoNaiveTimeAsNullableTimeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxTypesChronoNaiveTimeAsNullableTimeWhereElement;
    type Read = OptionSqlxTypesChronoNaiveTimeAsNullableTimeRead;
    type ReadInner = OptionSqlxTypesChronoNaiveTimeAsNullableTimeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxTypesChronoNaiveTimeAsNullableTimeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoNaiveTimeAsNotNullTime as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxTypesChronoNaiveTimeAsNotNullTime as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTime;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin(std::vec::Vec<SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin>);
impl VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin {
    pub fn new(value: std::vec::Vec<sqlx::types::chrono::NaiveTime>) -> Self {
        Self(value.into_iter().map(|element| SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::types::chrono::NaiveTime>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxTypesChronoNaiveTimeAsNotNullTimeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} time[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeTableTypeDeclaration = VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin;
pub type VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeCreate = VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTime),
    DimensionOneGreaterThanCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTime),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeRead(VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin);
impl VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeRead {
    pub fn new(value: std::vec::Vec<sqlx::types::chrono::NaiveTime>) -> Self {
        Self(VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeReadInner = std::vec::Vec<sqlx::types::chrono::NaiveTime>;
pub type VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeUpdate = VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin;
impl crate::PostgresqlType for VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTime {
    type TableTypeDeclaration = VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeTableTypeDeclaration;
    type Create = VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeWhereElement;
    type Read = VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeRead;
    type ReadInner = VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxTypesChronoNaiveTimeAsNotNullTime as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxTypesChronoNaiveTimeAsNotNullTime as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTime;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin(std::option::Option<VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin>);
impl OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::NaiveTime>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::NaiveTime>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxTypesChronoNaiveTimeAsNotNullArrayOfNotNullTimeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} time[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeTableTypeDeclaration = OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin;
pub type OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeCreate = OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesChronoNaiveTimeAsNullableTimeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTime),
    DimensionOneGreaterThanCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTime),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeRead(OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin);
impl OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::NaiveTime>>) -> Self {
        Self(OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeReadInner = std::option::Option<std::vec::Vec<sqlx::types::chrono::NaiveTime>>;
pub type OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeUpdate = OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTime {
    type TableTypeDeclaration = OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeTableTypeDeclaration;
    type Create = OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeWhereElement;
    type Read = OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeRead;
    type ReadInner = OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxTypesChronoNaiveTimeAsNullableArrayOfNotNullTimeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoNaiveTimeAsNotNullTime as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxTypesChronoNaiveTimeAsNotNullTime as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTime;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin(std::vec::Vec<OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin>);
impl VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveTime>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveTime>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxTypesChronoNaiveTimeAsNullableTimeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} time[] not null")
    }
}
pub type VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeTableTypeDeclaration = VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin;
pub type VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeCreate = VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTime),
    DimensionOneGreaterThanCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTime),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeRead(VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin);
impl VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveTime>>) -> Self {
        Self(VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeReadInner = std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveTime>>;
pub type VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeUpdate = VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTime {
    type TableTypeDeclaration = VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeTableTypeDeclaration;
    type Create = VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeWhereElement;
    type Read = VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeRead;
    type ReadInner = VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoNaiveTimeAsNotNullTime as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxTypesChronoNaiveTimeAsNotNullTime as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTime;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin(std::option::Option<VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin>);
impl OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveTime>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveTime>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxTypesChronoNaiveTimeAsNotNullArrayOfNullableTimeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} time[]")
    }
}
pub type OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeTableTypeDeclaration = OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin;
pub type OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeCreate = OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesChronoNaiveTimeAsNullableTimeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoNaiveTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTime),
    DimensionOneGreaterThanCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTime),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeRead(OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin);
impl OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveTime>>>) -> Self {
        Self(OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveTime>>>;
pub type OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeUpdate = OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTime {
    type TableTypeDeclaration = OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeWhereElement;
    type Read = OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeRead;
    type ReadInner = OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxTypesChronoNaiveTimeAsNullableArrayOfNullableTimeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoNaiveTimeAsNotNullTime as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxTypesChronoNaiveTimeAsNotNullTime as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxTypesTimeTimeAsNotNullTime;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesTimeTimeAsNotNullTimeOrigin(sqlx::types::time::Time);
impl SqlxTypesTimeTimeAsNotNullTimeOrigin {
    pub fn new(value: sqlx::types::time::Time) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::time::Time) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for SqlxTypesTimeTimeAsNotNullTimeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesTimeTimeAsNotNullTimeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesTimeTimeAsNotNullTimeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::types::time::Time::MIDNIGHT)
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesTimeTimeAsNotNullTimeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::types::time::Time as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::types::time::Time as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesTimeTimeAsNotNullTimeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesTimeTimeAsNotNullTimeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::types::time::Time as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxTypesTimeTimeAsNotNullTimeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::Time as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxTypesTimeTimeAsNotNullTimeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} time not null")
    }
}
pub type SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration = SqlxTypesTimeTimeAsNotNullTimeOrigin;
pub type SqlxTypesTimeTimeAsNotNullTimeCreate = SqlxTypesTimeTimeAsNotNullTimeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesTimeTimeAsNotNullTimeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesTimeTimeAsNotNullTimeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxTypesTimeTimeAsNotNullTimeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxTypesTimeTimeAsNotNullTimeOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    CurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementCurrentTime),
    GreaterThanCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanCurrentTime),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesTimeTimeAsNotNullTimeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::CurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::CurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesTimeTimeAsNotNullTimeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesTimeTimeAsNotNullTimeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::CurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesTimeTimeAsNotNullTimeRead(SqlxTypesTimeTimeAsNotNullTimeOrigin);
impl SqlxTypesTimeTimeAsNotNullTimeRead {
    pub fn new(value: sqlx::types::time::Time) -> Self {
        Self(SqlxTypesTimeTimeAsNotNullTimeOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::time::Time) -> Self {
        Self(SqlxTypesTimeTimeAsNotNullTimeOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesTimeTimeAsNotNullTimeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesTimeTimeAsNotNullTimeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesTimeTimeAsNotNullTimeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesTimeTimeAsNotNullTimeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxTypesTimeTimeAsNotNullTimeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesTimeTimeAsNotNullTimeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxTypesTimeTimeAsNotNullTimeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxTypesTimeTimeAsNotNullTimeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxTypesTimeTimeAsNotNullTimeReadInner = sqlx::types::time::Time;
pub type SqlxTypesTimeTimeAsNotNullTimeUpdate = SqlxTypesTimeTimeAsNotNullTimeOrigin;
impl crate::PostgresqlType for SqlxTypesTimeTimeAsNotNullTime {
    type TableTypeDeclaration = SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration;
    type Create = SqlxTypesTimeTimeAsNotNullTimeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxTypesTimeTimeAsNotNullTimeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxTypesTimeTimeAsNotNullTimeWhereElement;
    type Read = SqlxTypesTimeTimeAsNotNullTimeRead;
    type ReadInner = SqlxTypesTimeTimeAsNotNullTimeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxTypesTimeTimeAsNotNullTimeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![
            sqlx::types::time::Time::MIDNIGHT,
            sqlx::types::time::Time::from_hms(12, 0, 0).unwrap(),
            sqlx::types::time::Time::from_hms_milli(23, 59, 59, 999).unwrap(),
            sqlx::types::time::Time::from_hms_micro(1, 2, 3, 456_789).unwrap(),
            sqlx::types::time::Time::from_hms(6, 30, 15).unwrap(),
            sqlx::types::time::Time::from_hms(18, 45, 0).unwrap(),
        ]
    }
}
#[derive(Debug)]
pub struct OptionSqlxTypesTimeTimeAsNullableTime;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesTimeTimeAsNullableTimeOrigin(std::option::Option<SqlxTypesTimeTimeAsNotNullTimeOrigin>);
impl OptionSqlxTypesTimeTimeAsNullableTimeOrigin {
    pub fn new(value: std::option::Option<sqlx::types::time::Time>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxTypesTimeTimeAsNotNullTimeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::types::time::Time>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxTypesTimeTimeAsNullableTimeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesTimeTimeAsNullableTimeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesTimeTimeAsNullableTimeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesTimeTimeAsNullableTimeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxTypesTimeTimeAsNotNullTimeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxTypesTimeTimeAsNotNullTimeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesTimeTimeAsNullableTimeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesTimeTimeAsNullableTimeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxTypesTimeTimeAsNotNullTimeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxTypesTimeTimeAsNullableTimeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::Time as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxTypesTimeTimeAsNullableTimeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} time")
    }
}
pub type OptionSqlxTypesTimeTimeAsNullableTimeTableTypeDeclaration = OptionSqlxTypesTimeTimeAsNullableTimeOrigin;
pub type OptionSqlxTypesTimeTimeAsNullableTimeCreate = OptionSqlxTypesTimeTimeAsNullableTimeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesTimeTimeAsNullableTimeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesTimeTimeAsNullableTimeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxTypesTimeTimeAsNullableTimeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxTypesTimeTimeAsNullableTimeOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    CurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementCurrentTime),
    GreaterThanCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanCurrentTime),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxTypesTimeTimeAsNullableTimeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::CurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::CurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesTimeTimeAsNullableTimeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesTimeTimeAsNullableTimeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::CurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesTimeTimeAsNullableTimeRead(OptionSqlxTypesTimeTimeAsNullableTimeOrigin);
impl OptionSqlxTypesTimeTimeAsNullableTimeRead {
    pub fn new(value: std::option::Option<sqlx::types::time::Time>) -> Self {
        Self(OptionSqlxTypesTimeTimeAsNullableTimeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesTimeTimeAsNullableTimeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesTimeTimeAsNullableTimeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesTimeTimeAsNullableTimeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesTimeTimeAsNullableTimeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxTypesTimeTimeAsNullableTimeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesTimeTimeAsNullableTimeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxTypesTimeTimeAsNullableTimeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxTypesTimeTimeAsNullableTimeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxTypesTimeTimeAsNullableTimeReadInner = std::option::Option<sqlx::types::time::Time>;
pub type OptionSqlxTypesTimeTimeAsNullableTimeUpdate = OptionSqlxTypesTimeTimeAsNullableTimeOrigin;
impl crate::PostgresqlType for OptionSqlxTypesTimeTimeAsNullableTime {
    type TableTypeDeclaration = OptionSqlxTypesTimeTimeAsNullableTimeTableTypeDeclaration;
    type Create = OptionSqlxTypesTimeTimeAsNullableTimeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxTypesTimeTimeAsNullableTimeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxTypesTimeTimeAsNullableTimeWhereElement;
    type Read = OptionSqlxTypesTimeTimeAsNullableTimeRead;
    type ReadInner = OptionSqlxTypesTimeTimeAsNullableTimeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxTypesTimeTimeAsNullableTimeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesTimeTimeAsNotNullTime as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxTypesTimeTimeAsNotNullTime as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTime;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin(std::vec::Vec<SqlxTypesTimeTimeAsNotNullTimeOrigin>);
impl VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin {
    pub fn new(value: std::vec::Vec<sqlx::types::time::Time>) -> Self {
        Self(value.into_iter().map(|element| SqlxTypesTimeTimeAsNotNullTimeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::types::time::Time>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxTypesTimeTimeAsNotNullTimeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxTypesTimeTimeAsNotNullTimeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxTypesTimeTimeAsNotNullTimeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::Time as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} time[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeTableTypeDeclaration = VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin;
pub type VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeCreate = VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTime),
    DimensionOneGreaterThanCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTime),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeRead(VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin);
impl VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeRead {
    pub fn new(value: std::vec::Vec<sqlx::types::time::Time>) -> Self {
        Self(VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeReadInner = std::vec::Vec<sqlx::types::time::Time>;
pub type VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeUpdate = VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin;
impl crate::PostgresqlType for VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTime {
    type TableTypeDeclaration = VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeTableTypeDeclaration;
    type Create = VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeWhereElement;
    type Read = VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeRead;
    type ReadInner = VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxTypesTimeTimeAsNotNullTime as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxTypesTimeTimeAsNotNullTime as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTime;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin(std::option::Option<VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin>);
impl OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::time::Time>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::types::time::Time>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxTypesTimeTimeAsNotNullArrayOfNotNullTimeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::Time as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} time[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeTableTypeDeclaration = OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin;
pub type OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeCreate = OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesTimeTimeAsNullableTimeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTime),
    DimensionOneGreaterThanCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTime),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeRead(OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin);
impl OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::time::Time>>) -> Self {
        Self(OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeReadInner = std::option::Option<std::vec::Vec<sqlx::types::time::Time>>;
pub type OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeUpdate = OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTime {
    type TableTypeDeclaration = OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeTableTypeDeclaration;
    type Create = OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeWhereElement;
    type Read = OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeRead;
    type ReadInner = OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxTypesTimeTimeAsNullableArrayOfNotNullTimeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesTimeTimeAsNotNullTime as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxTypesTimeTimeAsNotNullTime as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTime;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin(std::vec::Vec<OptionSqlxTypesTimeTimeAsNullableTimeOrigin>);
impl VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::time::Time>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxTypesTimeTimeAsNullableTimeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::types::time::Time>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxTypesTimeTimeAsNullableTimeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxTypesTimeTimeAsNullableTimeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxTypesTimeTimeAsNullableTimeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::Time as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} time[] not null")
    }
}
pub type VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeTableTypeDeclaration = VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin;
pub type VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeCreate = VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTime),
    DimensionOneGreaterThanCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTime),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeRead(VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin);
impl VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::time::Time>>) -> Self {
        Self(VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeReadInner = std::vec::Vec<std::option::Option<sqlx::types::time::Time>>;
pub type VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeUpdate = VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTime {
    type TableTypeDeclaration = VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeTableTypeDeclaration;
    type Create = VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeWhereElement;
    type Read = VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeRead;
    type ReadInner = VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesTimeTimeAsNotNullTime as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxTypesTimeTimeAsNotNullTime as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTime;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin(std::option::Option<VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin>);
impl OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::time::Time>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::time::Time>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxTypesTimeTimeAsNotNullArrayOfNullableTimeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::Time as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} time[]")
    }
}
pub type OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeTableTypeDeclaration = OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin;
pub type OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeCreate = OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesTimeTimeAsNullableTimeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesTimeTimeAsNotNullTimeTableTypeDeclaration>),
    DimensionOneCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTime),
    DimensionOneGreaterThanCurrentTime(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTime),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTime(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTime(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeRead(OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin);
impl OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::time::Time>>>) -> Self {
        Self(OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::time::Time>>>;
pub type OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeUpdate = OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTime {
    type TableTypeDeclaration = OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeWhereElement;
    type Read = OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeRead;
    type ReadInner = OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxTypesTimeTimeAsNullableArrayOfNullableTimeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesTimeTimeAsNotNullTime as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxTypesTimeTimeAsNotNullTime as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxPostgresTypesPgIntervalAsNotNullInterval;
#[derive(Debug, Clone, PartialEq)]
pub struct SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin(sqlx::postgres::types::PgInterval);
impl SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin {
    pub fn new(value: sqlx::postgres::types::PgInterval) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgInterval) -> Self {
        Self::new(value)
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(__serializer, "SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin", false as std::primitive::usize + 1 + 1 + 1)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "months", &self.0.months)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "days", &self.0.days)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "microseconds", &self.0.microseconds)?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            enum Field {
                Months,
                Days,
                Microseconds,
            }
            impl<'de> serde::Deserialize<'de> for Field {
                fn deserialize<D>(__deserializer: D) -> Result<Field, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = Field;
                        fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                            serde::__private::Formatter::write_str(__f, "`months` or `days` or `microseconds`")
                        }
                        fn visit_str<E>(self, value: &str) -> Result<Field, E>
                        where
                            E: serde::de::Error,
                        {
                            match value {
                                "months" => Ok(Field::Months),
                                "days" => Ok(Field::Days),
                                "microseconds" => Ok(Field::Microseconds),
                                _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                            }
                        }
                    }
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct SqlxPostgresTypesPgIntervalAsIntervalVisitor;
            impl<'de> _serde::de::Visitor<'de> for SqlxPostgresTypesPgIntervalAsIntervalVisitor {
                type Value = SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin")
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let months = __seq.next_element()?.ok_or_else(|| serde::de::Error::invalid_length(0, &self))?;
                    let days = __seq.next_element()?.ok_or_else(|| serde::de::Error::invalid_length(1, &self))?;
                    let microseconds = __seq.next_element()?.ok_or_else(|| serde::de::Error::invalid_length(2, &self))?;
                    serde::__private::Ok(SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin(sqlx::postgres::types::PgInterval { months, days, microseconds }))
                }
                #[inline]
                fn visit_map<V>(self, mut map: V) -> Result<SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
                {
                    let mut months = None;
                    let mut days = None;
                    let mut microseconds = None;
                    while let Some(key) = map.next_key()? {
                        match key {
                            Field::Months => {
                                if months.is_some() {
                                    return Err(serde::de::Error::duplicate_field("months"));
                                }
                                months = Some(map.next_value()?);
                            }
                            Field::Days => {
                                if days.is_some() {
                                    return Err(serde::de::Error::duplicate_field("days"));
                                }
                                days = Some(map.next_value()?);
                            }
                            Field::Microseconds => {
                                if microseconds.is_some() {
                                    return Err(serde::de::Error::duplicate_field("microseconds"));
                                }
                                microseconds = Some(map.next_value()?);
                            }
                        }
                    }
                    let __field0 = months.ok_or_else(|| serde::de::Error::missing_field("\"months\""))?;
                    let __field1 = days.ok_or_else(|| serde::de::Error::missing_field("\"days\""))?;
                    let __field2 = microseconds.ok_or_else(|| serde::de::Error::missing_field("\"microseconds\""))?;
                    serde::__private::Ok(SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin(sqlx::postgres::types::PgInterval {
                        months: __field0,
                        days: __field1,
                        microseconds: __field2,
                    }))
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["months", "days", "microseconds"];
            _serde::Deserializer::deserialize_struct(__deserializer, "SqlxPostgresTypesPgIntervalAsNotNullInterval", FIELDS, SqlxPostgresTypesPgIntervalAsIntervalVisitor)
        }
    }
};
impl std::fmt::Display for SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::postgres::types::PgInterval {
            months: ::core::default::Default::default(),
            days: ::core::default::Default::default(),
            microseconds: ::core::default::Default::default(),
        })
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::postgres::types::PgInterval as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::postgres::types::PgInterval as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::postgres::types::PgInterval as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgInterval as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} interval not null")
    }
}
pub type SqlxPostgresTypesPgIntervalAsNotNullIntervalTableTypeDeclaration = SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin;
pub type SqlxPostgresTypesPgIntervalAsNotNullIntervalCreate = SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgIntervalAsNotNullIntervalSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgIntervalAsNotNullIntervalSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxPostgresTypesPgIntervalAsNotNullIntervalWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxPostgresTypesPgIntervalAsNotNullIntervalWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgIntervalAsNotNullIntervalWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgIntervalAsNotNullIntervalWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgIntervalAsNotNullIntervalRead(SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin);
impl SqlxPostgresTypesPgIntervalAsNotNullIntervalRead {
    pub fn new(value: sqlx::postgres::types::PgInterval) -> Self {
        Self(SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgInterval) -> Self {
        Self(SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgIntervalAsNotNullIntervalRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgIntervalAsNotNullIntervalRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgIntervalAsNotNullIntervalRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgIntervalAsNotNullIntervalRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgIntervalAsNotNullIntervalRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxPostgresTypesPgIntervalAsNotNullIntervalReadInner = sqlx::postgres::types::PgInterval;
pub type SqlxPostgresTypesPgIntervalAsNotNullIntervalUpdate = SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin;
impl crate::PostgresqlType for SqlxPostgresTypesPgIntervalAsNotNullInterval {
    type TableTypeDeclaration = SqlxPostgresTypesPgIntervalAsNotNullIntervalTableTypeDeclaration;
    type Create = SqlxPostgresTypesPgIntervalAsNotNullIntervalCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxPostgresTypesPgIntervalAsNotNullIntervalSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxPostgresTypesPgIntervalAsNotNullIntervalWhereElement;
    type Read = SqlxPostgresTypesPgIntervalAsNotNullIntervalRead;
    type ReadInner = SqlxPostgresTypesPgIntervalAsNotNullIntervalReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxPostgresTypesPgIntervalAsNotNullIntervalUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![
            sqlx::postgres::types::PgInterval { months: 0, days: 0, microseconds: 0 },
            sqlx::postgres::types::PgInterval { months: 1, days: 0, microseconds: 0 },
            sqlx::postgres::types::PgInterval { months: 0, days: 7, microseconds: 0 },
            sqlx::postgres::types::PgInterval { months: 0, days: 0, microseconds: 1_000_000 },
            sqlx::postgres::types::PgInterval { months: 0, days: 0, microseconds: 60_000_000 },
            sqlx::postgres::types::PgInterval { months: 0, days: 0, microseconds: 3_600_000_000 },
            sqlx::postgres::types::PgInterval { months: 12, days: 30, microseconds: 86_400_000_000 },
            sqlx::postgres::types::PgInterval { months: -1, days: -10, microseconds: -1_000_000 },
            sqlx::postgres::types::PgInterval { months: 2, days: 15, microseconds: 123_456_789 },
            sqlx::postgres::types::PgInterval {
                months: 0,
                days: 0,
                microseconds: std::primitive::i64::MAX,
            },
            sqlx::postgres::types::PgInterval {
                months: 0,
                days: 0,
                microseconds: std::primitive::i64::MIN + 1,
            },
        ]
    }
}
#[derive(Debug)]
pub struct OptionSqlxPostgresTypesPgIntervalAsNullableInterval;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin(std::option::Option<SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin>);
impl OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgInterval>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::postgres::types::PgInterval>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgInterval as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} interval")
    }
}
pub type OptionSqlxPostgresTypesPgIntervalAsNullableIntervalTableTypeDeclaration = OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin;
pub type OptionSqlxPostgresTypesPgIntervalAsNullableIntervalCreate = OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgIntervalAsNullableIntervalSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxPostgresTypesPgIntervalAsNullableIntervalWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgIntervalAsNullableIntervalRead(OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin);
impl OptionSqlxPostgresTypesPgIntervalAsNullableIntervalRead {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgInterval>) -> Self {
        Self(OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgIntervalAsNullableIntervalRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxPostgresTypesPgIntervalAsNullableIntervalReadInner = std::option::Option<sqlx::postgres::types::PgInterval>;
pub type OptionSqlxPostgresTypesPgIntervalAsNullableIntervalUpdate = OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin;
impl crate::PostgresqlType for OptionSqlxPostgresTypesPgIntervalAsNullableInterval {
    type TableTypeDeclaration = OptionSqlxPostgresTypesPgIntervalAsNullableIntervalTableTypeDeclaration;
    type Create = OptionSqlxPostgresTypesPgIntervalAsNullableIntervalCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxPostgresTypesPgIntervalAsNullableIntervalSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxPostgresTypesPgIntervalAsNullableIntervalWhereElement;
    type Read = OptionSqlxPostgresTypesPgIntervalAsNullableIntervalRead;
    type ReadInner = OptionSqlxPostgresTypesPgIntervalAsNullableIntervalReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxPostgresTypesPgIntervalAsNullableIntervalUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgIntervalAsNotNullInterval as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgIntervalAsNotNullInterval as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullInterval;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin(std::vec::Vec<SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin>);
impl VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgInterval>) -> Self {
        Self(value.into_iter().map(|element| SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::postgres::types::PgInterval>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxPostgresTypesPgIntervalAsNotNullIntervalOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgInterval as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} interval[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalTableTypeDeclaration = VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin;
pub type VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalCreate = VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgIntervalAsNotNullIntervalTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalRead(VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin);
impl VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalRead {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgInterval>) -> Self {
        Self(VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalReadInner = std::vec::Vec<sqlx::postgres::types::PgInterval>;
pub type VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalUpdate = VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin;
impl crate::PostgresqlType for VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullInterval {
    type TableTypeDeclaration = VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalTableTypeDeclaration;
    type Create = VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalWhereElement;
    type Read = VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalRead;
    type ReadInner = VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxPostgresTypesPgIntervalAsNotNullInterval as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxPostgresTypesPgIntervalAsNotNullInterval as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullInterval;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin(std::option::Option<VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin>);
impl OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgInterval>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgInterval>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxPostgresTypesPgIntervalAsNotNullArrayOfNotNullIntervalOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgInterval as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} interval[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalTableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin;
pub type OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalCreate = OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgIntervalAsNullableIntervalTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalRead(OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin);
impl OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgInterval>>) -> Self {
        Self(OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalReadInner = std::option::Option<std::vec::Vec<sqlx::postgres::types::PgInterval>>;
pub type OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalUpdate = OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullInterval {
    type TableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalTableTypeDeclaration;
    type Create = OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalWhereElement;
    type Read = OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalRead;
    type ReadInner = OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxPostgresTypesPgIntervalAsNullableArrayOfNotNullIntervalUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgIntervalAsNotNullInterval as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxPostgresTypesPgIntervalAsNotNullInterval as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableInterval;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin(std::vec::Vec<OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin>);
impl VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgInterval>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgInterval>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxPostgresTypesPgIntervalAsNullableIntervalOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgInterval as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} interval[] not null")
    }
}
pub type VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalTableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin;
pub type VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalCreate = VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgIntervalAsNotNullIntervalTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalRead(VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin);
impl VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgInterval>>) -> Self {
        Self(VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalReadInner = std::vec::Vec<std::option::Option<sqlx::postgres::types::PgInterval>>;
pub type VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalUpdate = VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableInterval {
    type TableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalTableTypeDeclaration;
    type Create = VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalWhereElement;
    type Read = VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalRead;
    type ReadInner = VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgIntervalAsNotNullInterval as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgIntervalAsNotNullInterval as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableInterval;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin(std::option::Option<VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin>);
impl OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgInterval>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgInterval>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxPostgresTypesPgIntervalAsNotNullArrayOfNullableIntervalOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgInterval as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} interval[]")
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalTableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin;
pub type OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalCreate = OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgIntervalAsNullableIntervalTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalRead(OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin);
impl OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgInterval>>>) -> Self {
        Self(OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgInterval>>>;
pub type OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalUpdate = OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableInterval {
    type TableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalWhereElement;
    type Read = OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalRead;
    type ReadInner = OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxPostgresTypesPgIntervalAsNullableArrayOfNullableIntervalUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgIntervalAsNotNullInterval as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgIntervalAsNotNullInterval as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxTypesTimeDateAsNotNullDate;
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct SqlxTypesTimeDateAsNotNullDateOrigin(sqlx::types::time::Date);
impl SqlxTypesTimeDateAsNotNullDateOrigin {
    pub fn new(value: sqlx::types::time::Date) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::time::Date) -> Self {
        Self::new(value)
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxTypesTimeDateAsNotNullDateOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(__serializer, "SqlxTypesTimeDateAsNotNullDateOrigin", false as std::primitive::usize + 1 + 1 + 1)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "year", &self.0.year())?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "month", &self.0.month())?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "day", &self.0.day())?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxTypesTimeDateAsNotNullDateOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        0u64 => serde::__private::Ok(__Field::__field0),
                        1u64 => serde::__private::Ok(__Field::__field1),
                        2u64 => serde::__private::Ok(__Field::__field2),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(self, __value: &str) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "year" => _serde::__private::Ok(__Field::__field0),
                        "month" => _serde::__private::Ok(__Field::__field1),
                        "day" => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(self, __value: &[u8]) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        b"year" => serde::__private::Ok(__Field::__field0),
                        b"month" => serde::__private::Ok(__Field::__field1),
                        b"day" => serde::__private::Ok(__Field::__field2),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: serde::__private::PhantomData<SqlxTypesTimeDateAsNotNullDateOrigin>,
                lifetime: serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SqlxTypesTimeDateAsNotNullDateOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxTypesTimeDateAsNotNullDateOrigin")
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = match serde::de::SeqAccess::next_element::<std::primitive::i32>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxTypesTimeDateAsNotNullDateOrigin with 3 elements"));
                        }
                    };
                    let __field1 = match serde::de::SeqAccess::next_element::<time::Month>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(1usize, &"struct SqlxTypesTimeDateAsNotNullDateOrigin with 3 elements"));
                        }
                    };
                    let __field2 = match serde::de::SeqAccess::next_element::<std::primitive::u8>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(2usize, &"struct SqlxTypesTimeDateAsNotNullDateOrigin with 3 elements"));
                        }
                    };
                    match sqlx::types::time::Date::from_calendar_date(__field0, __field1, __field2) {
                        Ok(value) => {
                            let minimum = sqlx::types::time::Date::from_calendar_date(-4713, time::Month::December, 31).unwrap();
                            if minimum > value {
                                Err(_serde::de::Error::custom(format!("SqlxTypesTimeDate less than minimum postgresql value {value:?}")))
                            } else {
                                _serde::__private::Ok(SqlxTypesTimeDateAsNotNullDateOrigin(value))
                            }
                        }
                        Err(value) => Err(_serde::de::Error::custom(format!("SqlxTypesTimeDate from calendar date {value:?}"))),
                    }
                }
                #[inline]
                fn visit_map<__A>(self, mut __map: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::MapAccess<'de>,
                {
                    let mut __field0: serde::__private::Option<std::primitive::i32> = serde::__private::None;
                    let mut __field1: serde::__private::Option<time::Month> = serde::__private::None;
                    let mut __field2: serde::__private::Option<std::primitive::u8> = serde::__private::None;
                    while let serde::__private::Some(__key) = serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if serde::__private::Option::is_some(&__field0) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"year\""));
                                }
                                __field0 = serde::__private::Some(serde::de::MapAccess::next_value::<std::primitive::i32>(&mut __map)?);
                            }
                            __Field::__field1 => {
                                if serde::__private::Option::is_some(&__field1) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"month\""));
                                }
                                __field1 = serde::__private::Some(serde::de::MapAccess::next_value::<time::Month>(&mut __map)?);
                            }
                            __Field::__field2 => {
                                if serde::__private::Option::is_some(&__field2) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"day\""));
                                }
                                __field2 = serde::__private::Some(serde::de::MapAccess::next_value::<std::primitive::u8>(&mut __map)?);
                            }
                            _ => {
                                let _ = serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        serde::__private::Some(__field0) => __field0,
                        serde::__private::None => serde::__private::de::missing_field("\"year\"")?,
                    };
                    let __field1 = match __field1 {
                        serde::__private::Some(__field1) => __field1,
                        serde::__private::None => serde::__private::de::missing_field("\"month\"")?,
                    };
                    let __field2 = match __field2 {
                        serde::__private::Some(__field2) => __field2,
                        serde::__private::None => serde::__private::de::missing_field("\"day\"")?,
                    };
                    match sqlx::types::time::Date::from_calendar_date(__field0, __field1, __field2) {
                        Ok(value) => {
                            let minimum = sqlx::types::time::Date::from_calendar_date(-4713, time::Month::December, 31).unwrap();
                            if minimum > value {
                                Err(_serde::de::Error::custom(format!("SqlxTypesTimeDate less than minimum postgresql value {value:?}")))
                            } else {
                                _serde::__private::Ok(SqlxTypesTimeDateAsNotNullDateOrigin(value))
                            }
                        }
                        Err(value) => Err(_serde::de::Error::custom(format!("SqlxTypesTimeDate from calendar date {value:?}"))),
                    }
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["year", "month", "day"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "SqlxTypesTimeDateAsNotNullDate",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<SqlxTypesTimeDateAsNotNullDateOrigin>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for SqlxTypesTimeDateAsNotNullDateOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesTimeDateAsNotNullDateOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesTimeDateAsNotNullDateOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::types::time::Date::from_ordinal_date(::core::default::Default::default(), 1).unwrap())
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesTimeDateAsNotNullDateOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::types::time::Date as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::types::time::Date as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesTimeDateAsNotNullDateOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesTimeDateAsNotNullDateOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::types::time::Date as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxTypesTimeDateAsNotNullDateOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::Date as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxTypesTimeDateAsNotNullDateOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} date not null")
    }
}
pub type SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration = SqlxTypesTimeDateAsNotNullDateOrigin;
pub type SqlxTypesTimeDateAsNotNullDateCreate = SqlxTypesTimeDateAsNotNullDateOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesTimeDateAsNotNullDateSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesTimeDateAsNotNullDateSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxTypesTimeDateAsNotNullDateWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxTypesTimeDateAsNotNullDateOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    CurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementCurrentDate),
    GreaterThanCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanCurrentDate),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesTimeDateAsNotNullDateWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::CurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::CurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesTimeDateAsNotNullDateWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesTimeDateAsNotNullDateWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::CurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesTimeDateAsNotNullDateRead(SqlxTypesTimeDateAsNotNullDateOrigin);
impl SqlxTypesTimeDateAsNotNullDateRead {
    pub fn new(value: sqlx::types::time::Date) -> Self {
        Self(SqlxTypesTimeDateAsNotNullDateOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::time::Date) -> Self {
        Self(SqlxTypesTimeDateAsNotNullDateOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesTimeDateAsNotNullDateRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesTimeDateAsNotNullDateRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesTimeDateAsNotNullDateRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesTimeDateAsNotNullDateRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxTypesTimeDateAsNotNullDateOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesTimeDateAsNotNullDateRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxTypesTimeDateAsNotNullDateOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxTypesTimeDateAsNotNullDateOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxTypesTimeDateAsNotNullDateReadInner = sqlx::types::time::Date;
pub type SqlxTypesTimeDateAsNotNullDateUpdate = SqlxTypesTimeDateAsNotNullDateOrigin;
impl crate::PostgresqlType for SqlxTypesTimeDateAsNotNullDate {
    type TableTypeDeclaration = SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration;
    type Create = SqlxTypesTimeDateAsNotNullDateCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxTypesTimeDateAsNotNullDateSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxTypesTimeDateAsNotNullDateWhereElement;
    type Read = SqlxTypesTimeDateAsNotNullDateRead;
    type ReadInner = SqlxTypesTimeDateAsNotNullDateReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxTypesTimeDateAsNotNullDateUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![
            sqlx::types::time::Date::from_calendar_date(1970, time::Month::January, 1).unwrap().into(),
            sqlx::types::time::Date::from_calendar_date(2000, time::Month::February, 29).unwrap().into(),
            sqlx::types::time::Date::from_calendar_date(2024, time::Month::December, 31).unwrap().into(),
            sqlx::types::time::Date::from_calendar_date(9999, time::Month::December, 31).unwrap().into(),
            sqlx::types::time::Date::from_calendar_date(1, time::Month::January, 1).unwrap().into(),
            sqlx::types::time::Date::from_calendar_date(2023, time::Month::June, 15).unwrap().into(),
            sqlx::types::time::Date::from_calendar_date(1900, time::Month::March, 1).unwrap().into(),
            sqlx::types::time::Date::from_calendar_date(2025, time::Month::January, 1).unwrap().into(),
            sqlx::types::time::Date::from_calendar_date(2025, time::Month::July, 15).unwrap().into(),
        ]
    }
}
#[derive(Debug)]
pub struct OptionSqlxTypesTimeDateAsNullableDate;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesTimeDateAsNullableDateOrigin(std::option::Option<SqlxTypesTimeDateAsNotNullDateOrigin>);
impl OptionSqlxTypesTimeDateAsNullableDateOrigin {
    pub fn new(value: std::option::Option<sqlx::types::time::Date>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxTypesTimeDateAsNotNullDateOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::types::time::Date>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxTypesTimeDateAsNullableDateOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesTimeDateAsNullableDateOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesTimeDateAsNullableDateOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesTimeDateAsNullableDateOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxTypesTimeDateAsNotNullDateOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxTypesTimeDateAsNotNullDateOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesTimeDateAsNullableDateOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesTimeDateAsNullableDateOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxTypesTimeDateAsNotNullDateOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxTypesTimeDateAsNullableDateOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::Date as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxTypesTimeDateAsNullableDateOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} date")
    }
}
pub type OptionSqlxTypesTimeDateAsNullableDateTableTypeDeclaration = OptionSqlxTypesTimeDateAsNullableDateOrigin;
pub type OptionSqlxTypesTimeDateAsNullableDateCreate = OptionSqlxTypesTimeDateAsNullableDateOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesTimeDateAsNullableDateSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesTimeDateAsNullableDateSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxTypesTimeDateAsNullableDateWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxTypesTimeDateAsNullableDateOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    CurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementCurrentDate),
    GreaterThanCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanCurrentDate),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxTypesTimeDateAsNullableDateWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::CurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::CurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesTimeDateAsNullableDateWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesTimeDateAsNullableDateWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::CurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesTimeDateAsNullableDateRead(OptionSqlxTypesTimeDateAsNullableDateOrigin);
impl OptionSqlxTypesTimeDateAsNullableDateRead {
    pub fn new(value: std::option::Option<sqlx::types::time::Date>) -> Self {
        Self(OptionSqlxTypesTimeDateAsNullableDateOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesTimeDateAsNullableDateRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesTimeDateAsNullableDateRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesTimeDateAsNullableDateRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesTimeDateAsNullableDateRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxTypesTimeDateAsNullableDateOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesTimeDateAsNullableDateRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxTypesTimeDateAsNullableDateOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxTypesTimeDateAsNullableDateOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxTypesTimeDateAsNullableDateReadInner = std::option::Option<sqlx::types::time::Date>;
pub type OptionSqlxTypesTimeDateAsNullableDateUpdate = OptionSqlxTypesTimeDateAsNullableDateOrigin;
impl crate::PostgresqlType for OptionSqlxTypesTimeDateAsNullableDate {
    type TableTypeDeclaration = OptionSqlxTypesTimeDateAsNullableDateTableTypeDeclaration;
    type Create = OptionSqlxTypesTimeDateAsNullableDateCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxTypesTimeDateAsNullableDateSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxTypesTimeDateAsNullableDateWhereElement;
    type Read = OptionSqlxTypesTimeDateAsNullableDateRead;
    type ReadInner = OptionSqlxTypesTimeDateAsNullableDateReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxTypesTimeDateAsNullableDateUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDate;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin(std::vec::Vec<SqlxTypesTimeDateAsNotNullDateOrigin>);
impl VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin {
    pub fn new(value: std::vec::Vec<sqlx::types::time::Date>) -> Self {
        Self(value.into_iter().map(|element| SqlxTypesTimeDateAsNotNullDateOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::types::time::Date>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxTypesTimeDateAsNotNullDateOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxTypesTimeDateAsNotNullDateOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxTypesTimeDateAsNotNullDateOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::Date as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} date[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateTableTypeDeclaration = VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin;
pub type VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateCreate = VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentDate),
    DimensionOneGreaterThanCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentDate),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRead(VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin);
impl VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRead {
    pub fn new(value: std::vec::Vec<sqlx::types::time::Date>) -> Self {
        Self(VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateReadInner = std::vec::Vec<sqlx::types::time::Date>;
pub type VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateUpdate = VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin;
impl crate::PostgresqlType for VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDate {
    type TableTypeDeclaration = VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateTableTypeDeclaration;
    type Create = VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateWhereElement;
    type Read = VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRead;
    type ReadInner = VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDate;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin(std::option::Option<VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin>);
impl OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::time::Date>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::types::time::Date>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxTypesTimeDateAsNotNullArrayOfNotNullDateOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::Date as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} date[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateTableTypeDeclaration = OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin;
pub type OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateCreate = OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesTimeDateAsNullableDateTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentDate),
    DimensionOneGreaterThanCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentDate),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateRead(OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin);
impl OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::time::Date>>) -> Self {
        Self(OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateReadInner = std::option::Option<std::vec::Vec<sqlx::types::time::Date>>;
pub type OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateUpdate = OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDate {
    type TableTypeDeclaration = OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateTableTypeDeclaration;
    type Create = OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateWhereElement;
    type Read = OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateRead;
    type ReadInner = OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxTypesTimeDateAsNullableArrayOfNotNullDateUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDate;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin(std::vec::Vec<OptionSqlxTypesTimeDateAsNullableDateOrigin>);
impl VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::time::Date>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxTypesTimeDateAsNullableDateOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::types::time::Date>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxTypesTimeDateAsNullableDateOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxTypesTimeDateAsNullableDateOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxTypesTimeDateAsNullableDateOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::Date as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} date[] not null")
    }
}
pub type VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateTableTypeDeclaration = VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin;
pub type VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateCreate = VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentDate),
    DimensionOneGreaterThanCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentDate),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateRead(VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin);
impl VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::time::Date>>) -> Self {
        Self(VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateReadInner = std::vec::Vec<std::option::Option<sqlx::types::time::Date>>;
pub type VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateUpdate = VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDate {
    type TableTypeDeclaration = VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateTableTypeDeclaration;
    type Create = VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateWhereElement;
    type Read = VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateRead;
    type ReadInner = VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDate;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin(std::option::Option<VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin>);
impl OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::time::Date>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::time::Date>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxTypesTimeDateAsNotNullArrayOfNullableDateOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::Date as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} date[]")
    }
}
pub type OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateTableTypeDeclaration = OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin;
pub type OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateCreate = OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesTimeDateAsNullableDateTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesTimeDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentDate),
    DimensionOneGreaterThanCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentDate),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateRead(OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin);
impl OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::time::Date>>>) -> Self {
        Self(OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::time::Date>>>;
pub type OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateUpdate = OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDate {
    type TableTypeDeclaration = OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateWhereElement;
    type Read = OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateRead;
    type ReadInner = OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxTypesTimeDateAsNullableArrayOfNullableDateUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxTypesChronoNaiveDateAsNotNullDate;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoNaiveDateAsNotNullDateOrigin(sqlx::types::chrono::NaiveDate);
impl SqlxTypesChronoNaiveDateAsNotNullDateOrigin {
    pub fn new(value: sqlx::types::chrono::NaiveDate) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::chrono::NaiveDate) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for SqlxTypesChronoNaiveDateAsNotNullDateOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoNaiveDateAsNotNullDateOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoNaiveDateAsNotNullDateOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesChronoNaiveDateAsNotNullDateOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::types::chrono::NaiveDate as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::types::chrono::NaiveDate as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesChronoNaiveDateAsNotNullDateOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesChronoNaiveDateAsNotNullDateOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::types::chrono::NaiveDate as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxTypesChronoNaiveDateAsNotNullDateOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveDate as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxTypesChronoNaiveDateAsNotNullDateOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} date not null")
    }
}
pub type SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration = SqlxTypesChronoNaiveDateAsNotNullDateOrigin;
pub type SqlxTypesChronoNaiveDateAsNotNullDateCreate = SqlxTypesChronoNaiveDateAsNotNullDateOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoNaiveDateAsNotNullDateSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoNaiveDateAsNotNullDateSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxTypesChronoNaiveDateAsNotNullDateWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxTypesChronoNaiveDateAsNotNullDateOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    CurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementCurrentDate),
    GreaterThanCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanCurrentDate),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesChronoNaiveDateAsNotNullDateWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::CurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::CurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoNaiveDateAsNotNullDateWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoNaiveDateAsNotNullDateWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::CurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoNaiveDateAsNotNullDateRead(SqlxTypesChronoNaiveDateAsNotNullDateOrigin);
impl SqlxTypesChronoNaiveDateAsNotNullDateRead {
    pub fn new(value: sqlx::types::chrono::NaiveDate) -> Self {
        Self(SqlxTypesChronoNaiveDateAsNotNullDateOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::chrono::NaiveDate) -> Self {
        Self(SqlxTypesChronoNaiveDateAsNotNullDateOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoNaiveDateAsNotNullDateRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoNaiveDateAsNotNullDateRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesChronoNaiveDateAsNotNullDateRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesChronoNaiveDateAsNotNullDateRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxTypesChronoNaiveDateAsNotNullDateOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesChronoNaiveDateAsNotNullDateRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxTypesChronoNaiveDateAsNotNullDateOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxTypesChronoNaiveDateAsNotNullDateOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxTypesChronoNaiveDateAsNotNullDateReadInner = sqlx::types::chrono::NaiveDate;
pub type SqlxTypesChronoNaiveDateAsNotNullDateUpdate = SqlxTypesChronoNaiveDateAsNotNullDateOrigin;
impl crate::PostgresqlType for SqlxTypesChronoNaiveDateAsNotNullDate {
    type TableTypeDeclaration = SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration;
    type Create = SqlxTypesChronoNaiveDateAsNotNullDateCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxTypesChronoNaiveDateAsNotNullDateSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxTypesChronoNaiveDateAsNotNullDateWhereElement;
    type Read = SqlxTypesChronoNaiveDateAsNotNullDateRead;
    type ReadInner = SqlxTypesChronoNaiveDateAsNotNullDateReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxTypesChronoNaiveDateAsNotNullDateUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![
            sqlx::types::chrono::NaiveDate::from_ymd_opt(1970, 1, 1).unwrap(),
            sqlx::types::chrono::NaiveDate::from_ymd_opt(2000, 2, 29).unwrap(),
            sqlx::types::chrono::NaiveDate::from_ymd_opt(2024, 12, 31).unwrap(),
            sqlx::types::chrono::NaiveDate::from_ymd_opt(1, 1, 1).unwrap(),
            sqlx::types::chrono::NaiveDate::from_ymd_opt(9999, 12, 31).unwrap(),
            sqlx::types::chrono::NaiveDate::from_ymd_opt(2025, 7, 15).unwrap(),
            sqlx::types::chrono::NaiveDate::from_ymd_opt(1900, 3, 1).unwrap(),
            sqlx::types::chrono::NaiveDate::from_ymd_opt(2023, 6, 15).unwrap(),
            sqlx::types::chrono::NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),
        ]
    }
}
#[derive(Debug)]
pub struct OptionSqlxTypesChronoNaiveDateAsNullableDate;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin(std::option::Option<SqlxTypesChronoNaiveDateAsNotNullDateOrigin>);
impl OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin {
    pub fn new(value: std::option::Option<sqlx::types::chrono::NaiveDate>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxTypesChronoNaiveDateAsNotNullDateOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::types::chrono::NaiveDate>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxTypesChronoNaiveDateAsNotNullDateOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxTypesChronoNaiveDateAsNotNullDateOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxTypesChronoNaiveDateAsNotNullDateOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveDate as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} date")
    }
}
pub type OptionSqlxTypesChronoNaiveDateAsNullableDateTableTypeDeclaration = OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin;
pub type OptionSqlxTypesChronoNaiveDateAsNullableDateCreate = OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoNaiveDateAsNullableDateSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoNaiveDateAsNullableDateSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxTypesChronoNaiveDateAsNullableDateWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    CurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementCurrentDate),
    GreaterThanCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanCurrentDate),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxTypesChronoNaiveDateAsNullableDateWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::CurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::CurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoNaiveDateAsNullableDateWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoNaiveDateAsNullableDateWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::CurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoNaiveDateAsNullableDateRead(OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin);
impl OptionSqlxTypesChronoNaiveDateAsNullableDateRead {
    pub fn new(value: std::option::Option<sqlx::types::chrono::NaiveDate>) -> Self {
        Self(OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoNaiveDateAsNullableDateRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoNaiveDateAsNullableDateRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesChronoNaiveDateAsNullableDateRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesChronoNaiveDateAsNullableDateRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesChronoNaiveDateAsNullableDateRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxTypesChronoNaiveDateAsNullableDateReadInner = std::option::Option<sqlx::types::chrono::NaiveDate>;
pub type OptionSqlxTypesChronoNaiveDateAsNullableDateUpdate = OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin;
impl crate::PostgresqlType for OptionSqlxTypesChronoNaiveDateAsNullableDate {
    type TableTypeDeclaration = OptionSqlxTypesChronoNaiveDateAsNullableDateTableTypeDeclaration;
    type Create = OptionSqlxTypesChronoNaiveDateAsNullableDateCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxTypesChronoNaiveDateAsNullableDateSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxTypesChronoNaiveDateAsNullableDateWhereElement;
    type Read = OptionSqlxTypesChronoNaiveDateAsNullableDateRead;
    type ReadInner = OptionSqlxTypesChronoNaiveDateAsNullableDateReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxTypesChronoNaiveDateAsNullableDateUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDate;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin(std::vec::Vec<SqlxTypesChronoNaiveDateAsNotNullDateOrigin>);
impl VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin {
    pub fn new(value: std::vec::Vec<sqlx::types::chrono::NaiveDate>) -> Self {
        Self(value.into_iter().map(|element| SqlxTypesChronoNaiveDateAsNotNullDateOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::types::chrono::NaiveDate>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxTypesChronoNaiveDateAsNotNullDateOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxTypesChronoNaiveDateAsNotNullDateOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxTypesChronoNaiveDateAsNotNullDateOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveDate as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} date[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateTableTypeDeclaration = VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin;
pub type VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateCreate = VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentDate),
    DimensionOneGreaterThanCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentDate),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRead(VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin);
impl VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRead {
    pub fn new(value: std::vec::Vec<sqlx::types::chrono::NaiveDate>) -> Self {
        Self(VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateReadInner = std::vec::Vec<sqlx::types::chrono::NaiveDate>;
pub type VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateUpdate = VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin;
impl crate::PostgresqlType for VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDate {
    type TableTypeDeclaration = VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateTableTypeDeclaration;
    type Create = VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateWhereElement;
    type Read = VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRead;
    type ReadInner = VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDate;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin(std::option::Option<VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin>);
impl OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::NaiveDate>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::NaiveDate>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveDate as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} date[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateTableTypeDeclaration = OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin;
pub type OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateCreate = OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesChronoNaiveDateAsNullableDateTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentDate),
    DimensionOneGreaterThanCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentDate),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRead(OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin);
impl OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::NaiveDate>>) -> Self {
        Self(OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateReadInner = std::option::Option<std::vec::Vec<sqlx::types::chrono::NaiveDate>>;
pub type OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateUpdate = OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDate {
    type TableTypeDeclaration = OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateTableTypeDeclaration;
    type Create = OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateWhereElement;
    type Read = OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRead;
    type ReadInner = OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDate;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin(std::vec::Vec<OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin>);
impl VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDate>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDate>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxTypesChronoNaiveDateAsNullableDateOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveDate as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} date[] not null")
    }
}
pub type VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateTableTypeDeclaration = VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin;
pub type VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateCreate = VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentDate),
    DimensionOneGreaterThanCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentDate),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRead(VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin);
impl VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDate>>) -> Self {
        Self(VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateReadInner = std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDate>>;
pub type VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateUpdate = VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDate {
    type TableTypeDeclaration = VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateTableTypeDeclaration;
    type Create = VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateWhereElement;
    type Read = VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRead;
    type ReadInner = VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDate;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin(std::option::Option<VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin>);
impl OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDate>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDate>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveDate as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} date[]")
    }
}
pub type OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateTableTypeDeclaration = OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin;
pub type OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateCreate = OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesChronoNaiveDateAsNullableDateTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoNaiveDateAsNotNullDateTableTypeDeclaration>),
    DimensionOneCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentDate),
    DimensionOneGreaterThanCurrentDate(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentDate),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentDate(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentDate(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRead(OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin);
impl OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDate>>>) -> Self {
        Self(OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDate>>>;
pub type OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateUpdate = OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDate {
    type TableTypeDeclaration = OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateWhereElement;
    type Read = OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRead;
    type ReadInner = OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin(sqlx::types::chrono::NaiveDateTime);
impl SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin {
    pub fn new(value: sqlx::types::chrono::NaiveDateTime) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::chrono::NaiveDateTime) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::types::chrono::NaiveDateTime as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::types::chrono::NaiveDateTime as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::types::chrono::NaiveDateTime as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveDateTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamp not null")
    }
}
pub type SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration = SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin;
pub type SqlxTypesChronoNaiveDateTimeAsNotNullTimestampCreate = SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoNaiveDateTimeAsNotNullTimestampSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxTypesChronoNaiveDateTimeAsNotNullTimestampWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    CurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementCurrentTimestamp),
    GreaterThanCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanCurrentTimestamp),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::CurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::CurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::CurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoNaiveDateTimeAsNotNullTimestampRead(SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin);
impl SqlxTypesChronoNaiveDateTimeAsNotNullTimestampRead {
    pub fn new(value: sqlx::types::chrono::NaiveDateTime) -> Self {
        Self(SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::chrono::NaiveDateTime) -> Self {
        Self(SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesChronoNaiveDateTimeAsNotNullTimestampRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxTypesChronoNaiveDateTimeAsNotNullTimestampReadInner = sqlx::types::chrono::NaiveDateTime;
pub type SqlxTypesChronoNaiveDateTimeAsNotNullTimestampUpdate = SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin;
impl crate::PostgresqlType for SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp {
    type TableTypeDeclaration = SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration;
    type Create = SqlxTypesChronoNaiveDateTimeAsNotNullTimestampCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxTypesChronoNaiveDateTimeAsNotNullTimestampSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxTypesChronoNaiveDateTimeAsNotNullTimestampWhereElement;
    type Read = SqlxTypesChronoNaiveDateTimeAsNotNullTimestampRead;
    type ReadInner = SqlxTypesChronoNaiveDateTimeAsNotNullTimestampReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxTypesChronoNaiveDateTimeAsNotNullTimestampUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![sqlx::types::chrono::NaiveDateTime::new(sqlx::types::chrono::NaiveDate::from_ymd_opt(1970, 1, 1).unwrap(), sqlx::types::chrono::NaiveTime::from_hms_opt(0, 0, 0).unwrap())]
    }
}
#[derive(Debug)]
pub struct OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestamp;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin(std::option::Option<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin>);
impl OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin {
    pub fn new(value: std::option::Option<sqlx::types::chrono::NaiveDateTime>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::types::chrono::NaiveDateTime>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveDateTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamp")
    }
}
pub type OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampTableTypeDeclaration = OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin;
pub type OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampCreate = OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    CurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementCurrentTimestamp),
    GreaterThanCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanCurrentTimestamp),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::CurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::CurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::CurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampRead(OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin);
impl OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampRead {
    pub fn new(value: std::option::Option<sqlx::types::chrono::NaiveDateTime>) -> Self {
        Self(OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampReadInner = std::option::Option<sqlx::types::chrono::NaiveDateTime>;
pub type OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampUpdate = OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin;
impl crate::PostgresqlType for OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestamp {
    type TableTypeDeclaration = OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampTableTypeDeclaration;
    type Create = OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampWhereElement;
    type Read = OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampRead;
    type ReadInner = OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestamp;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin(std::vec::Vec<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin>);
impl VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    pub fn new(value: std::vec::Vec<sqlx::types::chrono::NaiveDateTime>) -> Self {
        Self(value.into_iter().map(|element| SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::types::chrono::NaiveDateTime>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveDateTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamp[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampTableTypeDeclaration = VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin;
pub type VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampCreate = VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTimestamp),
    DimensionOneGreaterThanCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTimestamp),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRead(VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin);
impl VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRead {
    pub fn new(value: std::vec::Vec<sqlx::types::chrono::NaiveDateTime>) -> Self {
        Self(VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampReadInner = std::vec::Vec<sqlx::types::chrono::NaiveDateTime>;
pub type VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampUpdate = VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin;
impl crate::PostgresqlType for VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestamp {
    type TableTypeDeclaration = VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampTableTypeDeclaration;
    type Create = VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampWhereElement;
    type Read = VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRead;
    type ReadInner = VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestamp;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin(std::option::Option<VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin>);
impl OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::NaiveDateTime>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::NaiveDateTime>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveDateTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamp[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampTableTypeDeclaration = OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin;
pub type OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampCreate = OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTimestamp),
    DimensionOneGreaterThanCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTimestamp),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRead(OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin);
impl OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::NaiveDateTime>>) -> Self {
        Self(OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampReadInner = std::option::Option<std::vec::Vec<sqlx::types::chrono::NaiveDateTime>>;
pub type OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampUpdate = OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestamp {
    type TableTypeDeclaration = OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampTableTypeDeclaration;
    type Create = OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampWhereElement;
    type Read = OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRead;
    type ReadInner = OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestamp;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin(std::vec::Vec<OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin>);
impl VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDateTime>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDateTime>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveDateTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamp[] not null")
    }
}
pub type VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampTableTypeDeclaration = VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin;
pub type VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampCreate = VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTimestamp),
    DimensionOneGreaterThanCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTimestamp),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRead(VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin);
impl VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDateTime>>) -> Self {
        Self(VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampReadInner = std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDateTime>>;
pub type VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampUpdate = VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestamp {
    type TableTypeDeclaration = VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampTableTypeDeclaration;
    type Create = VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampWhereElement;
    type Read = VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRead;
    type ReadInner = VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestamp;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin(std::option::Option<VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin>);
impl OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDateTime>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDateTime>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::NaiveDateTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamp[]")
    }
}
pub type OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampTableTypeDeclaration = OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin;
pub type OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampCreate = OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesChronoNaiveDateTimeAsNullableTimestampTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTimestamp),
    DimensionOneGreaterThanCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTimestamp),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRead(OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin);
impl OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDateTime>>>) -> Self {
        Self(OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::NaiveDateTime>>>;
pub type OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampUpdate = OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestamp {
    type TableTypeDeclaration = OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampWhereElement;
    type Read = OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRead;
    type ReadInner = OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin(sqlx::types::time::PrimitiveDateTime);
impl SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin {
    pub fn new(value: sqlx::types::time::PrimitiveDateTime) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::time::PrimitiveDateTime) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::types::time::PrimitiveDateTime::new(sqlx::types::time::Date::from_ordinal_date(::core::default::Default::default(), 1).unwrap(), sqlx::types::time::Time::MIDNIGHT))
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::types::time::PrimitiveDateTime as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::types::time::PrimitiveDateTime as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::types::time::PrimitiveDateTime as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::PrimitiveDateTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamp not null")
    }
}
pub type SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration = SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin;
pub type SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampCreate = SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    CurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementCurrentTimestamp),
    GreaterThanCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanCurrentTimestamp),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::CurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::CurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::CurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRead(SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin);
impl SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRead {
    pub fn new(value: sqlx::types::time::PrimitiveDateTime) -> Self {
        Self(SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::time::PrimitiveDateTime) -> Self {
        Self(SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampReadInner = sqlx::types::time::PrimitiveDateTime;
pub type SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampUpdate = SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin;
impl crate::PostgresqlType for SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp {
    type TableTypeDeclaration = SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration;
    type Create = SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampWhereElement;
    type Read = SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRead;
    type ReadInner = SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![
            sqlx::types::time::PrimitiveDateTime::new(sqlx::types::time::Date::from_calendar_date(1970, time::Month::January, 1).unwrap(), sqlx::types::time::Time::MIDNIGHT),
            sqlx::types::time::PrimitiveDateTime::new(sqlx::types::time::Date::from_calendar_date(1969, time::Month::December, 31).unwrap(), sqlx::types::time::Time::from_hms(23, 59, 59).unwrap()),
            sqlx::types::time::PrimitiveDateTime::new(sqlx::types::time::Date::from_calendar_date(2000, time::Month::February, 29).unwrap(), sqlx::types::time::Time::from_hms_milli(12, 30, 45, 999).unwrap()),
            sqlx::types::time::PrimitiveDateTime::new(sqlx::types::time::Date::from_calendar_date(9999, time::Month::December, 31).unwrap(), sqlx::types::time::Time::from_hms(23, 59, 59).unwrap()),
            sqlx::types::time::PrimitiveDateTime::new(sqlx::types::time::Date::from_calendar_date(1, time::Month::January, 1).unwrap(), sqlx::types::time::Time::MIDNIGHT),
            sqlx::types::time::PrimitiveDateTime::new(sqlx::types::time::Date::from_calendar_date(2025, time::Month::July, 15).unwrap(), sqlx::types::time::Time::from_hms_micro(15, 45, 30, 123_456).unwrap()),
        ]
    }
}
#[derive(Debug)]
pub struct OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestamp;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin(std::option::Option<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin>);
impl OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin {
    pub fn new(value: std::option::Option<sqlx::types::time::PrimitiveDateTime>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::types::time::PrimitiveDateTime>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::PrimitiveDateTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamp")
    }
}
pub type OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampTableTypeDeclaration = OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin;
pub type OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampCreate = OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    CurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementCurrentTimestamp),
    GreaterThanCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanCurrentTimestamp),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::CurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::CurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::CurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRead(OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin);
impl OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRead {
    pub fn new(value: std::option::Option<sqlx::types::time::PrimitiveDateTime>) -> Self {
        Self(OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampReadInner = std::option::Option<sqlx::types::time::PrimitiveDateTime>;
pub type OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampUpdate = OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin;
impl crate::PostgresqlType for OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestamp {
    type TableTypeDeclaration = OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampTableTypeDeclaration;
    type Create = OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampWhereElement;
    type Read = OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRead;
    type ReadInner = OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestamp;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin(std::vec::Vec<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin>);
impl VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    pub fn new(value: std::vec::Vec<sqlx::types::time::PrimitiveDateTime>) -> Self {
        Self(value.into_iter().map(|element| SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::types::time::PrimitiveDateTime>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::PrimitiveDateTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamp[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampTableTypeDeclaration = VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin;
pub type VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampCreate = VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTimestamp),
    DimensionOneGreaterThanCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTimestamp),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRead(VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin);
impl VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRead {
    pub fn new(value: std::vec::Vec<sqlx::types::time::PrimitiveDateTime>) -> Self {
        Self(VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampReadInner = std::vec::Vec<sqlx::types::time::PrimitiveDateTime>;
pub type VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampUpdate = VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin;
impl crate::PostgresqlType for VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestamp {
    type TableTypeDeclaration = VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampTableTypeDeclaration;
    type Create = VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampWhereElement;
    type Read = VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRead;
    type ReadInner = VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestamp;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin(std::option::Option<VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin>);
impl OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::time::PrimitiveDateTime>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::types::time::PrimitiveDateTime>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::PrimitiveDateTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamp[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampTableTypeDeclaration = OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin;
pub type OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampCreate = OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTimestamp),
    DimensionOneGreaterThanCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTimestamp),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRead(OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin);
impl OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::time::PrimitiveDateTime>>) -> Self {
        Self(OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampReadInner = std::option::Option<std::vec::Vec<sqlx::types::time::PrimitiveDateTime>>;
pub type OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampUpdate = OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestamp {
    type TableTypeDeclaration = OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampTableTypeDeclaration;
    type Create = OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampWhereElement;
    type Read = OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRead;
    type ReadInner = OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestamp;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin(std::vec::Vec<OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin>);
impl VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::time::PrimitiveDateTime>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::types::time::PrimitiveDateTime>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::PrimitiveDateTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamp[] not null")
    }
}
pub type VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampTableTypeDeclaration = VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin;
pub type VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampCreate = VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTimestamp),
    DimensionOneGreaterThanCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTimestamp),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRead(VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin);
impl VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::time::PrimitiveDateTime>>) -> Self {
        Self(VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampReadInner = std::vec::Vec<std::option::Option<sqlx::types::time::PrimitiveDateTime>>;
pub type VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampUpdate = VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestamp {
    type TableTypeDeclaration = VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampTableTypeDeclaration;
    type Create = VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampWhereElement;
    type Read = VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRead;
    type ReadInner = VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestamp;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin(std::option::Option<VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin>);
impl OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::time::PrimitiveDateTime>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::time::PrimitiveDateTime>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::time::PrimitiveDateTime as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamp[]")
    }
}
pub type OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampTableTypeDeclaration = OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin;
pub type OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampCreate = OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesTimePrimitiveDateTimeAsNullableTimestampTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampTableTypeDeclaration>),
    DimensionOneCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneCurrentTimestamp),
    DimensionOneGreaterThanCurrentTimestamp(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanCurrentTimestamp),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanCurrentTimestamp(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanCurrentTimestamp(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRead(OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin);
impl OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::time::PrimitiveDateTime>>>) -> Self {
        Self(OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::time::PrimitiveDateTime>>>;
pub type OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampUpdate = OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestamp {
    type TableTypeDeclaration = OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampWhereElement;
    type Read = OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRead;
    type ReadInner = OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin(sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>);
impl SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin {
    pub fn new(value: sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamptz not null")
    }
}
pub type SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration = SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin;
pub type SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzCreate = SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin>),
    Before(crate::where_element_filters::PostgresqlTypeWhereElementBefore<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Before(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Before(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Before(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRead(SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin);
impl SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRead {
    pub fn new(value: sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>) -> Self {
        Self(SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>) -> Self {
        Self(SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzReadInner = sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>;
pub type SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzUpdate = SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin;
impl crate::PostgresqlType for SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz {
    type TableTypeDeclaration = SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration;
    type Create = SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzWhereElement;
    type Read = SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRead;
    type ReadInner = SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![sqlx::types::chrono::DateTime::<sqlx::types::chrono::Utc>::UNIX_EPOCH]
    }
}
#[derive(Debug)]
pub struct OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTz;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin(std::option::Option<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin>);
impl OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin {
    pub fn new(value: std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamptz")
    }
}
pub type OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzTableTypeDeclaration = OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin;
pub type OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzCreate = OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin>),
    Before(crate::where_element_filters::PostgresqlTypeWhereElementBefore<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Before(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Before(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Before(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRead(OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin);
impl OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRead {
    pub fn new(value: std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>) -> Self {
        Self(OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzReadInner = std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>;
pub type OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzUpdate = OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin;
impl crate::PostgresqlType for OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTz {
    type TableTypeDeclaration = OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzTableTypeDeclaration;
    type Create = OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzWhereElement;
    type Read = OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRead;
    type ReadInner = OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTz;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin(std::vec::Vec<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin>);
impl VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin {
    pub fn new(value: std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>) -> Self {
        Self(value.into_iter().map(|element| SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamptz[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzTableTypeDeclaration = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin;
pub type VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzCreate = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneBefore(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBefore<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBefore(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRead(VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin);
impl VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRead {
    pub fn new(value: std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>) -> Self {
        Self(VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzReadInner = std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>;
pub type VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzUpdate = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin;
impl crate::PostgresqlType for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTz {
    type TableTypeDeclaration = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzTableTypeDeclaration;
    type Create = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzWhereElement;
    type Read = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRead;
    type ReadInner = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTz;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin(std::option::Option<VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin>);
impl OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamptz[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzTableTypeDeclaration = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin;
pub type OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzCreate = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneBefore(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBefore<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBefore(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRead(OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin);
impl OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>) -> Self {
        Self(OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzReadInner = std::option::Option<std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>;
pub type OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzUpdate = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTz {
    type TableTypeDeclaration = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzTableTypeDeclaration;
    type Create = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzWhereElement;
    type Read = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRead;
    type ReadInner = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTz;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin(std::vec::Vec<OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin>);
impl VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamptz[] not null")
    }
}
pub type VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzTableTypeDeclaration = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin;
pub type VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzCreate = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneBefore(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBefore<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBefore(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRead(VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin);
impl VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>) -> Self {
        Self(VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzReadInner = std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>;
pub type VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzUpdate = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTz {
    type TableTypeDeclaration = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzTableTypeDeclaration;
    type Create = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzWhereElement;
    type Read = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRead;
    type ReadInner = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTz;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin(std::option::Option<VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin>);
impl OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamptz[]")
    }
}
pub type OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzTableTypeDeclaration = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin;
pub type OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzCreate = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneBefore(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBefore<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBefore(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRead(OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin);
impl OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>) -> Self {
        Self(OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>;
pub type OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzUpdate = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTz {
    type TableTypeDeclaration = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzWhereElement;
    type Read = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRead;
    type ReadInner = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz;
#[derive(Debug, Clone, PartialEq, PartialOrd, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin(sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>);
impl SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin {
    pub fn new(value: sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Local> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Local> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::types::chrono::DateTime<sqlx::types::chrono::Local> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Local> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamptz not null")
    }
}
pub type SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration = SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin;
pub type SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzCreate = SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin>),
    Before(crate::where_element_filters::PostgresqlTypeWhereElementBefore<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Before(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Before(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Before(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRead(SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin);
impl SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRead {
    pub fn new(value: sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>) -> Self {
        Self(SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>) -> Self {
        Self(SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzReadInner = sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>;
pub type SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzUpdate = SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin;
impl crate::PostgresqlType for SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz {
    type TableTypeDeclaration = SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration;
    type Create = SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzWhereElement;
    type Read = SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRead;
    type ReadInner = SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTz;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin(std::option::Option<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin>);
impl OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin {
    pub fn new(value: std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Local> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamptz")
    }
}
pub type OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzTableTypeDeclaration = OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin;
pub type OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzCreate = OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin>),
    Before(crate::where_element_filters::PostgresqlTypeWhereElementBefore<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
    Between(crate::where_element_filters::PostgresqlTypeWhereElementBetween<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Before(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Before(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::Between(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Before(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::Between(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRead(OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin);
impl OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRead {
    pub fn new(value: std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>) -> Self {
        Self(OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzReadInner = std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>;
pub type OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzUpdate = OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin;
impl crate::PostgresqlType for OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTz {
    type TableTypeDeclaration = OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzTableTypeDeclaration;
    type Create = OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzWhereElement;
    type Read = OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRead;
    type ReadInner = OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTz;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin(std::vec::Vec<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin>);
impl VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin {
    pub fn new(value: std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>) -> Self {
        Self(value.into_iter().map(|element| SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Local> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamptz[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzTableTypeDeclaration = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin;
pub type VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzCreate = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneBefore(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBefore<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBefore(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRead(VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin);
impl VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRead {
    pub fn new(value: std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>) -> Self {
        Self(VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzReadInner = std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>;
pub type VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzUpdate = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin;
impl crate::PostgresqlType for VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTz {
    type TableTypeDeclaration = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzTableTypeDeclaration;
    type Create = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzWhereElement;
    type Read = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRead;
    type ReadInner = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTz;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin(std::option::Option<VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin>);
impl OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Local> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamptz[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzTableTypeDeclaration = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin;
pub type OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzCreate = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneBefore(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBefore<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBefore(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRead(OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin);
impl OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>) -> Self {
        Self(OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzReadInner = std::option::Option<std::vec::Vec<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>;
pub type OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzUpdate = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTz {
    type TableTypeDeclaration = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzTableTypeDeclaration;
    type Create = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzWhereElement;
    type Read = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRead;
    type ReadInner = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTz;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin(std::vec::Vec<OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin>);
impl VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Local> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamptz[] not null")
    }
}
pub type VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzTableTypeDeclaration = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin;
pub type VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzCreate = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneBefore(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBefore<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBefore(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRead(VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin);
impl VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>) -> Self {
        Self(VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzReadInner = std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>;
pub type VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzUpdate = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTz {
    type TableTypeDeclaration = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzTableTypeDeclaration;
    type Create = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzWhereElement;
    type Read = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRead;
    type ReadInner = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTz;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin(std::option::Option<VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin>);
impl OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::chrono::DateTime<sqlx::types::chrono::Local> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} timestamptz[]")
    }
}
pub type OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzTableTypeDeclaration = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin;
pub type OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzCreate = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneBefore(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBefore<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
    DimensionOneBetween(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneBetween<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzTableTypeDeclaration>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBefore(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneBetween(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBefore(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneBetween(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRead(OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin);
impl OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>) -> Self {
        Self(OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>;
pub type OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzUpdate = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTz {
    type TableTypeDeclaration = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzWhereElement;
    type Read = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRead;
    type ReadInner = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresql;
#[derive(Debug, Clone, PartialEq, PartialOrd, Ord, Eq)]
pub struct SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin(sqlx::types::uuid::Uuid);
impl SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin {
    pub fn new(value: sqlx::types::uuid::Uuid) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::uuid::Uuid) -> Self {
        Self::new(value)
    }
}
impl crate::IsStringEmpty for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin {
    fn is_string_empty(&self) -> std::primitive::bool {
        self.0.to_string().is_empty()
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            _serde::Serializer::serialize_newtype_struct(__serializer, "SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin", &self.0.to_string())
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: serde::__private::PhantomData<SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin>,
                lifetime: serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin")
                }
                #[inline]
                fn visit_newtype_struct<__E>(self, __e: __E) -> serde::__private::Result<Self::Value, __E::Error>
                where
                    __E: serde::Deserializer<'de>,
                {
                    let __field0 = <std::string::String as serde::Deserialize>::deserialize(__e)?;
                    serde::__private::Ok(SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin(match sqlx::types::uuid::Uuid::try_parse(&__field0) {
                        Ok(value) => value,
                        Err(error) => {
                            return Err(serde::de::Error::custom(error));
                        }
                    }))
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = match serde::de::SeqAccess::next_element::<std::string::String>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin with 1 elements"));
                        }
                    };
                    serde::__private::Ok(SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin(match sqlx::types::uuid::Uuid::try_parse(&__field0) {
                        Ok(value) => value,
                        Err(error) => {
                            return Err(serde::de::Error::custom(error));
                        }
                    }))
                }
            }
            _serde::Deserializer::deserialize_newtype_struct(
                __deserializer,
                "SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin",
                __Visitor {
                    marker: serde::__private::PhantomData::<SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin>,
                    lifetime: serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::types::uuid::Uuid as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::types::uuid::Uuid as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::types::uuid::Uuid as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::uuid::Uuid as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, is_primary_key: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} uuid not null {}", crate::maybe_primary_key(is_primary_key))
    }
}
impl std::convert::From<SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlRead> for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin {
    fn from(value: SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlRead) -> Self {
        Self::new(<SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresql as crate::PostgresqlType>::into_inner(value))
    }
}
pub type SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlTableTypeDeclaration = SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlCreate(());
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlCreate {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin>),
    RegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, PartialOrd, Ord, Eq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlRead(SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin);
impl SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlRead {
    pub fn new(value: sqlx::types::uuid::Uuid) -> Self {
        Self(SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::uuid::Uuid) -> Self {
        Self(SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlRead {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, _: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                Ok(format!("({} = ${})", column, increment))
            }
            None => Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() }),
        }
    }
    fn query_bind(self, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(self);
        query
    }
}
impl crate::PostgresqlTypePrimaryKey for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresql {
    type PrimaryKey = SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlRead;
}
pub type SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlReadInner = sqlx::types::uuid::Uuid;
pub type SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlUpdate = SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlOrigin;
impl crate::PostgresqlType for SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresql {
    type TableTypeDeclaration = SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlTableTypeDeclaration;
    type Create = SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlCreate;
    fn create_query_part(_: &Self::Create, _: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        Ok(std::string::String::from("uuid_generate_v4()"))
    }
    fn create_query_bind(_: Self::Create, query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query
    }
    type Select = SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlWhereElement;
    type Read = SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlRead;
    type ReadInner = SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxTypesUuidUuidAsNotNullUuidV4InitializedByPostgresqlUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct SqlxTypesUuidUuidAsNotNullUuidInitializedByClient;
#[derive(Debug, Clone, PartialEq)]
pub struct SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin(sqlx::types::uuid::Uuid);
impl SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin {
    pub fn new(value: sqlx::types::uuid::Uuid) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::uuid::Uuid) -> Self {
        Self::new(value)
    }
}
impl crate::IsStringEmpty for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin {
    fn is_string_empty(&self) -> std::primitive::bool {
        self.0.to_string().is_empty()
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            _serde::Serializer::serialize_newtype_struct(__serializer, "SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin", &self.0.to_string())
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: serde::__private::PhantomData<SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin>,
                lifetime: serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin")
                }
                #[inline]
                fn visit_newtype_struct<__E>(self, __e: __E) -> serde::__private::Result<Self::Value, __E::Error>
                where
                    __E: serde::Deserializer<'de>,
                {
                    let __field0 = <std::string::String as serde::Deserialize>::deserialize(__e)?;
                    serde::__private::Ok(SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin(match sqlx::types::uuid::Uuid::try_parse(&__field0) {
                        Ok(value) => value,
                        Err(error) => {
                            return Err(serde::de::Error::custom(error));
                        }
                    }))
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = match serde::de::SeqAccess::next_element::<std::string::String>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin with 1 elements"));
                        }
                    };
                    serde::__private::Ok(SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin(match sqlx::types::uuid::Uuid::try_parse(&__field0) {
                        Ok(value) => value,
                        Err(error) => {
                            return Err(serde::de::Error::custom(error));
                        }
                    }))
                }
            }
            _serde::Deserializer::deserialize_newtype_struct(
                __deserializer,
                "SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin",
                __Visitor {
                    marker: serde::__private::PhantomData::<SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin>,
                    lifetime: serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::types::uuid::Uuid as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::types::uuid::Uuid as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::types::uuid::Uuid as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::uuid::Uuid as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} uuid not null")
    }
}
pub type SqlxTypesUuidUuidAsNotNullUuidInitializedByClientTableTypeDeclaration = SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin;
pub type SqlxTypesUuidUuidAsNotNullUuidInitializedByClientCreate = SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesUuidUuidAsNotNullUuidInitializedByClientSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxTypesUuidUuidAsNotNullUuidInitializedByClientWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin>),
    RegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesUuidUuidAsNotNullUuidInitializedByClientRead(SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin);
impl SqlxTypesUuidUuidAsNotNullUuidInitializedByClientRead {
    pub fn new(value: sqlx::types::uuid::Uuid) -> Self {
        Self(SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::uuid::Uuid) -> Self {
        Self(SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesUuidUuidAsNotNullUuidInitializedByClientRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxTypesUuidUuidAsNotNullUuidInitializedByClientReadInner = sqlx::types::uuid::Uuid;
pub type SqlxTypesUuidUuidAsNotNullUuidInitializedByClientUpdate = SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin;
impl crate::PostgresqlType for SqlxTypesUuidUuidAsNotNullUuidInitializedByClient {
    type TableTypeDeclaration = SqlxTypesUuidUuidAsNotNullUuidInitializedByClientTableTypeDeclaration;
    type Create = SqlxTypesUuidUuidAsNotNullUuidInitializedByClientCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxTypesUuidUuidAsNotNullUuidInitializedByClientSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxTypesUuidUuidAsNotNullUuidInitializedByClientWhereElement;
    type Read = SqlxTypesUuidUuidAsNotNullUuidInitializedByClientRead;
    type ReadInner = SqlxTypesUuidUuidAsNotNullUuidInitializedByClientReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxTypesUuidUuidAsNotNullUuidInitializedByClientUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![sqlx::types::Uuid::new_v4()]
    }
}
#[derive(Debug)]
pub struct OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClient;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin(std::option::Option<SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin>);
impl OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin {
    pub fn new(value: std::option::Option<sqlx::types::uuid::Uuid>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::types::uuid::Uuid>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::uuid::Uuid as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} uuid")
    }
}
pub type OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientTableTypeDeclaration = OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin;
pub type OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientCreate = OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin>),
    RegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientRead(OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin);
impl OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientRead {
    pub fn new(value: std::option::Option<sqlx::types::uuid::Uuid>) -> Self {
        Self(OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientReadInner = std::option::Option<sqlx::types::uuid::Uuid>;
pub type OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientUpdate = OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin;
impl crate::PostgresqlType for OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClient {
    type TableTypeDeclaration = OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientTableTypeDeclaration;
    type Create = OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientWhereElement;
    type Read = OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientRead;
    type ReadInner = OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesUuidUuidAsNotNullUuidInitializedByClient as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxTypesUuidUuidAsNotNullUuidInitializedByClient as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClient;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin(std::vec::Vec<SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin>);
impl VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin {
    pub fn new(value: std::vec::Vec<sqlx::types::uuid::Uuid>) -> Self {
        Self(value.into_iter().map(|element| SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::types::uuid::Uuid>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxTypesUuidUuidAsNotNullUuidInitializedByClientOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::uuid::Uuid as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} uuid[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientTableTypeDeclaration = VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin;
pub type VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientCreate = VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesUuidUuidAsNotNullUuidInitializedByClientTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneRegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientRead(VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin);
impl VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientRead {
    pub fn new(value: std::vec::Vec<sqlx::types::uuid::Uuid>) -> Self {
        Self(VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientReadInner = std::vec::Vec<sqlx::types::uuid::Uuid>;
pub type VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientUpdate = VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin;
impl crate::PostgresqlType for VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClient {
    type TableTypeDeclaration = VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientTableTypeDeclaration;
    type Create = VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientWhereElement;
    type Read = VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientRead;
    type ReadInner = VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxTypesUuidUuidAsNotNullUuidInitializedByClient as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxTypesUuidUuidAsNotNullUuidInitializedByClient as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClient;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin(std::option::Option<VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin>);
impl OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::uuid::Uuid>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::types::uuid::Uuid>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxTypesUuidUuidAsNotNullArrayOfNotNullUuidInitializedByClientOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::uuid::Uuid as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} uuid[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientTableTypeDeclaration = OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin;
pub type OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientCreate = OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneRegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientRead(OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin);
impl OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::uuid::Uuid>>) -> Self {
        Self(OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientReadInner = std::option::Option<std::vec::Vec<sqlx::types::uuid::Uuid>>;
pub type OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientUpdate = OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClient {
    type TableTypeDeclaration = OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientTableTypeDeclaration;
    type Create = OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientWhereElement;
    type Read = OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientRead;
    type ReadInner = OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxTypesUuidUuidAsNullableArrayOfNotNullUuidInitializedByClientUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesUuidUuidAsNotNullUuidInitializedByClient as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxTypesUuidUuidAsNotNullUuidInitializedByClient as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClient;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin(std::vec::Vec<OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin>);
impl VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::uuid::Uuid>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::types::uuid::Uuid>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::uuid::Uuid as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} uuid[] not null")
    }
}
pub type VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientTableTypeDeclaration = VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin;
pub type VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientCreate = VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesUuidUuidAsNotNullUuidInitializedByClientTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneRegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientRead(VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin);
impl VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::uuid::Uuid>>) -> Self {
        Self(VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientReadInner = std::vec::Vec<std::option::Option<sqlx::types::uuid::Uuid>>;
pub type VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientUpdate = VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClient {
    type TableTypeDeclaration = VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientTableTypeDeclaration;
    type Create = VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientWhereElement;
    type Read = VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientRead;
    type ReadInner = VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesUuidUuidAsNotNullUuidInitializedByClient as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxTypesUuidUuidAsNotNullUuidInitializedByClient as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClient;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin(std::option::Option<VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin>);
impl OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::uuid::Uuid>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::uuid::Uuid>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxTypesUuidUuidAsNotNullArrayOfNullableUuidInitializedByClientOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::uuid::Uuid as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} uuid[]")
    }
}
pub type OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientTableTypeDeclaration = OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin;
pub type OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientCreate = OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesUuidUuidAsNullableUuidInitializedByClientTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneRegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientRead(OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin);
impl OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::uuid::Uuid>>>) -> Self {
        Self(OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::uuid::Uuid>>>;
pub type OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientUpdate = OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClient {
    type TableTypeDeclaration = OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientWhereElement;
    type Read = OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientRead;
    type ReadInner = OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxTypesUuidUuidAsNullableArrayOfNullableUuidInitializedByClientUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesUuidUuidAsNotNullUuidInitializedByClient as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxTypesUuidUuidAsNotNullUuidInitializedByClient as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxTypesIpnetworkIpNetworkAsNotNullInet;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin(sqlx::types::ipnetwork::IpNetwork);
impl SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin {
    pub fn new(value: sqlx::types::ipnetwork::IpNetwork) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::ipnetwork::IpNetwork) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::types::ipnetwork::IpNetwork::V4(sqlx::types::ipnetwork::Ipv4Network::new(core::net::Ipv4Addr::UNSPECIFIED, ::core::default::Default::default()).unwrap()))
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::types::ipnetwork::IpNetwork as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::types::ipnetwork::IpNetwork as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::types::ipnetwork::IpNetwork as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::ipnetwork::IpNetwork as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} inet not null")
    }
}
pub type SqlxTypesIpnetworkIpNetworkAsNotNullInetTableTypeDeclaration = SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin;
pub type SqlxTypesIpnetworkIpNetworkAsNotNullInetCreate = SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesIpnetworkIpNetworkAsNotNullInetSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesIpnetworkIpNetworkAsNotNullInetSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxTypesIpnetworkIpNetworkAsNotNullInetWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesIpnetworkIpNetworkAsNotNullInetWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesIpnetworkIpNetworkAsNotNullInetWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesIpnetworkIpNetworkAsNotNullInetWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesIpnetworkIpNetworkAsNotNullInetRead(SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin);
impl SqlxTypesIpnetworkIpNetworkAsNotNullInetRead {
    pub fn new(value: sqlx::types::ipnetwork::IpNetwork) -> Self {
        Self(SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::ipnetwork::IpNetwork) -> Self {
        Self(SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesIpnetworkIpNetworkAsNotNullInetRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesIpnetworkIpNetworkAsNotNullInetRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesIpnetworkIpNetworkAsNotNullInetRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesIpnetworkIpNetworkAsNotNullInetRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesIpnetworkIpNetworkAsNotNullInetRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxTypesIpnetworkIpNetworkAsNotNullInetReadInner = sqlx::types::ipnetwork::IpNetwork;
pub type SqlxTypesIpnetworkIpNetworkAsNotNullInetUpdate = SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin;
impl crate::PostgresqlType for SqlxTypesIpnetworkIpNetworkAsNotNullInet {
    type TableTypeDeclaration = SqlxTypesIpnetworkIpNetworkAsNotNullInetTableTypeDeclaration;
    type Create = SqlxTypesIpnetworkIpNetworkAsNotNullInetCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxTypesIpnetworkIpNetworkAsNotNullInetSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxTypesIpnetworkIpNetworkAsNotNullInetWhereElement;
    type Read = SqlxTypesIpnetworkIpNetworkAsNotNullInetRead;
    type ReadInner = SqlxTypesIpnetworkIpNetworkAsNotNullInetReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxTypesIpnetworkIpNetworkAsNotNullInetUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![
            <sqlx::types::ipnetwork::IpNetwork as std::str::FromStr>::from_str("192.168.0.0/24").unwrap(),
            <sqlx::types::ipnetwork::IpNetwork as std::str::FromStr>::from_str("10.0.0.0/8").unwrap(),
            <sqlx::types::ipnetwork::IpNetwork as std::str::FromStr>::from_str("172.16.0.0/12").unwrap(),
            <sqlx::types::ipnetwork::IpNetwork as std::str::FromStr>::from_str("127.0.0.1/32").unwrap(),
            <sqlx::types::ipnetwork::IpNetwork as std::str::FromStr>::from_str("::1/128").unwrap(),
            <sqlx::types::ipnetwork::IpNetwork as std::str::FromStr>::from_str("2001:db8::/32").unwrap(),
            sqlx::types::ipnetwork::IpNetwork::V4(sqlx::types::ipnetwork::Ipv4Network::new(std::net::Ipv4Addr::new(192, 168, 0, 0), 24).unwrap()),
            sqlx::types::ipnetwork::IpNetwork::V4(sqlx::types::ipnetwork::Ipv4Network::new(std::net::Ipv4Addr::new(10, 0, 0, 0), 8).unwrap()),
            sqlx::types::ipnetwork::IpNetwork::V4(sqlx::types::ipnetwork::Ipv4Network::new(std::net::Ipv4Addr::new(127, 0, 0, 1), 32).unwrap()),
            sqlx::types::ipnetwork::IpNetwork::V6(sqlx::types::ipnetwork::Ipv6Network::new(std::net::Ipv6Addr::LOCALHOST, 128).unwrap()),
            sqlx::types::ipnetwork::IpNetwork::V6(sqlx::types::ipnetwork::Ipv6Network::new("2001:db8::".parse().unwrap(), 32).unwrap()),
        ]
    }
}
#[derive(Debug)]
pub struct OptionSqlxTypesIpnetworkIpNetworkAsNullableInet;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin(std::option::Option<SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin>);
impl OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin {
    pub fn new(value: std::option::Option<sqlx::types::ipnetwork::IpNetwork>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::types::ipnetwork::IpNetwork>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::ipnetwork::IpNetwork as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} inet")
    }
}
pub type OptionSqlxTypesIpnetworkIpNetworkAsNullableInetTableTypeDeclaration = OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin;
pub type OptionSqlxTypesIpnetworkIpNetworkAsNullableInetCreate = OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesIpnetworkIpNetworkAsNullableInetSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxTypesIpnetworkIpNetworkAsNullableInetWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin>),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesIpnetworkIpNetworkAsNullableInetRead(OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin);
impl OptionSqlxTypesIpnetworkIpNetworkAsNullableInetRead {
    pub fn new(value: std::option::Option<sqlx::types::ipnetwork::IpNetwork>) -> Self {
        Self(OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesIpnetworkIpNetworkAsNullableInetRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxTypesIpnetworkIpNetworkAsNullableInetReadInner = std::option::Option<sqlx::types::ipnetwork::IpNetwork>;
pub type OptionSqlxTypesIpnetworkIpNetworkAsNullableInetUpdate = OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin;
impl crate::PostgresqlType for OptionSqlxTypesIpnetworkIpNetworkAsNullableInet {
    type TableTypeDeclaration = OptionSqlxTypesIpnetworkIpNetworkAsNullableInetTableTypeDeclaration;
    type Create = OptionSqlxTypesIpnetworkIpNetworkAsNullableInetCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxTypesIpnetworkIpNetworkAsNullableInetSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxTypesIpnetworkIpNetworkAsNullableInetWhereElement;
    type Read = OptionSqlxTypesIpnetworkIpNetworkAsNullableInetRead;
    type ReadInner = OptionSqlxTypesIpnetworkIpNetworkAsNullableInetReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxTypesIpnetworkIpNetworkAsNullableInetUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesIpnetworkIpNetworkAsNotNullInet as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxTypesIpnetworkIpNetworkAsNotNullInet as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInet;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin(std::vec::Vec<SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin>);
impl VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin {
    pub fn new(value: std::vec::Vec<sqlx::types::ipnetwork::IpNetwork>) -> Self {
        Self(value.into_iter().map(|element| SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::types::ipnetwork::IpNetwork>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxTypesIpnetworkIpNetworkAsNotNullInetOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::ipnetwork::IpNetwork as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} inet[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetTableTypeDeclaration = VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin;
pub type VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetCreate = VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesIpnetworkIpNetworkAsNotNullInetTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetRead(VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin);
impl VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetRead {
    pub fn new(value: std::vec::Vec<sqlx::types::ipnetwork::IpNetwork>) -> Self {
        Self(VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetReadInner = std::vec::Vec<sqlx::types::ipnetwork::IpNetwork>;
pub type VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetUpdate = VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin;
impl crate::PostgresqlType for VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInet {
    type TableTypeDeclaration = VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetTableTypeDeclaration;
    type Create = VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetWhereElement;
    type Read = VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetRead;
    type ReadInner = VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxTypesIpnetworkIpNetworkAsNotNullInet as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxTypesIpnetworkIpNetworkAsNotNullInet as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInet;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin(std::option::Option<VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin>);
impl OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::ipnetwork::IpNetwork>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::types::ipnetwork::IpNetwork>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNotNullInetOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::ipnetwork::IpNetwork as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} inet[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetTableTypeDeclaration = OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin;
pub type OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetCreate = OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesIpnetworkIpNetworkAsNullableInetTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetRead(OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin);
impl OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::ipnetwork::IpNetwork>>) -> Self {
        Self(OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetReadInner = std::option::Option<std::vec::Vec<sqlx::types::ipnetwork::IpNetwork>>;
pub type OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetUpdate = OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInet {
    type TableTypeDeclaration = OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetTableTypeDeclaration;
    type Create = OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetWhereElement;
    type Read = OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetRead;
    type ReadInner = OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNotNullInetUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesIpnetworkIpNetworkAsNotNullInet as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxTypesIpnetworkIpNetworkAsNotNullInet as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInet;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin(std::vec::Vec<OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin>);
impl VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::ipnetwork::IpNetwork>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::types::ipnetwork::IpNetwork>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxTypesIpnetworkIpNetworkAsNullableInetOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::ipnetwork::IpNetwork as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} inet[] not null")
    }
}
pub type VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetTableTypeDeclaration = VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin;
pub type VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetCreate = VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesIpnetworkIpNetworkAsNotNullInetTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetRead(VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin);
impl VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::ipnetwork::IpNetwork>>) -> Self {
        Self(VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetReadInner = std::vec::Vec<std::option::Option<sqlx::types::ipnetwork::IpNetwork>>;
pub type VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetUpdate = VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInet {
    type TableTypeDeclaration = VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetTableTypeDeclaration;
    type Create = VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetWhereElement;
    type Read = VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetRead;
    type ReadInner = VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesIpnetworkIpNetworkAsNotNullInet as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxTypesIpnetworkIpNetworkAsNotNullInet as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInet;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin(std::option::Option<VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin>);
impl OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::ipnetwork::IpNetwork>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::ipnetwork::IpNetwork>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxTypesIpnetworkIpNetworkAsNotNullArrayOfNullableInetOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::ipnetwork::IpNetwork as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} inet[]")
    }
}
pub type OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetTableTypeDeclaration = OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin;
pub type OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetCreate = OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesIpnetworkIpNetworkAsNullableInetTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetRead(OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin);
impl OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::ipnetwork::IpNetwork>>>) -> Self {
        Self(OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::ipnetwork::IpNetwork>>>;
pub type OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetUpdate = OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInet {
    type TableTypeDeclaration = OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetWhereElement;
    type Read = OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetRead;
    type ReadInner = OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxTypesIpnetworkIpNetworkAsNullableArrayOfNullableInetUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesIpnetworkIpNetworkAsNotNullInet as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxTypesIpnetworkIpNetworkAsNotNullInet as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxTypesMacAddressMacAddressAsNotNullMacAddr;
#[derive(Debug, Clone, PartialEq)]
pub struct SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin(sqlx::types::mac_address::MacAddress);
impl SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin {
    pub fn new(value: sqlx::types::mac_address::MacAddress) -> Self {
        Self(value)
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::mac_address::MacAddress) -> Self {
        Self::new(value)
    }
}
impl crate::IsStringEmpty for SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin {
    fn is_string_empty(&self) -> std::primitive::bool {
        self.0.to_string().is_empty()
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            _serde::Serializer::serialize_newtype_struct(__serializer, "SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin", &self.0.bytes())
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: serde::__private::PhantomData<SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin>,
                lifetime: serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin")
                }
                #[inline]
                fn visit_newtype_struct<__E>(self, __e: __E) -> serde::__private::Result<Self::Value, __E::Error>
                where
                    __E: serde::Deserializer<'de>,
                {
                    let __field0 = <[std::primitive::u8; 6] as serde::Deserialize>::deserialize(__e)?;
                    serde::__private::Ok(SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin(sqlx::types::mac_address::MacAddress::new(__field0)))
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = match serde::de::SeqAccess::next_element::<[std::primitive::u8; 6]>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin with 1 elements"));
                        }
                    };
                    serde::__private::Ok(SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin(sqlx::types::mac_address::MacAddress::new(__field0)))
                }
            }
            _serde::Deserializer::deserialize_newtype_struct(
                __deserializer,
                "SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin",
                __Visitor {
                    marker: serde::__private::PhantomData::<SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin>,
                    lifetime: serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(::core::default::Default::default())
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::types::mac_address::MacAddress as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::types::mac_address::MacAddress as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::types::mac_address::MacAddress as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::mac_address::MacAddress as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} macaddr not null")
    }
}
pub type SqlxTypesMacAddressMacAddressAsNotNullMacAddrTableTypeDeclaration = SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin;
pub type SqlxTypesMacAddressMacAddressAsNotNullMacAddrCreate = SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesMacAddressMacAddressAsNotNullMacAddrSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesMacAddressMacAddressAsNotNullMacAddrSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxTypesMacAddressMacAddressAsNotNullMacAddrWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesMacAddressMacAddressAsNotNullMacAddrTableTypeDeclaration>),
    RegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxTypesMacAddressMacAddressAsNotNullMacAddrWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesMacAddressMacAddressAsNotNullMacAddrWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesMacAddressMacAddressAsNotNullMacAddrWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxTypesMacAddressMacAddressAsNotNullMacAddrRead(SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin);
impl SqlxTypesMacAddressMacAddressAsNotNullMacAddrRead {
    pub fn new(value: sqlx::types::mac_address::MacAddress) -> Self {
        Self(SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::types::mac_address::MacAddress) -> Self {
        Self(SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxTypesMacAddressMacAddressAsNotNullMacAddrRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxTypesMacAddressMacAddressAsNotNullMacAddrRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxTypesMacAddressMacAddressAsNotNullMacAddrRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxTypesMacAddressMacAddressAsNotNullMacAddrRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxTypesMacAddressMacAddressAsNotNullMacAddrRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxTypesMacAddressMacAddressAsNotNullMacAddrReadInner = sqlx::types::mac_address::MacAddress;
pub type SqlxTypesMacAddressMacAddressAsNotNullMacAddrUpdate = SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin;
impl crate::PostgresqlType for SqlxTypesMacAddressMacAddressAsNotNullMacAddr {
    type TableTypeDeclaration = SqlxTypesMacAddressMacAddressAsNotNullMacAddrTableTypeDeclaration;
    type Create = SqlxTypesMacAddressMacAddressAsNotNullMacAddrCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxTypesMacAddressMacAddressAsNotNullMacAddrSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxTypesMacAddressMacAddressAsNotNullMacAddrWhereElement;
    type Read = SqlxTypesMacAddressMacAddressAsNotNullMacAddrRead;
    type ReadInner = SqlxTypesMacAddressMacAddressAsNotNullMacAddrReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0
    }
    type Update = SqlxTypesMacAddressMacAddressAsNotNullMacAddrUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![
            sqlx::types::mac_address::MacAddress::new([0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            sqlx::types::mac_address::MacAddress::new([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]),
            sqlx::types::mac_address::MacAddress::new([0x02, 0x00, 0x00, 0x00, 0x00, 0x01]),
            sqlx::types::mac_address::MacAddress::new([0x00, 0x1A, 0x2B, 0x3C, 0x4D, 0x5E]),
            sqlx::types::mac_address::MacAddress::new([0x01, 0x00, 0x5E, 0x00, 0x00, 0xFB]),
            sqlx::types::mac_address::MacAddress::new([0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xFE]),
        ]
    }
}
#[derive(Debug)]
pub struct OptionSqlxTypesMacAddressMacAddressAsNullableMacAddr;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin(std::option::Option<SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin>);
impl OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin {
    pub fn new(value: std::option::Option<sqlx::types::mac_address::MacAddress>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::types::mac_address::MacAddress>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::mac_address::MacAddress as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} macaddr")
    }
}
pub type OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrTableTypeDeclaration = OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin;
pub type OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrCreate = OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin>),
    GreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThan<SqlxTypesMacAddressMacAddressAsNotNullMacAddrTableTypeDeclaration>),
    RegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrRead(OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin);
impl OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrRead {
    pub fn new(value: std::option::Option<sqlx::types::mac_address::MacAddress>) -> Self {
        Self(OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrReadInner = std::option::Option<sqlx::types::mac_address::MacAddress>;
pub type OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrUpdate = OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin;
impl crate::PostgresqlType for OptionSqlxTypesMacAddressMacAddressAsNullableMacAddr {
    type TableTypeDeclaration = OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrTableTypeDeclaration;
    type Create = OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrWhereElement;
    type Read = OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrRead;
    type ReadInner = OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0),
            None => None,
        }
    }
    type Update = OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesMacAddressMacAddressAsNotNullMacAddr as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxTypesMacAddressMacAddressAsNotNullMacAddr as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddr;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin(std::vec::Vec<SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin>);
impl VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin {
    pub fn new(value: std::vec::Vec<sqlx::types::mac_address::MacAddress>) -> Self {
        Self(value.into_iter().map(|element| SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::types::mac_address::MacAddress>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxTypesMacAddressMacAddressAsNotNullMacAddrOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::mac_address::MacAddress as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} macaddr[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrTableTypeDeclaration = VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin;
pub type VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrCreate = VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesMacAddressMacAddressAsNotNullMacAddrTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesMacAddressMacAddressAsNotNullMacAddrTableTypeDeclaration>),
    DimensionOneRegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrRead(VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin);
impl VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrRead {
    pub fn new(value: std::vec::Vec<sqlx::types::mac_address::MacAddress>) -> Self {
        Self(VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrReadInner = std::vec::Vec<sqlx::types::mac_address::MacAddress>;
pub type VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrUpdate = VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin;
impl crate::PostgresqlType for VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddr {
    type TableTypeDeclaration = VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrTableTypeDeclaration;
    type Create = VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrWhereElement;
    type Read = VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrRead;
    type ReadInner = VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value.0.0.into_iter().map(|element| element.0).collect()
    }
    type Update = VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxTypesMacAddressMacAddressAsNotNullMacAddr as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxTypesMacAddressMacAddressAsNotNullMacAddr as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddr;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin(std::option::Option<VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin>);
impl OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::mac_address::MacAddress>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::types::mac_address::MacAddress>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxTypesMacAddressMacAddressAsNotNullArrayOfNotNullMacAddrOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::mac_address::MacAddress as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} macaddr[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrTableTypeDeclaration = OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin;
pub type OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrCreate = OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesMacAddressMacAddressAsNotNullMacAddrTableTypeDeclaration>),
    DimensionOneRegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrRead(OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin);
impl OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::types::mac_address::MacAddress>>) -> Self {
        Self(OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrReadInner = std::option::Option<std::vec::Vec<sqlx::types::mac_address::MacAddress>>;
pub type OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrUpdate = OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddr {
    type TableTypeDeclaration = OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrTableTypeDeclaration;
    type Create = OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrWhereElement;
    type Read = OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrRead;
    type ReadInner = OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(value.0.into_iter().map(|element| element.0).collect()),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxTypesMacAddressMacAddressAsNullableArrayOfNotNullMacAddrUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesMacAddressMacAddressAsNotNullMacAddr as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxTypesMacAddressMacAddressAsNotNullMacAddr as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddr;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin(std::vec::Vec<OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin>);
impl VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::mac_address::MacAddress>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::types::mac_address::MacAddress>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::mac_address::MacAddress as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} macaddr[] not null")
    }
}
pub type VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrTableTypeDeclaration = VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin;
pub type VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrCreate = VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxTypesMacAddressMacAddressAsNotNullMacAddrTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesMacAddressMacAddressAsNotNullMacAddrTableTypeDeclaration>),
    DimensionOneRegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrRead(VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin);
impl VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::types::mac_address::MacAddress>>) -> Self {
        Self(VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrReadInner = std::vec::Vec<std::option::Option<sqlx::types::mac_address::MacAddress>>;
pub type VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrUpdate = VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddr {
    type TableTypeDeclaration = VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrTableTypeDeclaration;
    type Create = VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrWhereElement;
    type Read = VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrRead;
    type ReadInner = VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(value.0),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesMacAddressMacAddressAsNotNullMacAddr as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxTypesMacAddressMacAddressAsNotNullMacAddr as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddr;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin(std::option::Option<VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin>);
impl OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::mac_address::MacAddress>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::mac_address::MacAddress>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxTypesMacAddressMacAddressAsNotNullArrayOfNullableMacAddrOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::types::mac_address::MacAddress as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} macaddr[]")
    }
}
pub type OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrTableTypeDeclaration = OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin;
pub type OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrCreate = OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxTypesMacAddressMacAddressAsNullableMacAddrTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneGreaterThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThan<SqlxTypesMacAddressMacAddressAsNotNullMacAddrTableTypeDeclaration>),
    DimensionOneRegularExpression(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRegularExpression),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRegularExpression(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRegularExpression(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrRead(OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin);
impl OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::mac_address::MacAddress>>>) -> Self {
        Self(OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::types::mac_address::MacAddress>>>;
pub type OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrUpdate = OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddr {
    type TableTypeDeclaration = OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrWhereElement;
    type Read = OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrRead;
    type ReadInner = OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(value.0),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxTypesMacAddressMacAddressAsNullableArrayOfNullableMacAddrUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxTypesMacAddressMacAddressAsNotNullMacAddr as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxTypesMacAddressMacAddressAsNotNullMacAddr as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range;
#[derive(Debug, Clone, PartialEq)]
pub struct SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin(sqlx::postgres::types::PgRange<StdPrimitiveI32AsNotNullInt4Origin>);
impl SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin {
    pub fn new(value: sqlx::postgres::types::PgRange<std::primitive::i32>) -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: match value.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(StdPrimitiveI32AsNotNullInt4Origin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(StdPrimitiveI32AsNotNullInt4Origin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(StdPrimitiveI32AsNotNullInt4Origin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(StdPrimitiveI32AsNotNullInt4Origin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<std::primitive::i32>) -> Self {
        Self::new(value)
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(__serializer, "SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin", false as std::primitive::usize + 1 + 1)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "start", &self.0.start)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "end", &self.0.end)?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            enum Field {
                Start,
                End,
            }
            impl<'de> serde::Deserialize<'de> for Field {
                fn deserialize<D>(__deserializer: D) -> Result<Field, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = Field;
                        fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                            serde::__private::Formatter::write_str(__f, "`start` or `end`")
                        }
                        fn visit_str<E>(self, value: &str) -> Result<Field, E>
                        where
                            E: serde::de::Error,
                        {
                            match value {
                                "start" => Ok(Field::Start),
                                "end" => Ok(Field::End),
                                _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                            }
                        }
                    }
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct SqlxPostgresTypesPgRangeStdPrimitiveI32AsInt4RangeVisitor;
            impl<'de> _serde::de::Visitor<'de> for SqlxPostgresTypesPgRangeStdPrimitiveI32AsInt4RangeVisitor {
                type Value = SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin")
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = __seq.next_element()?.ok_or_else(|| serde::de::Error::invalid_length(0, &self))?;
                    let __field1 = __seq.next_element()?.ok_or_else(|| serde::de::Error::invalid_length(1, &self))?;
                    serde::__private::Ok(SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin(sqlx::postgres::types::PgRange { start: __field0, end: __field1 }))
                }
                #[inline]
                fn visit_map<V>(self, mut map: V) -> Result<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
                {
                    let mut start = None;
                    let mut end = None;
                    while let Some(key) = map.next_key()? {
                        match key {
                            Field::Start => {
                                if start.is_some() {
                                    return Err(serde::de::Error::duplicate_field("start"));
                                }
                                start = Some(map.next_value()?);
                            }
                            Field::End => {
                                if end.is_some() {
                                    return Err(serde::de::Error::duplicate_field("end"));
                                }
                                end = Some(map.next_value()?);
                            }
                        }
                    }
                    let __field0 = start.ok_or_else(|| serde::de::Error::missing_field("\"start\""))?;
                    let __field1 = end.ok_or_else(|| serde::de::Error::missing_field("\"end\""))?;
                    serde::__private::Ok(SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin(sqlx::postgres::types::PgRange { start: __field0, end: __field1 }))
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["start", "end"];
            _serde::Deserializer::deserialize_struct(__deserializer, "SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range", FIELDS, SqlxPostgresTypesPgRangeStdPrimitiveI32AsInt4RangeVisitor)
        }
    }
};
impl std::fmt::Display for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: std::ops::Bound::Included(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            end: std::ops::Bound::Excluded(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        })
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i32> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::postgres::types::PgRange<std::primitive::i32> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::postgres::types::PgRange<std::primitive::i32> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self::new(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i32> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int4range not null")
    }
}
pub type SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration = SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin;
pub type SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeCreate = SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeRead(SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin);
impl SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeRead {
    pub fn new(value: sqlx::postgres::types::PgRange<std::primitive::i32>) -> Self {
        Self(SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<std::primitive::i32>) -> Self {
        Self(SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeReadInner = sqlx::postgres::types::PgRange<std::primitive::i32>;
pub type SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeUpdate = SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin;
impl crate::PostgresqlType for SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range {
    type TableTypeDeclaration = SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration;
    type Create = SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeWhereElement;
    type Read = SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeRead;
    type ReadInner = SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        sqlx::postgres::types::PgRange {
            start: match value.0.0.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.0.0.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        }
    }
    type Update = SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4Range;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin(std::option::Option<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin>);
impl OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i32>>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i32>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i32> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int4range")
    }
}
pub type OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeTableTypeDeclaration = OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin;
pub type OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeCreate = OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeRead(OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin);
impl OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeRead {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i32>>) -> Self {
        Self(OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeReadInner = std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i32>>;
pub type OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeUpdate = OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin;
impl crate::PostgresqlType for OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4Range {
    type TableTypeDeclaration = OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeTableTypeDeclaration;
    type Create = OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeWhereElement;
    type Read = OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeRead;
    type ReadInner = OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeRead(value))),
            None => None,
        }
    }
    type Update = OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4Range;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin(std::vec::Vec<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin>);
impl VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i32>>) -> Self {
        Self(value.into_iter().map(|element| SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i32>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i32> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int4range[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeTableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin;
pub type VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeCreate = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeRead(VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin);
impl VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeRead {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i32>>) -> Self {
        Self(VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeReadInner = std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i32>>;
pub type VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeUpdate = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin;
impl crate::PostgresqlType for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4Range {
    type TableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeTableTypeDeclaration;
    type Create = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeWhereElement;
    type Read = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeRead;
    type ReadInner = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| <SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeRead(element)))
            .collect()
    }
    type Update = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4Range;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin(std::option::Option<VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin>);
impl OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i32>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i32>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNotNullInt4RangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i32> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int4range[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeTableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin;
pub type OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeCreate = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeRead(OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin);
impl OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i32>>>) -> Self {
        Self(OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeReadInner = std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i32>>>;
pub type OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeUpdate = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4Range {
    type TableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeTableTypeDeclaration;
    type Create = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeWhereElement;
    type Read = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeRead;
    type ReadInner = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| <SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeRead(element)))
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNotNullInt4RangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4Range;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin(std::vec::Vec<OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin>);
impl VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i32>>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i32>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i32> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int4range[] not null")
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeTableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin;
pub type VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeCreate = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeRead(VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin);
impl VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i32>>>) -> Self {
        Self(VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeReadInner = std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i32>>>;
pub type VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeUpdate = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4Range {
    type TableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeTableTypeDeclaration;
    type Create = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeWhereElement;
    type Read = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeRead;
    type ReadInner = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeRead(value))),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4Range;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin(std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin>);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i32>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i32>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullArrayOfNullableInt4RangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i32> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int4range[]")
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeTableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeCreate = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableInt4RangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<StdPrimitiveI32AsNotNullInt4 as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeRead(OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i32>>>>) -> Self {
        Self(OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i32>>>>;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeUpdate = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4Range {
    type TableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeWhereElement;
    type Read = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeRead;
    type ReadInner = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4RangeRead(value))),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI32AsNullableArrayOfNullableInt4RangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeStdPrimitiveI32AsNotNullInt4Range as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range;
#[derive(Debug, Clone, PartialEq)]
pub struct SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin(sqlx::postgres::types::PgRange<StdPrimitiveI64AsNotNullInt8Origin>);
impl SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin {
    pub fn new(value: sqlx::postgres::types::PgRange<std::primitive::i64>) -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: match value.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(StdPrimitiveI64AsNotNullInt8Origin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(StdPrimitiveI64AsNotNullInt8Origin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(StdPrimitiveI64AsNotNullInt8Origin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(StdPrimitiveI64AsNotNullInt8Origin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<std::primitive::i64>) -> Self {
        Self::new(value)
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(__serializer, "SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin", false as std::primitive::usize + 1 + 1)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "start", &self.0.start)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "end", &self.0.end)?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            enum Field {
                Start,
                End,
            }
            impl<'de> serde::Deserialize<'de> for Field {
                fn deserialize<D>(__deserializer: D) -> Result<Field, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = Field;
                        fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                            serde::__private::Formatter::write_str(__f, "`start` or `end`")
                        }
                        fn visit_str<E>(self, value: &str) -> Result<Field, E>
                        where
                            E: serde::de::Error,
                        {
                            match value {
                                "start" => Ok(Field::Start),
                                "end" => Ok(Field::End),
                                _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                            }
                        }
                    }
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct SqlxPostgresTypesPgRangeStdPrimitiveI64AsInt8RangeVisitor;
            impl<'de> _serde::de::Visitor<'de> for SqlxPostgresTypesPgRangeStdPrimitiveI64AsInt8RangeVisitor {
                type Value = SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin")
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = __seq.next_element()?.ok_or_else(|| serde::de::Error::invalid_length(0, &self))?;
                    let __field1 = __seq.next_element()?.ok_or_else(|| serde::de::Error::invalid_length(1, &self))?;
                    serde::__private::Ok(SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin(sqlx::postgres::types::PgRange { start: __field0, end: __field1 }))
                }
                #[inline]
                fn visit_map<V>(self, mut map: V) -> Result<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
                {
                    let mut start = None;
                    let mut end = None;
                    while let Some(key) = map.next_key()? {
                        match key {
                            Field::Start => {
                                if start.is_some() {
                                    return Err(serde::de::Error::duplicate_field("start"));
                                }
                                start = Some(map.next_value()?);
                            }
                            Field::End => {
                                if end.is_some() {
                                    return Err(serde::de::Error::duplicate_field("end"));
                                }
                                end = Some(map.next_value()?);
                            }
                        }
                    }
                    let __field0 = start.ok_or_else(|| serde::de::Error::missing_field("\"start\""))?;
                    let __field1 = end.ok_or_else(|| serde::de::Error::missing_field("\"end\""))?;
                    serde::__private::Ok(SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin(sqlx::postgres::types::PgRange { start: __field0, end: __field1 }))
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["start", "end"];
            _serde::Deserializer::deserialize_struct(__deserializer, "SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range", FIELDS, SqlxPostgresTypesPgRangeStdPrimitiveI64AsInt8RangeVisitor)
        }
    }
};
impl std::fmt::Display for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: std::ops::Bound::Included(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            end: std::ops::Bound::Excluded(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        })
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i64> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::postgres::types::PgRange<std::primitive::i64> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::postgres::types::PgRange<std::primitive::i64> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self::new(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i64> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int8range not null")
    }
}
pub type SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration = SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin;
pub type SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeCreate = SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeRead(SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin);
impl SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeRead {
    pub fn new(value: sqlx::postgres::types::PgRange<std::primitive::i64>) -> Self {
        Self(SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<std::primitive::i64>) -> Self {
        Self(SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeReadInner = sqlx::postgres::types::PgRange<std::primitive::i64>;
pub type SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeUpdate = SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin;
impl crate::PostgresqlType for SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range {
    type TableTypeDeclaration = SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration;
    type Create = SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeWhereElement;
    type Read = SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeRead;
    type ReadInner = SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        sqlx::postgres::types::PgRange {
            start: match value.0.0.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.0.0.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        }
    }
    type Update = SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8Range;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin(std::option::Option<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin>);
impl OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i64>>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i64>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i64> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int8range")
    }
}
pub type OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeTableTypeDeclaration = OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin;
pub type OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeCreate = OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeRead(OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin);
impl OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeRead {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i64>>) -> Self {
        Self(OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeReadInner = std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i64>>;
pub type OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeUpdate = OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin;
impl crate::PostgresqlType for OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8Range {
    type TableTypeDeclaration = OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeTableTypeDeclaration;
    type Create = OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeWhereElement;
    type Read = OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeRead;
    type ReadInner = OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeRead(value))),
            None => None,
        }
    }
    type Update = OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8Range;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin(std::vec::Vec<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin>);
impl VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i64>>) -> Self {
        Self(value.into_iter().map(|element| SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i64>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i64> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int8range[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeTableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin;
pub type VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeCreate = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeRead(VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin);
impl VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeRead {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i64>>) -> Self {
        Self(VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeReadInner = std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i64>>;
pub type VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeUpdate = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin;
impl crate::PostgresqlType for VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8Range {
    type TableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeTableTypeDeclaration;
    type Create = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeWhereElement;
    type Read = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeRead;
    type ReadInner = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| <SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeRead(element)))
            .collect()
    }
    type Update = VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8Range;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin(std::option::Option<VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin>);
impl OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i64>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i64>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNotNullInt8RangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i64> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int8range[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeTableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin;
pub type OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeCreate = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeRead(OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin);
impl OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i64>>>) -> Self {
        Self(OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeReadInner = std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<std::primitive::i64>>>;
pub type OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeUpdate = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8Range {
    type TableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeTableTypeDeclaration;
    type Create = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeWhereElement;
    type Read = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeRead;
    type ReadInner = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| <SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeRead(element)))
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNotNullInt8RangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8Range;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin(std::vec::Vec<OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin>);
impl VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i64>>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i64>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i64> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int8range[] not null")
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeTableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin;
pub type VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeCreate = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeRead(VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin);
impl VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i64>>>) -> Self {
        Self(VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeReadInner = std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i64>>>;
pub type VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeUpdate = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8Range {
    type TableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeTableTypeDeclaration;
    type Create = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeWhereElement;
    type Read = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeRead;
    type ReadInner = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeRead(value))),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8Range;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin(std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin>);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i64>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i64>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullArrayOfNullableInt8RangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<std::primitive::i64> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} int8range[]")
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeTableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeCreate = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableInt8RangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<StdPrimitiveI64AsNotNullInt8 as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeRead(OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i64>>>>) -> Self {
        Self(OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<std::primitive::i64>>>>;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeUpdate = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8Range {
    type TableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeWhereElement;
    type Read = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeRead;
    type ReadInner = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8RangeRead(value))),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxPostgresTypesPgRangeStdPrimitiveI64AsNullableArrayOfNullableInt8RangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeStdPrimitiveI64AsNotNullInt8Range as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange;
#[derive(Debug, Clone, PartialEq)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin(sqlx::postgres::types::PgRange<SqlxTypesBigDecimalAsNotNullNumericOrigin>);
impl SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>) -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: match value.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesBigDecimalAsNotNullNumericOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesBigDecimalAsNotNullNumericOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesBigDecimalAsNotNullNumericOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesBigDecimalAsNotNullNumericOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>) -> Self {
        Self::new(value)
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(__serializer, "SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin", false as std::primitive::usize + 1 + 1)?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "start",
                &match &self.0.start.clone() {
                    std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                    std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                    std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                },
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "end",
                &match &self.0.end.clone() {
                    std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                    std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                    std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                },
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        0u64 => serde::__private::Ok(__Field::__field0),
                        1u64 => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(self, __value: &str) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "start" => _serde::__private::Ok(__Field::__field0),
                        "end" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(self, __value: &[u8]) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        b"start" => serde::__private::Ok(__Field::__field0),
                        b"end" => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: serde::__private::PhantomData<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin>,
                lifetime: serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin")
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesBigDecimalAsNotNullNumericOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin with 2 elements"));
                        }
                    };
                    let __field1 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesBigDecimalAsNotNullNumericOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(1usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin with 2 elements"));
                        }
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin(sqlx::postgres::types::PgRange {
                        start: match __field0 {
                            std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                            std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                            std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                        },
                        end: match __field1 {
                            std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                            std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                            std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                        },
                    }))
                }
                #[inline]
                fn visit_map<__A>(self, mut __map: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::MapAccess<'de>,
                {
                    let mut __field0: serde::__private::Option<std::collections::Bound<SqlxTypesBigDecimalAsNotNullNumericOrigin>> = serde::__private::None;
                    let mut __field1: serde::__private::Option<std::collections::Bound<SqlxTypesBigDecimalAsNotNullNumericOrigin>> = serde::__private::None;
                    while let serde::__private::Some(__key) = serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if serde::__private::Option::is_some(&__field0) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"start\""));
                                }
                                __field0 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesBigDecimalAsNotNullNumericOrigin>>(&mut __map)?);
                            }
                            __Field::__field1 => {
                                if serde::__private::Option::is_some(&__field1) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"end\""));
                                }
                                __field1 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesBigDecimalAsNotNullNumericOrigin>>(&mut __map)?);
                            }
                            _ => {
                                let _ = serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        serde::__private::Some(__field0) => __field0,
                        serde::__private::None => serde::__private::de::missing_field("\"start\"")?,
                    };
                    let __field1 = match __field1 {
                        serde::__private::Some(__field1) => __field1,
                        serde::__private::None => serde::__private::de::missing_field("\"end\"")?,
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin(sqlx::postgres::types::PgRange {
                        start: match __field0 {
                            std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                            std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                            std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                        },
                        end: match __field1 {
                            std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                            std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                            std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                        },
                    }))
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["start", "end"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: std::ops::Bound::Included(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            end: std::ops::Bound::Excluded(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        })
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::BigDecimal> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::postgres::types::PgRange<sqlx::types::BigDecimal> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::postgres::types::PgRange<sqlx::types::BigDecimal> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self::new(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::BigDecimal> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} numrange not null")
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin;
pub type SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeCreate = SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeRead(SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin);
impl SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeRead {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeReadInner = sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>;
pub type SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeUpdate = SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin;
impl crate::PostgresqlType for SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange {
    type TableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration;
    type Create = SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeWhereElement;
    type Read = SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeRead;
    type ReadInner = SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        sqlx::postgres::types::PgRange {
            start: match value.0.0.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.0.0.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        }
    }
    type Update = SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin(std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin>);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::BigDecimal> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} numrange")
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeTableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeCreate = OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeRead(OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeRead {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>) -> Self {
        Self(OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeReadInner = std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeUpdate = OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin;
impl crate::PostgresqlType for OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRange {
    type TableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeTableTypeDeclaration;
    type Create = OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeWhereElement;
    type Read = OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeRead;
    type ReadInner = OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeRead(value))),
            None => None,
        }
    }
    type Update = OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin(std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin>);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>) -> Self {
        Self(value.into_iter().map(|element| SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::BigDecimal> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} numrange[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeTableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeCreate = VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeRead(VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeRead {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>) -> Self {
        Self(VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeReadInner = std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeUpdate = VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin;
impl crate::PostgresqlType for VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRange {
    type TableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeTableTypeDeclaration;
    type Create = VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeWhereElement;
    type Read = VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeRead;
    type ReadInner = VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeRead(element)))
            .collect()
    }
    type Update = VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin(std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin>);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNotNullNumRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::BigDecimal> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} numrange[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeTableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeCreate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeRead(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>>) -> Self {
        Self(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeReadInner = std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>>;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeUpdate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRange {
    type TableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeTableTypeDeclaration;
    type Create = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeWhereElement;
    type Read = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeRead;
    type ReadInner = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeRead(element)))
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNotNullNumRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin(std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin>);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::BigDecimal> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} numrange[] not null")
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeTableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeCreate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeRead(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>>) -> Self {
        Self(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeReadInner = std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>>;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeUpdate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRange {
    type TableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeTableTypeDeclaration;
    type Create = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeWhereElement;
    type Read = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeRead;
    type ReadInner = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeRead(value))),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin(std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin>);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullArrayOfNullableNumRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::BigDecimal> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} numrange[]")
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeTableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeCreate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableNumRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesBigDecimalAsNotNullNumeric as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeRead(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>>>) -> Self {
        Self(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::BigDecimal>>>>;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeUpdate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRange {
    type TableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeWhereElement;
    type Read = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeRead;
    type ReadInner = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRangeRead(value))),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNullableArrayOfNullableNumRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesBigDecimalAsNotNullNumRange as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange;
#[derive(Debug, Clone, PartialEq)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin(sqlx::postgres::types::PgRange<SqlxTypesTimeDateAsNotNullDateOrigin>);
impl SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::time::Date>) -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: match value.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesTimeDateAsNotNullDateOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesTimeDateAsNotNullDateOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesTimeDateAsNotNullDateOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesTimeDateAsNotNullDateOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::time::Date>) -> Self {
        Self::new(value)
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(__serializer, "SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin", false as std::primitive::usize + 1 + 1)?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "start",
                &match &self.0.start {
                    std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                    std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                    std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                },
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "end",
                &match &self.0.end {
                    std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                    std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                    std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                },
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        0u64 => serde::__private::Ok(__Field::__field0),
                        1u64 => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(self, __value: &str) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "start" => _serde::__private::Ok(__Field::__field0),
                        "end" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(self, __value: &[u8]) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        b"start" => serde::__private::Ok(__Field::__field0),
                        b"end" => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: serde::__private::PhantomData<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin>,
                lifetime: serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin")
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesTimeDateAsNotNullDateOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin with 2 elements"));
                        }
                    };
                    let __field1 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesTimeDateAsNotNullDateOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(1usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin with 2 elements"));
                        }
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin(sqlx::postgres::types::PgRange {
                        start: match __field0 {
                            std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                            std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                            std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                        },
                        end: match __field1 {
                            std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                            std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                            std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                        },
                    }))
                }
                #[inline]
                fn visit_map<__A>(self, mut __map: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::MapAccess<'de>,
                {
                    let mut __field0: serde::__private::Option<std::collections::Bound<SqlxTypesTimeDateAsNotNullDateOrigin>> = serde::__private::None;
                    let mut __field1: serde::__private::Option<std::collections::Bound<SqlxTypesTimeDateAsNotNullDateOrigin>> = serde::__private::None;
                    while let serde::__private::Some(__key) = serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if serde::__private::Option::is_some(&__field0) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"start\""));
                                }
                                __field0 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesTimeDateAsNotNullDateOrigin>>(&mut __map)?);
                            }
                            __Field::__field1 => {
                                if serde::__private::Option::is_some(&__field1) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"end\""));
                                }
                                __field1 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesTimeDateAsNotNullDateOrigin>>(&mut __map)?);
                            }
                            _ => {
                                let _ = serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        serde::__private::Some(__field0) => __field0,
                        serde::__private::None => serde::__private::de::missing_field("\"start\"")?,
                    };
                    let __field1 = match __field1 {
                        serde::__private::Some(__field1) => __field1,
                        serde::__private::None => serde::__private::de::missing_field("\"end\"")?,
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin(sqlx::postgres::types::PgRange {
                        start: match __field0 {
                            std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                            std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                            std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                        },
                        end: match __field1 {
                            std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                            std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                            std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                        },
                    }))
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["start", "end"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: std::ops::Bound::Included(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            end: std::ops::Bound::Excluded(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        })
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::Date> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::postgres::types::PgRange<sqlx::types::time::Date> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::postgres::types::PgRange<sqlx::types::time::Date> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self::new(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::Date> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} daterange not null")
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin;
pub type SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeCreate = SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeRead(SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin);
impl SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeRead {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::time::Date>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::time::Date>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeReadInner = sqlx::postgres::types::PgRange<sqlx::types::time::Date>;
pub type SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeUpdate = SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin;
impl crate::PostgresqlType for SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange {
    type TableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration;
    type Create = SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeWhereElement;
    type Read = SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeRead;
    type ReadInner = SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        sqlx::postgres::types::PgRange {
            start: match value.0.0.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.0.0.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        }
    }
    type Update = SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin(std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin>);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::Date> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} daterange")
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeTableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeCreate = OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeRead(OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeRead {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>) -> Self {
        Self(OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeReadInner = std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeUpdate = OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin;
impl crate::PostgresqlType for OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRange {
    type TableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeTableTypeDeclaration;
    type Create = OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeWhereElement;
    type Read = OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeRead;
    type ReadInner = OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeRead(value))),
            None => None,
        }
    }
    type Update = OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin(std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin>);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>) -> Self {
        Self(value.into_iter().map(|element| SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::Date> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} daterange[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeTableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeCreate = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeRead(VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeRead {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>) -> Self {
        Self(VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeReadInner = std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeUpdate = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin;
impl crate::PostgresqlType for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRange {
    type TableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeTableTypeDeclaration;
    type Create = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeWhereElement;
    type Read = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeRead;
    type ReadInner = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeRead(element)))
            .collect()
    }
    type Update = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin(std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin>);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNotNullDateRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::Date> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} daterange[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeTableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeCreate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeRead(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>>) -> Self {
        Self(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeReadInner = std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>>;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeUpdate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRange {
    type TableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeTableTypeDeclaration;
    type Create = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeWhereElement;
    type Read = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeRead;
    type ReadInner = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeRead(element)))
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNotNullDateRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin(std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin>);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::Date> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} daterange[] not null")
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeTableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeCreate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeRead(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>>) -> Self {
        Self(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeReadInner = std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>>;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeUpdate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRange {
    type TableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeTableTypeDeclaration;
    type Create = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeWhereElement;
    type Read = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeRead;
    type ReadInner = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeRead(value))),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin(std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin>);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullArrayOfNullableDateRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::Date> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} daterange[]")
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeTableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeCreate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableDateRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesTimeDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeRead(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>>>) -> Self {
        Self(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::Date>>>>;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeUpdate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRange {
    type TableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeWhereElement;
    type Read = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeRead;
    type ReadInner = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRangeRead(value))),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNullableArrayOfNullableDateRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesTimeDateAsNotNullDateRange as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange;
#[derive(Debug, Clone, PartialEq)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin(sqlx::postgres::types::PgRange<SqlxTypesChronoNaiveDateAsNotNullDateOrigin>);
impl SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>) -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: match value.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesChronoNaiveDateAsNotNullDateOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesChronoNaiveDateAsNotNullDateOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesChronoNaiveDateAsNotNullDateOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesChronoNaiveDateAsNotNullDateOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>) -> Self {
        Self::new(value)
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(__serializer, "SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin", false as std::primitive::usize + 1 + 1)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "start", &self.0.start)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "end", &self.0.end)?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        0u64 => serde::__private::Ok(__Field::__field0),
                        1u64 => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(self, __value: &str) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "start" => _serde::__private::Ok(__Field::__field0),
                        "end" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(self, __value: &[u8]) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        b"start" => serde::__private::Ok(__Field::__field0),
                        b"end" => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: serde::__private::PhantomData<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin>,
                lifetime: serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin")
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesChronoNaiveDateAsNotNullDateOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin with 2 elements"));
                        }
                    };
                    let __field1 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesChronoNaiveDateAsNotNullDateOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(1usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin with 2 elements"));
                        }
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin(sqlx::postgres::types::PgRange { start: __field0, end: __field1 }))
                }
                #[inline]
                fn visit_map<__A>(self, mut __map: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::MapAccess<'de>,
                {
                    let mut __field0: serde::__private::Option<std::collections::Bound<SqlxTypesChronoNaiveDateAsNotNullDateOrigin>> = serde::__private::None;
                    let mut __field1: serde::__private::Option<std::collections::Bound<SqlxTypesChronoNaiveDateAsNotNullDateOrigin>> = serde::__private::None;
                    while let serde::__private::Some(__key) = serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if serde::__private::Option::is_some(&__field0) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"start\""));
                                }
                                __field0 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesChronoNaiveDateAsNotNullDateOrigin>>(&mut __map)?);
                            }
                            __Field::__field1 => {
                                if serde::__private::Option::is_some(&__field1) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"end\""));
                                }
                                __field1 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesChronoNaiveDateAsNotNullDateOrigin>>(&mut __map)?);
                            }
                            _ => {
                                let _ = serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        serde::__private::Some(__field0) => __field0,
                        serde::__private::None => serde::__private::de::missing_field("\"start\"")?,
                    };
                    let __field1 = match __field1 {
                        serde::__private::Some(__field1) => __field1,
                        serde::__private::None => serde::__private::de::missing_field("\"end\"")?,
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin(sqlx::postgres::types::PgRange { start: __field0, end: __field1 }))
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["start", "end"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: std::ops::Bound::Included(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            end: std::ops::Bound::Excluded(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        })
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self::new(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} daterange not null")
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin;
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeCreate = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeRead(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin);
impl SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeRead {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeReadInner = sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>;
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeUpdate = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin;
impl crate::PostgresqlType for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange {
    type TableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration;
    type Create = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeWhereElement;
    type Read = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeRead;
    type ReadInner = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        sqlx::postgres::types::PgRange {
            start: match value.0.0.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.0.0.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        }
    }
    type Update = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin(std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin>);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} daterange")
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeTableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeCreate = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeRead(OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeRead {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>) -> Self {
        Self(OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeReadInner = std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeUpdate = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin;
impl crate::PostgresqlType for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRange {
    type TableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeTableTypeDeclaration;
    type Create = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeWhereElement;
    type Read = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeRead;
    type ReadInner = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeRead(
                value,
            ))),
            None => None,
        }
    }
    type Update = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin(std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin>);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>) -> Self {
        Self(value.into_iter().map(|element| SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} daterange[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeTableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeCreate = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeRead(VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeRead {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>) -> Self {
        Self(VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeReadInner = std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeUpdate = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin;
impl crate::PostgresqlType for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRange {
    type TableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeTableTypeDeclaration;
    type Create = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeWhereElement;
    type Read = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeRead;
    type ReadInner = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeRead(element)))
            .collect()
    }
    type Update = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin(std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin>);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNotNullDateRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} daterange[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeTableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeCreate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeRead(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>>) -> Self {
        Self(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeReadInner = std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>>;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeUpdate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRange {
    type TableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeTableTypeDeclaration;
    type Create = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeWhereElement;
    type Read = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeRead;
    type ReadInner = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeRead(element)))
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNotNullDateRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin(std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin>);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} daterange[] not null")
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeTableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeCreate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeRead(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>>) -> Self {
        Self(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeReadInner = std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>>;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeUpdate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRange {
    type TableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeTableTypeDeclaration;
    type Create = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeWhereElement;
    type Read = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeRead;
    type ReadInner = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeRead(
                    value,
                ))),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin(std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin>);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullArrayOfNullableDateRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} daterange[]")
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeTableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeCreate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableDateRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoNaiveDateAsNotNullDate as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeRead(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>>>) -> Self {
        Self(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDate>>>>;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeUpdate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRange {
    type TableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeWhereElement;
    type Read = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeRead;
    type ReadInner = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRangeRead(
                            value,
                        ))),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNullableArrayOfNullableDateRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateAsNotNullDateRange as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange;
#[derive(Debug, Clone, PartialEq)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin(sqlx::postgres::types::PgRange<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin>);
impl SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>) -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: match value.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>) -> Self {
        Self::new(value)
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(__serializer, "SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin", false as std::primitive::usize + 1 + 1)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "start", &self.0.start)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "end", &self.0.end)?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        0u64 => serde::__private::Ok(__Field::__field0),
                        1u64 => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(self, __value: &str) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "start" => _serde::__private::Ok(__Field::__field0),
                        "end" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(self, __value: &[u8]) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        b"start" => serde::__private::Ok(__Field::__field0),
                        b"end" => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: serde::__private::PhantomData<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin>,
                lifetime: serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin")
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin with 2 elements"));
                        }
                    };
                    let __field1 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(1usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin with 2 elements"));
                        }
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin(sqlx::postgres::types::PgRange { start: __field0, end: __field1 }))
                }
                #[inline]
                fn visit_map<__A>(self, mut __map: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::MapAccess<'de>,
                {
                    let mut __field0: serde::__private::Option<std::collections::Bound<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin>> = serde::__private::None;
                    let mut __field1: serde::__private::Option<std::collections::Bound<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin>> = serde::__private::None;
                    while let serde::__private::Some(__key) = serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if serde::__private::Option::is_some(&__field0) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"start\""));
                                }
                                __field0 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin>>(&mut __map)?);
                            }
                            __Field::__field1 => {
                                if serde::__private::Option::is_some(&__field1) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"end\""));
                                }
                                __field1 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesChronoNaiveDateTimeAsNotNullTimestampOrigin>>(&mut __map)?);
                            }
                            _ => {
                                let _ = serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        serde::__private::Some(__field0) => __field0,
                        serde::__private::None => serde::__private::de::missing_field("\"start\"")?,
                    };
                    let __field1 = match __field1 {
                        serde::__private::Some(__field1) => __field1,
                        serde::__private::None => serde::__private::de::missing_field("\"end\"")?,
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin(sqlx::postgres::types::PgRange { start: __field0, end: __field1 }))
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["start", "end"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: std::ops::Bound::Included(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            end: std::ops::Bound::Excluded(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        })
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self::new(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tsrange not null")
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin;
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeCreate = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeRead(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin);
impl SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeRead {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeReadInner = sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>;
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeUpdate = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin;
impl crate::PostgresqlType for SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange {
    type TableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration;
    type Create = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeWhereElement;
    type Read = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeRead;
    type ReadInner = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        sqlx::postgres::types::PgRange {
            start: match value.0.0.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.0.0.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        }
    }
    type Update = SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin(std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin>);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tsrange")
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeTableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeCreate = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeRead(OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeRead {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>) -> Self {
        Self(OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeReadInner = std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeUpdate = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin;
impl crate::PostgresqlType for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRange {
    type TableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeTableTypeDeclaration;
    type Create = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeWhereElement;
    type Read = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeRead;
    type ReadInner = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::into_inner(
                SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeRead(value),
            )),
            None => None,
        }
    }
    type Update = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin(std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin>);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>) -> Self {
        Self(value.into_iter().map(|element| SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tsrange[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeTableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeCreate = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead(VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>) -> Self {
        Self(VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeReadInner = std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeUpdate = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin;
impl crate::PostgresqlType for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRange {
    type TableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeTableTypeDeclaration;
    type Create = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeWhereElement;
    type Read = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead;
    type ReadInner = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeRead(element)))
            .collect()
    }
    type Update = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin(std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin>);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tsrange[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeTableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeCreate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>>) -> Self {
        Self(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeReadInner = std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>>;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeUpdate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRange {
    type TableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeTableTypeDeclaration;
    type Create = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeWhereElement;
    type Read = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead;
    type ReadInner = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeRead(element)))
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNotNullTimestampRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin(std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin>);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tsrange[] not null")
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeTableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeCreate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>>) -> Self {
        Self(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeReadInner = std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>>;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeUpdate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRange {
    type TableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeTableTypeDeclaration;
    type Create = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeWhereElement;
    type Read = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead;
    type ReadInner = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::into_inner(
                    SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeRead(value),
                )),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin(std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin>);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tsrange[]")
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeTableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeCreate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableTimestampRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoNaiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeRead(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>>>) -> Self {
        Self(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::NaiveDateTime>>>>;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeUpdate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRange {
    type TableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeWhereElement;
    type Read = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeRead;
    type ReadInner = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::into_inner(
                            SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRangeRead(value),
                        )),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNullableArrayOfNullableTimestampRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesChronoNaiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange;
#[derive(Debug, Clone, PartialEq)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin(sqlx::postgres::types::PgRange<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin>);
impl SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>) -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: match value.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>) -> Self {
        Self::new(value)
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(__serializer, "SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin", false as std::primitive::usize + 1 + 1)?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "start",
                &match &self.0.start {
                    std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                    std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                    std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                },
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "end",
                &match &self.0.end {
                    std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                    std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                    std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                },
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        0u64 => serde::__private::Ok(__Field::__field0),
                        1u64 => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(self, __value: &str) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "start" => _serde::__private::Ok(__Field::__field0),
                        "end" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(self, __value: &[u8]) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        b"start" => serde::__private::Ok(__Field::__field0),
                        b"end" => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: serde::__private::PhantomData<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin>,
                lifetime: serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin")
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin with 2 elements"));
                        }
                    };
                    let __field1 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(1usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin with 2 elements"));
                        }
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin(sqlx::postgres::types::PgRange {
                        start: match __field0 {
                            std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                            std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                            std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                        },
                        end: match __field1 {
                            std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                            std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                            std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                        },
                    }))
                }
                #[inline]
                fn visit_map<__A>(self, mut __map: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::MapAccess<'de>,
                {
                    let mut __field0: serde::__private::Option<std::collections::Bound<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin>> = serde::__private::None;
                    let mut __field1: serde::__private::Option<std::collections::Bound<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin>> = serde::__private::None;
                    while let serde::__private::Some(__key) = serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if serde::__private::Option::is_some(&__field0) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"start\""));
                                }
                                __field0 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin>>(&mut __map)?);
                            }
                            __Field::__field1 => {
                                if serde::__private::Option::is_some(&__field1) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"end\""));
                                }
                                __field1 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestampOrigin>>(&mut __map)?);
                            }
                            _ => {
                                let _ = serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        serde::__private::Some(__field0) => __field0,
                        serde::__private::None => serde::__private::de::missing_field("\"start\"")?,
                    };
                    let __field1 = match __field1 {
                        serde::__private::Some(__field1) => __field1,
                        serde::__private::None => serde::__private::de::missing_field("\"end\"")?,
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin(sqlx::postgres::types::PgRange {
                        start: match __field0 {
                            std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                            std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                            std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                        },
                        end: match __field1 {
                            std::collections::Bound::Included(value) => std::collections::Bound::Included(value),
                            std::collections::Bound::Excluded(value) => std::collections::Bound::Excluded(value),
                            std::collections::Bound::Unbounded => std::collections::Bound::Unbounded,
                        },
                    }))
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["start", "end"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: std::ops::Bound::Included(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            end: std::ops::Bound::Excluded(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        })
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self::new(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tsrange not null")
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin;
pub type SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeCreate = SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeRead(SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin);
impl SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeRead {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeReadInner = sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>;
pub type SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeUpdate = SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin;
impl crate::PostgresqlType for SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange {
    type TableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration;
    type Create = SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeWhereElement;
    type Read = SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeRead;
    type ReadInner = SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        sqlx::postgres::types::PgRange {
            start: match value.0.0.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.0.0.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        }
    }
    type Update = SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin(std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin>);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tsrange")
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeTableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeCreate = OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeRead(OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeRead {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>) -> Self {
        Self(OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeReadInner = std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeUpdate = OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin;
impl crate::PostgresqlType for OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRange {
    type TableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeTableTypeDeclaration;
    type Create = OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeWhereElement;
    type Read = OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeRead;
    type ReadInner = OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::into_inner(
                SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeRead(value),
            )),
            None => None,
        }
    }
    type Update = OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin(std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin>);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>) -> Self {
        Self(value.into_iter().map(|element| SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tsrange[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeTableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeCreate = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead(VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>) -> Self {
        Self(VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeReadInner = std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeUpdate = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin;
impl crate::PostgresqlType for VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRange {
    type TableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeTableTypeDeclaration;
    type Create = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeWhereElement;
    type Read = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeRead;
    type ReadInner = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeRead(element)))
            .collect()
    }
    type Update = VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin(std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin>);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNotNullTimestampRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tsrange[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeTableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeCreate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>>) -> Self {
        Self(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeReadInner = std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>>;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeUpdate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRange {
    type TableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeTableTypeDeclaration;
    type Create = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeWhereElement;
    type Read = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeRead;
    type ReadInner = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeRead(element)))
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNotNullTimestampRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin(std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin>);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tsrange[] not null")
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeTableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeCreate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>>) -> Self {
        Self(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeReadInner = std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>>;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeUpdate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRange {
    type TableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeTableTypeDeclaration;
    type Create = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeWhereElement;
    type Read = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeRead;
    type ReadInner = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::into_inner(
                    SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeRead(value),
                )),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin(std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin>);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullArrayOfNullableTimestampRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tsrange[]")
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeTableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeCreate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableTimestampRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesTimePrimitiveDateTimeAsNotNullTimestamp as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeRead(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>>>) -> Self {
        Self(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::time::PrimitiveDateTime>>>>;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeUpdate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRange {
    type TableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeWhereElement;
    type Read = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeRead;
    type ReadInner = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::into_inner(
                            SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRangeRead(value),
                        )),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNullableArrayOfNullableTimestampRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesTimePrimitiveDateTimeAsNotNullTimestampRange as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange;
#[derive(Debug, Clone, PartialEq)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin(sqlx::postgres::types::PgRange<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin>);
impl SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>) -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: match value.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>) -> Self {
        Self::new(value)
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(__serializer, "SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin", false as std::primitive::usize + 1 + 1)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "start", &self.0.start)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "end", &self.0.end)?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        0u64 => serde::__private::Ok(__Field::__field0),
                        1u64 => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(self, __value: &str) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "start" => _serde::__private::Ok(__Field::__field0),
                        "end" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(self, __value: &[u8]) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        b"start" => serde::__private::Ok(__Field::__field0),
                        b"end" => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: serde::__private::PhantomData<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin>,
                lifetime: serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin")
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin with 2 elements"));
                        }
                    };
                    let __field1 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(1usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin with 2 elements"));
                        }
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin(sqlx::postgres::types::PgRange { start: __field0, end: __field1 }))
                }
                #[inline]
                fn visit_map<__A>(self, mut __map: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::MapAccess<'de>,
                {
                    let mut __field0: serde::__private::Option<std::collections::Bound<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin>> = serde::__private::None;
                    let mut __field1: serde::__private::Option<std::collections::Bound<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin>> = serde::__private::None;
                    while let serde::__private::Some(__key) = serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if serde::__private::Option::is_some(&__field0) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"start\""));
                                }
                                __field0 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin>>(&mut __map)?);
                            }
                            __Field::__field1 => {
                                if serde::__private::Option::is_some(&__field1) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"end\""));
                                }
                                __field1 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzOrigin>>(&mut __map)?);
                            }
                            _ => {
                                let _ = serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        serde::__private::Some(__field0) => __field0,
                        serde::__private::None => serde::__private::de::missing_field("\"start\"")?,
                    };
                    let __field1 = match __field1 {
                        serde::__private::Some(__field1) => __field1,
                        serde::__private::None => serde::__private::de::missing_field("\"end\"")?,
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin(sqlx::postgres::types::PgRange { start: __field0, end: __field1 }))
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["start", "end"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: std::ops::Bound::Included(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            end: std::ops::Bound::Excluded(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        })
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self::new(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tstzrange not null")
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin;
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeCreate = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeRead(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin);
impl SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeRead {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeReadInner = sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>;
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeUpdate = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin;
impl crate::PostgresqlType for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange {
    type TableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration;
    type Create = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeWhereElement;
    type Read = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeRead;
    type ReadInner = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        sqlx::postgres::types::PgRange {
            start: match value.0.0.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.0.0.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        }
    }
    type Update = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin(std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin>);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tstzrange")
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeTableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeCreate = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeRead(OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeRead {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>) -> Self {
        Self(OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeReadInner = std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeUpdate = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin;
impl crate::PostgresqlType for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRange {
    type TableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeTableTypeDeclaration;
    type Create = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeWhereElement;
    type Read = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeRead;
    type ReadInner = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::into_inner(
                SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeRead(value),
            )),
            None => None,
        }
    }
    type Update = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin(std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin>);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>) -> Self {
        Self(value.into_iter().map(|element| SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tstzrange[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeTableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeCreate = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeRead(VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeRead {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>) -> Self {
        Self(VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeReadInner = std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeUpdate = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin;
impl crate::PostgresqlType for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRange {
    type TableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeTableTypeDeclaration;
    type Create = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeWhereElement;
    type Read = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeRead;
    type ReadInner = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeRead(element)))
            .collect()
    }
    type Update = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin(std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin>);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNotNullTimestampTzRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tstzrange[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeTableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeCreate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeRead(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>) -> Self {
        Self(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeReadInner = std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeUpdate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRange {
    type TableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeTableTypeDeclaration;
    type Create = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeWhereElement;
    type Read = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeRead;
    type ReadInner = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeRead(element)))
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNotNullTimestampTzRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin(std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin>);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tstzrange[] not null")
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeTableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeCreate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeRead(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>) -> Self {
        Self(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeReadInner = std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeUpdate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRange {
    type TableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeTableTypeDeclaration;
    type Create = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeWhereElement;
    type Read = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeRead;
    type ReadInner = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::into_inner(
                    SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeRead(value),
                )),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin(std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin>);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullArrayOfNullableTimestampTzRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tstzrange[]")
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeTableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeCreate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableTimestampTzRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeRead(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>>) -> Self {
        Self(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>>>>>;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeUpdate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRange {
    type TableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeWhereElement;
    type Read = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeRead;
    type ReadInner = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::into_inner(
                            SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRangeRead(value),
                        )),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNullableArrayOfNullableTimestampTzRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoUtcAsNotNullTimestampTzRange as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
#[derive(Debug)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange;
#[derive(Debug, Clone, PartialEq)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin(sqlx::postgres::types::PgRange<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin>);
impl SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>) -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: match value.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin::new(value)),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin::new(value)),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>) -> Self {
        Self::new(value)
    }
}
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(__serializer, "SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin", false as std::primitive::usize + 1 + 1)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "start", &self.0.start)?;
            _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "end", &self.0.end)?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        0u64 => serde::__private::Ok(__Field::__field0),
                        1u64 => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(self, __value: &str) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "start" => _serde::__private::Ok(__Field::__field0),
                        "end" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(self, __value: &[u8]) -> serde::__private::Result<Self::Value, __E>
                where
                    __E: serde::de::Error,
                {
                    match __value {
                        b"start" => serde::__private::Ok(__Field::__field0),
                        b"end" => serde::__private::Ok(__Field::__field1),
                        _ => serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: serde::__private::PhantomData<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin>,
                lifetime: serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin;
                fn expecting(&self, __f: &mut serde::__private::Formatter<'_>) -> serde::__private::fmt::Result {
                    serde::__private::Formatter::write_str(__f, "struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin")
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::SeqAccess<'de>,
                {
                    let __field0 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(0usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin with 2 elements"));
                        }
                    };
                    let __field1 = match serde::de::SeqAccess::next_element::<std::collections::Bound<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin>>(&mut __seq)? {
                        serde::__private::Some(__value) => __value,
                        serde::__private::None => {
                            return serde::__private::Err(serde::de::Error::invalid_length(1usize, &"struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin with 2 elements"));
                        }
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin(sqlx::postgres::types::PgRange { start: __field0, end: __field1 }))
                }
                #[inline]
                fn visit_map<__A>(self, mut __map: __A) -> serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: serde::de::MapAccess<'de>,
                {
                    let mut __field0: serde::__private::Option<std::collections::Bound<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin>> = serde::__private::None;
                    let mut __field1: serde::__private::Option<std::collections::Bound<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin>> = serde::__private::None;
                    while let serde::__private::Some(__key) = serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if serde::__private::Option::is_some(&__field0) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"start\""));
                                }
                                __field0 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin>>(&mut __map)?);
                            }
                            __Field::__field1 => {
                                if serde::__private::Option::is_some(&__field1) {
                                    return serde::__private::Err(<__A::Error as serde::de::Error>::duplicate_field("\"end\""));
                                }
                                __field1 = serde::__private::Some(serde::de::MapAccess::next_value::<std::collections::Bound<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzOrigin>>(&mut __map)?);
                            }
                            _ => {
                                let _ = serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        serde::__private::Some(__field0) => __field0,
                        serde::__private::None => serde::__private::de::missing_field("\"start\"")?,
                    };
                    let __field1 = match __field1 {
                        serde::__private::Some(__field1) => __field1,
                        serde::__private::None => serde::__private::de::missing_field("\"end\"")?,
                    };
                    serde::__private::Ok(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin(sqlx::postgres::types::PgRange { start: __field0, end: __field1 }))
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["start", "end"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl std::fmt::Display for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(sqlx::postgres::types::PgRange {
            start: std::ops::Bound::Included(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            end: std::ops::Bound::Excluded(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        })
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self::new(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tstzrange not null")
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin;
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeCreate = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeRead(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin);
impl SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeRead {
    pub fn new(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin::new(value))
    }
    pub fn new_or_try_new_unwraped_for_test(value: sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>) -> Self {
        Self(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin::new_or_try_new_unwraped_for_test(value))
    }
}
impl error_occurence_lib::ToStdStringString for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeReadInner = sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>;
pub type SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeUpdate = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin;
impl crate::PostgresqlType for SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange {
    type TableTypeDeclaration = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration;
    type Create = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeWhereElement;
    type Read = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeRead;
    type ReadInner = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        sqlx::postgres::types::PgRange {
            start: match value.0.0.start {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
            end: match value.0.0.end {
                std::ops::Bound::Included(value) => std::ops::Bound::Included(value.0),
                std::ops::Bound::Excluded(value) => std::ops::Bound::Excluded(value.0),
                std::ops::Bound::Unbounded => std::ops::Bound::Unbounded,
            },
        }
    }
    type Update = SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        vec![]
    }
}
#[derive(Debug)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin(std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin>);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>) -> Self {
        Self(match value {
            Some(value) => Some(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tstzrange")
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeTableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeCreate = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeSelect;
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        ::core::default::Default::default()
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin>),
    FindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    FindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    StrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    StrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    IncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    ExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    GreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanIncludedLowerBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    GreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementGreaterThanExcludedUpperBound<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    OverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    AdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    RangeLength(crate::where_element_filters::PostgresqlTypeWhereElementRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::FindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::StrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::IncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::ExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::GreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::OverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::AdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::RangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::FindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::StrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::IncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::ExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::GreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::OverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::AdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::RangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeRead(OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin);
impl OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeRead {
    pub fn new(value: std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>) -> Self {
        Self(OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeReadInner = std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>;
pub type OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeUpdate = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin;
impl crate::PostgresqlType for OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRange {
    type TableTypeDeclaration = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeTableTypeDeclaration;
    type Create = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeSelect;
    fn select_query_part(_: &Self::Select, column: &std::primitive::str) -> std::string::String {
        column.to_string()
    }
    type WhereElement = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeWhereElement;
    type Read = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeRead;
    type ReadInner = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::into_inner(
                SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeRead(value),
            )),
            None => None,
        }
    }
    type Update = OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(element))
            .collect::<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::ReadInner>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin(std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin>);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>) -> Self {
        Self(value.into_iter().map(|element| SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tstzrange[] not null,check (array_position({column},null) is null)")
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeTableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeCreate = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeRead(VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin);
impl VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeRead {
    pub fn new(value: std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>) -> Self {
        Self(VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeReadInner = std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>;
pub type VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeUpdate = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin;
impl crate::PostgresqlType for VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRange {
    type TableTypeDeclaration = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeTableTypeDeclaration;
    type Create = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeWhereElement;
    type Read = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeRead;
    type ReadInner = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeRead(element)))
            .collect()
    }
    type Update = VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![element])
            .collect::<std::vec::Vec<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::ReadInner>>>()
    }
}
#[derive(Debug)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin(std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin>);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNotNullTimestampTzRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tstzrange[],check (array_position({column},null) is null)")
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeTableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeCreate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeRead(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin);
impl OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>) -> Self {
        Self(OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeReadInner = std::option::Option<std::vec::Vec<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>;
pub type OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeUpdate = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeOrigin;
impl crate::PostgresqlType for OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRange {
    type TableTypeDeclaration = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeTableTypeDeclaration;
    type Create = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeWhereElement;
    type Read = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeRead;
    type ReadInner = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::into_inner(SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeRead(element)))
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNotNullTimestampTzRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![element]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(None);
        acc
    }
}
#[derive(Debug)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin(std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin>);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>) -> Self {
        Self(value.into_iter().map(|element| OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin::new(element)).collect())
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(vec![crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()])
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::vec::Vec<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tstzrange[] not null")
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeTableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeCreate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeRead(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin);
impl VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeRead {
    pub fn new(value: std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>) -> Self {
        Self(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeReadInner = std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>;
pub type VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeUpdate = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin;
impl crate::PostgresqlType for VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRange {
    type TableTypeDeclaration = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeTableTypeDeclaration;
    type Create = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    type Select = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeWhereElement;
    type Read = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeRead;
    type ReadInner = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        value
            .0
            .0
            .into_iter()
            .map(|element| match element.0 {
                Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::into_inner(
                    SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeRead(value),
                )),
                None => None,
            })
            .collect()
    }
    type Update = VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(value);
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| vec![Some(element)])
            .collect::<std::vec::Vec<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::ReadInner>>>>();
        acc.push(vec![None]);
        acc
    }
}
#[derive(Debug)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRange;
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin(std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin>);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>>) -> Self {
        Self(match value {
            Some(value) => Some(VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin::new(value)),
            None => None,
        })
    }
    pub fn new_or_try_new_unwraped_for_test(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>>) -> Self {
        Self::new(value)
    }
}
impl std::fmt::Display for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(formatter, "{self:?}")
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn to_std_string_string(&self) -> std::string::String {
        self.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(Some(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()))
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin> as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <std::option::Option<VecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullArrayOfNullableTimestampTzRangeOrigin> as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::postgres::PgHasArrayType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin {
    fn array_type_info() -> sqlx::postgres::PgTypeInfo {
        <sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>> as sqlx::postgres::PgHasArrayType>::array_type_info()
    }
}
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin {
    pub fn create_table_column_query_part(column: &dyn std::fmt::Display, _: std::primitive::bool) -> impl std::fmt::Display {
        format!("{column} tstzrange[]")
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeTableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeCreate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin;
#[derive(Debug, Default, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeSelect {
    dimension1_pagination: crate::PaginationStartsWithOne,
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeSelect {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self {
            dimension1_pagination: crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub enum OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeWhereElement {
    Equal(crate::where_element_filters::PostgresqlTypeWhereElementEqual<OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin>),
    DimensionOneEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneEqual<OptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableTimestampTzRangeTableTypeDeclaration>),
    DimensionOneLengthEqual(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthEqual),
    DimensionOneLengthMoreThan(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneLengthMoreThan),
    DimensionOneFindRangesWithinGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesWithinGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneFindRangesThatFullyContainTheGivenRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneFindRangesThatFullyContainTheGivenRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToLeftOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToLeftOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneStrictlyToRightOfRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneStrictlyToRightOfRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanIncludedLowerBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanIncludedLowerBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneGreaterThanExcludedUpperBound(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneGreaterThanExcludedUpperBound<<SqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTz as crate::PostgresqlType>::Read>),
    DimensionOneOverlapWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneOverlapWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneAdjacentWithRange(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneAdjacentWithRange<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeTableTypeDeclaration>),
    DimensionOneRangeLength(crate::where_element_filters::PostgresqlTypeWhereElementDimensionOneRangeLength),
}
impl<'a> crate::PostgresqlTypeWhereFilter<'a> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeWhereElement {
    fn query_part(&self, increment: &mut std::primitive::u64, column: &dyn std::fmt::Display, is_need_to_add_logical_operator: std::primitive::bool) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        match &self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_part(value, increment, column, is_need_to_add_logical_operator),
        }
    }
    fn query_bind(self, query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        match self {
            Self::Equal(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthEqual(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneLengthMoreThan(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesWithinGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToLeftOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneStrictlyToRightOfRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanIncludedLowerBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneGreaterThanExcludedUpperBound(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneOverlapWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneAdjacentWithRange(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
            Self::DimensionOneRangeLength(value) => crate::PostgresqlTypeWhereFilter::query_bind(value, query),
        }
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeWhereElement {
    fn to_std_string_string(&self) -> std::string::String {
        format!("{self:#?}")
    }
}
impl crate::AllEnumVariantsArrayDefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeWhereElement {
    fn all_enum_variants_array_default_but_std_option_option_is_always_some_and_std_vec_vec_always_contains_one_element() -> std::vec::Vec<Self> {
        vec![
            Self::Equal(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthEqual(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneLengthMoreThan(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesWithinGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneFindRangesThatFullyContainTheGivenRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToLeftOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneStrictlyToRightOfRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanIncludedLowerBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneGreaterThanExcludedUpperBound(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneOverlapWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneAdjacentWithRange(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
            Self::DimensionOneRangeLength(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element()),
        ]
    }
}
#[derive(Debug, Clone, PartialEq, serde :: Serialize, serde :: Deserialize)]
pub struct OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeRead(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin);
impl OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeRead {
    pub fn new(value: std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>>) -> Self {
        Self(OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin::new(value))
    }
}
impl error_occurence_lib::ToStdStringString for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeRead {
    fn to_std_string_string(&self) -> std::string::String {
        self.0.to_string()
    }
}
impl crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeRead {
    fn default_but_option_is_always_some_and_vec_always_contains_one_element() -> Self {
        Self(crate::DefaultButOptionIsAlwaysSomeAndVecAlwaysContainsOneElement::default_but_option_is_always_some_and_vec_always_contains_one_element())
    }
}
impl sqlx::Encode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeRead {
    fn encode_by_ref(&self, buf: &mut sqlx::postgres::PgArgumentBuffer) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        sqlx::Encode::<sqlx::Postgres>::encode_by_ref(&self.0, buf)
    }
}
impl sqlx::Decode<'_, sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeRead {
    fn decode(value: sqlx::postgres::PgValueRef<'_>) -> Result<Self, sqlx::error::BoxDynError> {
        match <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin as sqlx::Decode<sqlx::Postgres>>::decode(value) {
            Ok(value) => Ok(Self(value)),
            Err(error) => Err(error),
        }
    }
}
impl sqlx::Type<sqlx::Postgres> for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeRead {
    fn type_info() -> <sqlx::Postgres as sqlx::Database>::TypeInfo {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::type_info()
    }
    fn compatible(ty: &<sqlx::Postgres as sqlx::Database>::TypeInfo) -> bool {
        <OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin as sqlx::Type<sqlx::Postgres>>::compatible(ty)
    }
}
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeReadInner = std::option::Option<std::vec::Vec<std::option::Option<sqlx::postgres::types::PgRange<sqlx::types::chrono::DateTime<sqlx::types::chrono::Local>>>>>;
pub type OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeUpdate = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeOrigin;
impl crate::PostgresqlType for OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRange {
    type TableTypeDeclaration = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeTableTypeDeclaration;
    type Create = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeCreate;
    fn create_query_part(_: &Self::Create, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn create_query_bind(value: Self::Create, mut query: sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'_, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    type Select = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeSelect;
    fn select_query_part(value: &Self::Select, column: &std::primitive::str) -> std::string::String {
        format!("{column}[{}:{}]", value.dimension1_pagination.start(), value.dimension1_pagination.end(),)
    }
    type WhereElement = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeWhereElement;
    type Read = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeRead;
    type ReadInner = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeReadInner;
    fn into_inner(value: Self::Read) -> Self::ReadInner {
        match value.0.0 {
            Some(value) => Some(
                value
                    .0
                    .into_iter()
                    .map(|element| match element.0 {
                        Some(value) => Some(<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::into_inner(
                            SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRangeRead(value),
                        )),
                        None => None,
                    })
                    .collect(),
            ),
            None => None,
        }
    }
    type Update = OptionVecOfOptionSqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNullableArrayOfNullableTimestampTzRangeUpdate;
    fn update_query_part(_: &Self::Update, _: &std::primitive::str, _: &std::primitive::str, _: &std::primitive::str, increment: &mut std::primitive::u64) -> Result<std::string::String, crate::QueryPartErrorNamed> {
        let mut acc = std::string::String::default();
        match increment.checked_add(1) {
            Some(value) => {
                *increment = value;
                acc.push_str(&format!("${increment}"));
            }
            None => {
                return Err(crate::QueryPartErrorNamed::CheckedAdd { code_occurence: error_occurence_lib::code_occurence!() });
            }
        }
        Ok(acc)
    }
    fn update_query_bind<'a>(value: Self::Update, mut query: sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments>) -> sqlx::query::Query<'a, sqlx::Postgres, sqlx::postgres::PgArguments> {
        query = query.bind(match value.0 {
            Some(value) => Some(value),
            None => None,
        });
        query
    }
    fn test_cases() -> std::vec::Vec<Self::ReadInner> {
        let mut acc = <SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::test_cases()
            .into_iter()
            .map(|element| Some(vec![Some(element)]))
            .collect::<std::vec::Vec<std::option::Option<std::vec::Vec<std::option::Option<<SqlxPostgresTypesPgRangeSqlxTypesChronoDateTimeSqlxTypesChronoLocalAsNotNullTimestampTzRange as crate::PostgresqlType>::ReadInner>>>>>();
        acc.push(None);
        acc.push(Some(vec![None]));
        acc
    }
}
