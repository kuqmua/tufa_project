use from_str::FromStr;
use location_lib::{Location, ToErrString, loc, loc::Loc};
use naming::{AscUcc, DescUcc, DisplayToScStr, DisplayToUccStr};
pub use pg_crud_common_and_macros_common::*;
use schemars::JsonSchema;
use serde::{Deserialize, Deserializer, Serialize};
use sqlx::{
    encode::IsNull,
    error::BoxDynError,
    postgres::{PgArgumentBuffer, PgArguments, PgValueRef},
    query::Query,
    types::Json,
    {Database, Decode, Encode, Postgres, Type},
};
use std::{
    error::Error as StdErEr,
    fmt::{
        Formatter, Result as StdFmtResult, {Debug, Display},
    },
};
use thiserror::Error;
use utoipa::ToSchema;
use uuid::Uuid;
macro_rules! trait_al {
    ($name:ident = $($bounds:tt)+) => {
        pub trait $name: $($bounds)+ {}
        impl<T: $($bounds)+> $name for T {}
    };
}
pub const DEFAULT_PAGINATION_LIMIT: i64 = 5;
trait_al!(DebugClonePartialEqAl = Debug + Clone + PartialEq);
trait_al!(DebugClonePartialEqSerializeAl = DebugClonePartialEqAl + Serialize);
trait_al!(DebugClonePartialEqSerdeAl = DebugClonePartialEqSerializeAl + for<'__> Deserialize<'__>);
trait_al!(
    DebugClonePartialEqSerdeDefaultSomeOneAl = DebugClonePartialEqSerdeAl + DefaultOptSomeVecOneEl
);
trait_al!(SqlxEncodePgSqlxTypePgAl = for<'__> Encode<'__, Postgres> + Type<Postgres>);
trait_al!(UtoipaToSchemaAndSchemarsJsonSchemaAl = for<'__> ToSchema<'__> + JsonSchema);
trait_al!(TableTypeAl = DebugClonePartialEqSerdeDefaultSomeOneAl);
trait_al!(CreateAl = DebugClonePartialEqSerdeDefaultSomeOneAl);
trait_al!(CreateForQueryAl = DebugClonePartialEqSerializeAl + SqlxEncodePgSqlxTypePgAl);
trait_al!(SelectAl = DebugClonePartialEqSerdeDefaultSomeOneAl);
trait_al!(WhereAl = DebugClonePartialEqSerdeAl + for<'__> PgTypeWhereFilter<'__>);
trait_al!(ReadAl = DebugClonePartialEqSerdeAl);
trait_al!(ReadOnlyIdsAl = DebugClonePartialEqSerdeAl);
trait_al!(ReadInnerAl = DebugClonePartialEqAl);
trait_al!(UpdateAl = DebugClonePartialEqSerdeDefaultSomeOneAl);
trait_al!(UpdateForQueryAl = DebugClonePartialEqSerializeAl);
#[allow(clippy::arbitrary_source_item_ordering)]
pub trait PgType {
    //difference between Create and TableType - Create may not contain generated by pg id
    type TableType: TableTypeAl;
    fn create_table_column_query_part(column: &dyn Display, _: bool) -> impl Display;
    type Create: CreateAl;
    fn create_query_part(value: &Self::Create, incr: &mut u64) -> Result<String, QueryPartEr>;
    fn create_query_bind(
        value: Self::Create,
        query: Query<'_, Postgres, PgArguments>,
    ) -> Result<Query<'_, Postgres, PgArguments>, String>;
    type Select: SelectAl;
    fn select_query_part(value: &Self::Select, column: &str) -> Result<String, QueryPartEr>;
    type Where: WhereAl;
    type Read: ReadAl + for<'__> Decode<'__, Postgres> + Type<Postgres>;
    fn normalize(value: Self::Read) -> Self::Read;
    type ReadOnlyIds: ReadOnlyIdsAl;
    fn select_only_ids_query_part(column: &str) -> Result<String, QueryPartEr>;
    type ReadInner: ReadInnerAl;
    fn into_inner(value: Self::Read) -> Self::ReadInner;
    type Update: UpdateAl;
    type UpdateForQuery: UpdateForQueryAl;
    fn update_query_part(
        value: &Self::UpdateForQuery,
        jsonb_set_accumulator: &str,
        jsonb_set_target: &str,
        jsonb_set_path: &str,
        incr: &mut u64,
    ) -> Result<String, QueryPartEr>;
    fn update_query_bind(
        value: Self::UpdateForQuery,
        query: Query<'_, Postgres, PgArguments>,
    ) -> Result<Query<'_, Postgres, PgArguments>, String>;
    fn select_only_updated_ids_query_part(
        value: &Self::UpdateForQuery,
        column: &str,
        incr: &mut u64,
    ) -> Result<String, QueryPartEr>;
    fn select_only_updated_ids_query_bind<'lifetime>(
        value: &'lifetime Self::UpdateForQuery,
        query: Query<'lifetime, Postgres, PgArguments>,
    ) -> Result<Query<'lifetime, Postgres, PgArguments>, String>;
}
#[allow(clippy::arbitrary_source_item_ordering)]
pub trait PgJsonType {
    type TableType: TableTypeAl + UtoipaToSchemaAndSchemarsJsonSchemaAl;
    type Create: CreateAl + UtoipaToSchemaAndSchemarsJsonSchemaAl;
    type CreateForQuery: CreateForQueryAl + From<Self::Create>;
    type Select: SelectAl + UtoipaToSchemaAndSchemarsJsonSchemaAl;
    fn select_query_part(
        value: &Self::Select,
        fi: &str,
        column_field: &str,
        //todo remove this coz its used properly now
        column_field_for_er_message: &str,
        is_pg_type: bool,
    ) -> Result<String, QueryPartEr>;
    type Where: WhereAl
        + UtoipaToSchemaAndSchemarsJsonSchemaAl
        + AllEnumVrtsArrDefaultOptSomeVecOneEl
        + ToErrString;
    //todo impl get fields from read
    //todo maybe add Decode trait here and Type
    type Read: ReadAl + UtoipaToSchemaAndSchemarsJsonSchemaAl + DefaultOptSomeVecOneEl;
    type ReadOnlyIds: ReadOnlyIdsAl;
    fn select_only_ids_query_part(column_field: &str) -> Result<String, QueryPartEr>;
    type ReadInner: ReadInnerAl;
    fn into_inner(value: Self::Read) -> Self::ReadInner;
    type Update: UpdateAl + UtoipaToSchemaAndSchemarsJsonSchemaAl;
    type UpdateForQuery: UpdateForQueryAl + From<Self::Update>;
    fn update_query_part(
        value: &Self::UpdateForQuery,
        jsonb_set_accumulator: &str,
        jsonb_set_target: &str,
        jsonb_set_path: &str,
        incr: &mut u64,
    ) -> Result<String, QueryPartEr>;
    fn update_query_bind(
        value: Self::UpdateForQuery,
        query: Query<'_, Postgres, PgArguments>,
    ) -> Result<Query<'_, Postgres, PgArguments>, String>;
    fn select_only_updated_ids_query_part(
        value: &Self::UpdateForQuery,
        fi: &str,
        column_field: &str,
        incr: &mut u64,
    ) -> Result<String, QueryPartEr>;
    fn select_only_updated_ids_query_bind<'lifetime>(
        value: &'lifetime Self::UpdateForQuery,
        query: Query<'lifetime, Postgres, PgArguments>,
    ) -> Result<Query<'lifetime, Postgres, PgArguments>, String>;
    fn select_only_created_ids_query_part(
        value: &Self::CreateForQuery,
        fi: &str,
        column_field: &str,
        incr: &mut u64,
    ) -> Result<String, QueryPartEr>;
    fn select_only_created_ids_query_bind<'lifetime>(
        value: &'lifetime Self::CreateForQuery,
        query: Query<'lifetime, Postgres, PgArguments>,
    ) -> Result<Query<'lifetime, Postgres, PgArguments>, String>;
}
#[allow(clippy::arbitrary_source_item_ordering)]
pub trait PgTypePrimaryKey {
    type PgType: PgType;
    type TableType: TableTypeAl + PartialOrd;
    fn read_only_ids_into_table_type(
        value: <Self::PgType as PgType>::ReadOnlyIds,
    ) -> <Self::PgType as PgType>::TableType;
    fn read_only_ids_into_read(
        value: <Self::PgType as PgType>::ReadOnlyIds,
    ) -> <Self::PgType as PgType>::Read;
    fn read_only_ids_into_update(
        value: <Self::PgType as PgType>::ReadOnlyIds,
    ) -> <Self::PgType as PgType>::Update;
    fn read_into_table_type(
        value: <Self::PgType as PgType>::Read,
    ) -> <Self::PgType as PgType>::TableType;
}
#[allow(clippy::arbitrary_source_item_ordering)]
pub trait PgTypeNotPrimaryKey {
    type PgType: PgType;
    type Create: CreateAl + SqlxEncodePgSqlxTypePgAl;
}
#[allow(clippy::arbitrary_source_item_ordering)]
pub trait PgJsonTypeObjectVecElId {
    type PgJsonType: PgJsonType;
    type CreateForQuery: CreateForQueryAl
        + From<<Self::PgJsonType as PgJsonType>::Create>
        + From<<Self::PgJsonType as PgJsonType>::Update>;
    type Update: UpdateAl + UtoipaToSchemaAndSchemarsJsonSchemaAl + ToErrString;
    type ReadInner: ReadInnerAl;
    fn query_bind_string_as_pg_text_create_for_query(
        value: <Self::PgJsonType as PgJsonType>::CreateForQuery,
        query: Query<'_, Postgres, PgArguments>,
    ) -> Result<Query<'_, Postgres, PgArguments>, String>;
    fn query_bind_string_as_pg_text_update_for_query(
        value: <Self::PgJsonType as PgJsonType>::UpdateForQuery,
        query: Query<'_, Postgres, PgArguments>,
    ) -> Result<Query<'_, Postgres, PgArguments>, String>;
    fn get_inner(value: &<Self::PgJsonType as PgJsonType>::CreateForQuery) -> &Self::ReadInner;
    fn incr_checked_add_one(incr: &mut u64) -> Result<u64, QueryPartEr>;
}
#[allow(clippy::arbitrary_source_item_ordering)]
#[cfg(feature = "test-utils")]
pub trait PgTypeTestCases {
    type PgType: PgType;
    type Select: SelectAl + DefaultOptSomeVecOneElMaxPageSize;
    fn opt_vec_create() -> Option<Vec<<Self::PgType as PgType>::Create>>;
    fn read_only_ids_to_two_dimal_vec_read_inner(
        read_only_ids: &<Self::PgType as PgType>::ReadOnlyIds,
    ) -> Vec<Vec<<Self::PgType as PgType>::ReadInner>>;
    fn read_inner_into_read_with_new_or_try_new_unwraped(
        value: <Self::PgType as PgType>::ReadInner,
    ) -> <Self::PgType as PgType>::Read;
    fn read_inner_into_update_with_new_or_try_new_unwraped(
        value: <Self::PgType as PgType>::ReadInner,
    ) -> <Self::PgType as PgType>::Update;
    fn update_to_read_only_ids(
        value: &<Self::PgType as PgType>::Update,
    ) -> <Self::PgType as PgType>::ReadOnlyIds;
    fn read_only_ids_to_opt_value_read_default_opt_some_vec_one_el(
        value: &<Self::PgType as PgType>::ReadOnlyIds,
    ) -> Option<Value<<Self::PgType as PgType>::Read>>;
    fn previous_read_merged_with_opt_update_into_read(
        read: <Self::PgType as PgType>::Read,
        opt_update: Option<<Self::PgType as PgType>::Update>,
    ) -> <Self::PgType as PgType>::Read;
    fn read_only_ids_merged_with_create_into_read(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> <Self::PgType as PgType>::Read;
    fn read_only_ids_merged_with_create_into_opt_value_read(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> Option<Value<<Self::PgType as PgType>::Read>>;
    fn read_only_ids_merged_with_create_into_table_type(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> <Self::PgType as PgType>::TableType;
    //todo add prefix pg_type or pg_json_type ?
    fn read_only_ids_merged_with_create_into_where_equal(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> <Self::PgType as PgType>::Where;
    fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> NotEmptyUniqueVec<<Self::PgType as PgType>::Where>;
    fn read_only_ids_merged_with_create_into_opt_vec_where_equal_to_json_field(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgType as PgType>::Where>>;
    fn create_into_pg_type_opt_vec_where_dim_one_equal(
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgType as PgType>::Where>>;
    fn pg_type_opt_vec_where_greater_than_test()
    -> Option<NotEmptyUniqueVec<PgTypeGreaterThanTest<Self::PgType>>>;
    fn read_only_ids_merged_with_table_type_into_pg_type_opt_where_greater_than(
        greater_than_vrt: PgTypeGreaterThanVrt,
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        table_type: <Self::PgType as PgType>::TableType,
    ) -> Option<<Self::PgType as PgType>::Where>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_dim_one_equal(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgType as PgType>::Where>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_dim_two_equal(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgType as PgType>::Where>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_dim_three_equal(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgType as PgType>::Where>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_dim_four_equal(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgType as PgType>::Where>>;
    fn create_into_pg_json_type_opt_vec_where_length_equal(
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgType as PgType>::Where>>;
    fn create_into_pg_json_type_opt_vec_where_length_greater_than(
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgType as PgType>::Where>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_greater_than(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<SingleOrMultiple<<Self::PgType as PgType>::Where>>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_between(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<SingleOrMultiple<<Self::PgType as PgType>::Where>>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_in(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<SingleOrMultiple<<Self::PgType as PgType>::Where>>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_regex(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<SingleOrMultiple<<Self::PgType as PgType>::Where>>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_contains_el_greater_than(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<SingleOrMultiple<<Self::PgType as PgType>::Where>>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_contains_el_regex(
        read_only_ids: <Self::PgType as PgType>::ReadOnlyIds,
        create: <Self::PgType as PgType>::Create,
    ) -> Option<NotEmptyUniqueVec<SingleOrMultiple<<Self::PgType as PgType>::Where>>>;
}
#[allow(clippy::arbitrary_source_item_ordering)]
#[derive(Debug, Clone, PartialEq)]
pub struct PgTypeGreaterThanTest<T: PgType> {
    pub vrt: PgTypeGreaterThanVrt,
    pub create: <T as PgType>::Create,
    pub greater_than: <T as PgType>::TableType,
}
#[allow(clippy::arbitrary_source_item_ordering)]
#[derive(Debug)]
pub struct PgTypeLengthGreaterThanTest<T: PgType> {
    pub vrt: PgJsonTypeLengthGreaterThanVrt,
    pub create: <T as PgType>::Create,
    pub length_greater_than: UnsignedPartOfI32,
}
#[allow(clippy::arbitrary_source_item_ordering)]
#[derive(Debug)]
pub struct PgJsonTypeLengthGreaterThanTest<T: PgJsonType> {
    pub vrt: PgJsonTypeLengthGreaterThanVrt,
    pub create: <T as PgJsonType>::Create,
    pub length_greater_than: UnsignedPartOfI32,
}
#[allow(clippy::arbitrary_source_item_ordering)]
#[cfg(feature = "test-utils")]
pub trait PgJsonTypeTestCases {
    type PgJsonType: PgJsonType;
    type Select: SelectAl
        + UtoipaToSchemaAndSchemarsJsonSchemaAl
        + DefaultOptSomeVecOneElMaxPageSize;
    fn opt_vec_create() -> Option<Vec<<Self::PgJsonType as PgJsonType>::Create>>;
    fn read_only_ids_to_two_dimal_vec_read_inner(
        read_only_ids: &<Self::PgJsonType as PgJsonType>::ReadOnlyIds,
    ) -> Vec<Vec<<Self::PgJsonType as PgJsonType>::ReadInner>>;
    fn read_inner_into_read_with_new_or_try_new_unwraped(
        value: <Self::PgJsonType as PgJsonType>::ReadInner,
    ) -> <Self::PgJsonType as PgJsonType>::Read;
    fn read_inner_into_update_with_new_or_try_new_unwraped(
        value: <Self::PgJsonType as PgJsonType>::ReadInner,
    ) -> <Self::PgJsonType as PgJsonType>::Update;
    fn read_only_ids_into_opt_value_read_inner(
        value: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
    ) -> Option<Value<<Self::PgJsonType as PgJsonType>::ReadInner>>;
    fn update_to_read_only_ids(
        value: &<Self::PgJsonType as PgJsonType>::Update,
    ) -> <Self::PgJsonType as PgJsonType>::ReadOnlyIds;
    fn read_only_ids_to_opt_value_read_default_opt_some_vec_one_el(
        value: &<Self::PgJsonType as PgJsonType>::ReadOnlyIds,
    ) -> Option<Value<<Self::PgJsonType as PgJsonType>::Read>>;
    fn previous_read_merged_with_opt_update_into_read(
        read: <Self::PgJsonType as PgJsonType>::Read,
        opt_update: Option<<Self::PgJsonType as PgJsonType>::Update>,
    ) -> <Self::PgJsonType as PgJsonType>::Read;
    fn read_only_ids_merged_with_create_into_read(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> <Self::PgJsonType as PgJsonType>::Read;
    fn read_only_ids_merged_with_create_into_opt_value_read(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> Option<Value<<Self::PgJsonType as PgJsonType>::Read>>;
    fn read_only_ids_merged_with_create_into_table_type(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> <Self::PgJsonType as PgJsonType>::TableType;
    fn read_only_ids_merged_with_create_into_where_equal(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> <Self::PgJsonType as PgJsonType>::Where;
    fn read_only_ids_merged_with_create_into_vec_where_equal_using_fields(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> NotEmptyUniqueVec<<Self::PgJsonType as PgJsonType>::Where>;
    fn read_only_ids_merged_with_create_into_vec_where_equal_to_json_field(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> NotEmptyUniqueVec<<Self::PgJsonType as PgJsonType>::Where>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_dim_one_equal(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgJsonType as PgJsonType>::Where>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_dim_two_equal(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgJsonType as PgJsonType>::Where>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_dim_three_equal(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgJsonType as PgJsonType>::Where>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_dim_four_equal(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgJsonType as PgJsonType>::Where>>;
    fn create_into_pg_json_type_opt_vec_where_length_equal(
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgJsonType as PgJsonType>::Where>>;
    fn create_into_pg_json_type_opt_vec_where_length_greater_than(
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> Option<NotEmptyUniqueVec<<Self::PgJsonType as PgJsonType>::Where>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_greater_than(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> Option<NotEmptyUniqueVec<SingleOrMultiple<<Self::PgJsonType as PgJsonType>::Where>>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_between(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> Option<NotEmptyUniqueVec<SingleOrMultiple<<Self::PgJsonType as PgJsonType>::Where>>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_in(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> Option<NotEmptyUniqueVec<SingleOrMultiple<<Self::PgJsonType as PgJsonType>::Where>>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_regex(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> Option<NotEmptyUniqueVec<SingleOrMultiple<<Self::PgJsonType as PgJsonType>::Where>>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_contains_el_greater_than(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> Option<NotEmptyUniqueVec<SingleOrMultiple<<Self::PgJsonType as PgJsonType>::Where>>>;
    fn read_only_ids_merged_with_create_into_pg_json_type_opt_vec_where_contains_el_regex(
        read_only_ids: <Self::PgJsonType as PgJsonType>::ReadOnlyIds,
        create: <Self::PgJsonType as PgJsonType>::Create,
    ) -> Option<NotEmptyUniqueVec<SingleOrMultiple<<Self::PgJsonType as PgJsonType>::Where>>>;
}
pub trait PgTypeWhereFilter<'query_lifetime> {
    fn query_bind(
        self,
        query: Query<'query_lifetime, Postgres, PgArguments>,
    ) -> Result<Query<'query_lifetime, Postgres, PgArguments>, String>;
    fn query_part(
        &self,
        incr: &mut u64,
        column: &dyn Display,
        is_need_to_add_logical_operator: bool,
    ) -> Result<String, QueryPartEr>;
}
//todo custom deserialization - must not contain more than one el
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, ToSchema, JsonSchema)]
pub struct NullableJsonObjectPgTypeWhereFilter<
    T: Debug
        + PartialEq
        + Clone
        + for<'lifetime> PgTypeWhereFilter<'lifetime>
        + AllEnumVrtsArrDefaultOptSomeVecOneEl,
>(pub Option<NotEmptyUniqueVec<T>>);
impl<'query_lifetime, T> PgTypeWhereFilter<'query_lifetime>
    for NullableJsonObjectPgTypeWhereFilter<T>
where
    T: Debug
        + PartialEq
        + Clone
        + for<'t_lifetime> PgTypeWhereFilter<'t_lifetime>
        + AllEnumVrtsArrDefaultOptSomeVecOneEl,
{
    fn query_bind(
        self,
        query: Query<'query_lifetime, Postgres, PgArguments>,
    ) -> Result<Query<'query_lifetime, Postgres, PgArguments>, String> {
        match self.0 {
            Some(v) => v.query_bind(query),
            None => Ok(query), //todo maybe wrong
        }
    }
    fn query_part(
        &self,
        incr: &mut u64,
        column: &dyn Display,
        is_need_to_add_logical_operator: bool,
    ) -> Result<String, QueryPartEr> {
        self.0.as_ref().map_or_else(
            || Ok(format!("{column} = 'null'")),
            |v_b4a9fcfb| v_b4a9fcfb.query_part(incr, column, is_need_to_add_logical_operator),
        )
    }
}
impl<T> ToErrString for NullableJsonObjectPgTypeWhereFilter<T>
where
    T: Debug
        + PartialEq
        + Clone
        + for<'t_lifetime> PgTypeWhereFilter<'t_lifetime>
        + AllEnumVrtsArrDefaultOptSomeVecOneEl,
{
    fn to_err_string(&self) -> String {
        format!("{self:#?}")
    }
}
impl<T> AllEnumVrtsArrDefaultOptSomeVecOneEl for NullableJsonObjectPgTypeWhereFilter<T>
where
    T: Debug
        + PartialEq
        + Clone
        + for<'t_lifetime> PgTypeWhereFilter<'t_lifetime>
        + AllEnumVrtsArrDefaultOptSomeVecOneEl,
{
    fn all_vrts_default_opt_some_vec_one_el() -> Vec<Self> {
        vec![Self(Some(
            DefaultOptSomeVecOneEl::default_opt_some_vec_one_el(),
        ))]
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Error, Location)]
pub enum QueryPartEr {
    CheckedAdd { loc: Loc },
    WriteIntoBuffer { loc: Loc },
}
#[derive(Debug, Clone, PartialEq, Eq, Serialize, ToSchema, JsonSchema)]
pub struct PgTypeWhere<T> {
    logical_operator: LogicalOperator,
    value: NotEmptyUniqueVec<T>,
}
impl<T: PartialEq + Clone> PgTypeWhere<T> {
    #[must_use]
    pub const fn get_logical_operator(&self) -> &LogicalOperator {
        &self.logical_operator
    }
    #[must_use]
    pub const fn new(logical_operator: LogicalOperator, value: NotEmptyUniqueVec<T>) -> Self {
        Self {
            logical_operator,
            value,
        }
    }
    pub fn try_new(
        logical_operator: LogicalOperator,
        value: Vec<T>,
    ) -> Result<Self, NotEmptyUniqueVecTryNewEr<T>> {
        match NotEmptyUniqueVec::try_new(value) {
            Ok(v_56f976af) => Ok(Self {
                logical_operator,
                value: v_56f976af,
            }),
            Err(er) => Err(er),
        }
    }
}
#[allow(unused_qualifications)]
#[allow(clippy::absolute_paths)]
#[allow(clippy::arbitrary_source_item_ordering)]
const _: () = {
    #[expect(clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de, T: Debug + PartialEq + Clone + Deserialize<'de>> Deserialize<'de> for PgTypeWhere<T> {
        fn deserialize<__D>(__deserializer: __D) -> Result<Self, __D::Error>
        where
            __D: Deserializer<'de>,
        {
            #[expect(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                f0,
                f1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl _serde::de::Visitor<'_> for __FieldVisitor {
                type Value = __Field;
                fn expecting(&self, __f: &mut Formatter<'_>) -> _serde::__private228::fmt::Result {
                    _serde::__private228::Formatter::write_str(__f, "field identifier")
                }
                fn visit_u64<__E>(self, v: u64) -> Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match v {
                        0u64 => Ok(__Field::f0),
                        1u64 => Ok(__Field::f1),
                        _ => Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(self, v: &str) -> Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match v {
                        "logical_operator" => Ok(__Field::f0),
                        "value" => Ok(__Field::f1),
                        _ => Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(self, v: &[u8]) -> Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match v {
                        b"logical_operator" => Ok(__Field::f0),
                        b"value" => Ok(__Field::f1),
                        _ => Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> Result<Self, __D::Error>
                where
                    __D: Deserializer<'de>,
                {
                    Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de, PgTypeWhere> {
                marker: _serde::__private228::PhantomData<PgTypeWhere>,
                lifetime: _serde::__private228::PhantomData<&'de ()>,
            }
            impl<'de, T: Debug + PartialEq + Clone + Deserialize<'de>> _serde::de::Visitor<'de>
                for __Visitor<'de, T>
            {
                type Value = PgTypeWhere<T>;
                fn expecting(&self, __f: &mut Formatter<'_>) -> _serde::__private228::fmt::Result {
                    Formatter::write_str(__f, "struct PgTypeWhere")
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let Some(f0) =
                        _serde::de::SeqAccess::next_element::<LogicalOperator>(&mut __seq)?
                    else {
                        return Err(_serde::de::Error::invalid_length(
                            0usize,
                            &"struct PgTypeWhere with 2 els",
                        ));
                    };
                    let Some(f1) = _serde::de::SeqAccess::next_element::<Vec<T>>(&mut __seq)?
                    else {
                        return Err(_serde::de::Error::invalid_length(
                            1usize,
                            &"struct PgTypeWhere with 2 els",
                        ));
                    };
                    match PgTypeWhere::try_new(f0, f1) {
                        Ok(v) => Ok(v),
                        Err(er) => Err(serde::de::Error::custom(format!("{er:?}"))),
                    }
                }
                #[inline]
                fn visit_map<__A>(self, mut __map: __A) -> Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut f0: Option<LogicalOperator> = None;
                    let mut f1: Option<Vec<T>> = None;
                    while let Some(__key) = _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                    {
                        match __key {
                            __Field::f0 => {
                                if Option::is_some(&f0) {
                                    return Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "logical_operator",
                                        ),
                                    );
                                }
                                f0 = Some(_serde::de::MapAccess::next_value::<LogicalOperator>(
                                    &mut __map,
                                )?);
                            }
                            __Field::f1 => {
                                if Option::is_some(&f1) {
                                    return Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                    );
                                }
                                f1 = Some(_serde::de::MapAccess::next_value::<Vec<T>>(&mut __map)?);
                            }
                            __Field::__ignore => {
                                let _: serde::de::IgnoredAny =
                                    _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(
                                        &mut __map,
                                    )?;
                            }
                        }
                    }
                    let f0_value = match f0 {
                        Some(v) => v,
                        None => _serde::__private228::de::missing_field("logical_operator")?,
                    };
                    let f1_value = match f1 {
                        Some(v) => v,
                        None => _serde::__private228::de::missing_field("value")?,
                    };
                    match PgTypeWhere::try_new(f0_value, f1_value) {
                        Ok(v) => Ok(v),
                        Err(er) => Err(serde::de::Error::custom(format!("{er:?}"))),
                    }
                }
            }
            #[doc(hidden)]
            const FIELDS: &[&str] = &["logical_operator", "value"];
            Deserializer::deserialize_struct(
                __deserializer,
                "PgTypeWhere",
                FIELDS,
                __Visitor {
                    marker: _serde::__private228::PhantomData::<T>,
                    lifetime: _serde::__private228::PhantomData,
                },
            )
        }
    }
};
impl<'query_lifetime, T: PgTypeWhereFilter<'query_lifetime>> PgTypeWhereFilter<'query_lifetime>
    for PgTypeWhere<T>
{
    fn query_bind(
        self,
        mut query: Query<'query_lifetime, Postgres, PgArguments>,
    ) -> Result<Query<'query_lifetime, Postgres, PgArguments>, String> {
        for el in self.value.0 {
            match PgTypeWhereFilter::query_bind(el, query) {
                Ok(v) => {
                    query = v;
                }
                Err(er) => {
                    return Err(er);
                }
            }
        }
        Ok(query)
    }
    fn query_part(
        &self,
        incr: &mut u64,
        column: &dyn Display,
        is_need_to_add_logical_operator: bool,
    ) -> Result<String, QueryPartEr> {
        let mut acc = String::default();
        let mut is_need_to_add_logical_operator_inner_handle = false;
        for el in &self.value.0 {
            match PgTypeWhereFilter::query_part(
                el,
                incr,
                column,
                is_need_to_add_logical_operator_inner_handle,
            ) {
                Ok(v) => {
                    use std::fmt::Write as _;
                    if write!(acc, "{v} ").is_err() {
                        return Err(QueryPartEr::WriteIntoBuffer { loc: loc!() });
                    }
                    is_need_to_add_logical_operator_inner_handle = true;
                }
                Err(er) => {
                    return Err(er);
                }
            }
        }
        let _: Option<char> = acc.pop();
        Ok(format!(
            "{}({acc})",
            &self
                .logical_operator
                .to_query_part(is_need_to_add_logical_operator)
        ))
    }
}
impl<T: Debug + PartialEq + Clone + AllEnumVrtsArrDefaultOptSomeVecOneEl> DefaultOptSomeVecOneEl
    for PgTypeWhere<T>
{
    fn default_opt_some_vec_one_el() -> Self {
        Self {
            logical_operator: DefaultOptSomeVecOneEl::default_opt_some_vec_one_el(),
            value: NotEmptyUniqueVec::try_new(
                AllEnumVrtsArrDefaultOptSomeVecOneEl::all_vrts_default_opt_some_vec_one_el(),
            )
            .expect("a918b427"),
        }
    }
}
#[derive(Debug, Default, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, FromStr)]
pub enum Order {
    #[serde(rename(serialize = "asc", deserialize = "asc"))]
    #[default]
    Asc,
    #[serde(rename(serialize = "desc", deserialize = "desc"))]
    Desc,
}
impl Display for Order {
    fn fmt(&self, f: &mut Formatter<'_>) -> StdFmtResult {
        match self {
            Self::Asc => write!(f, "{AscUcc}"),
            Self::Desc => write!(f, "{DescUcc}"),
        }
    }
}
impl DefaultOptSomeVecOneEl for Order {
    fn default_opt_some_vec_one_el() -> Self {
        Self::default()
    }
}
impl Order {
    #[must_use]
    pub fn to_sc_str(&self) -> String {
        DisplayToScStr::case(&self)
    }
    #[must_use]
    pub fn to_ucc_str(&self) -> String {
        DisplayToUccStr::case(&self)
    }
}
#[derive(Debug, Serialize, Deserialize)]
pub struct OrderBy<ColumnGeneric> {
    pub column: ColumnGeneric,
    pub order: Option<Order>,
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, ToSchema, JsonSchema)]
pub struct PaginationBase {
    limit: i64,
    offset: i64,
}
impl PaginationBase {
    #[must_use]
    pub const fn end(&self) -> i64 {
        self.offset.checked_add(self.limit).expect("8a297b66")
    }
    #[must_use]
    pub const fn new_unchecked(limit: i64, offset: i64) -> Self {
        Self { limit, offset }
    }
    #[must_use]
    pub const fn start(&self) -> i64 {
        self.offset
    }
}
impl<'query_lifetime> PgTypeWhereFilter<'query_lifetime> for PaginationBase {
    fn query_bind(
        self,
        mut query: Query<'query_lifetime, Postgres, PgArguments>,
    ) -> Result<Query<'query_lifetime, Postgres, PgArguments>, String> {
        if let Err(er) = query.try_bind(self.limit) {
            return Err(er.to_string());
        }
        if let Err(er) = query.try_bind(self.offset) {
            return Err(er.to_string());
        }
        Ok(query)
    }
    fn query_part(&self, incr: &mut u64, _: &dyn Display, _: bool) -> Result<String, QueryPartEr> {
        let limit_incr = match incr_checked_add_one_returning_incr(incr) {
            Ok(v) => v,
            Err(er) => {
                return Err(er);
            }
        };
        let offset_incr = match incr_checked_add_one_returning_incr(incr) {
            Ok(v) => v,
            Err(er) => {
                return Err(er);
            }
        };
        Ok(format!("limit ${limit_incr} offset ${offset_incr}"))
    }
}
impl Default for PaginationBase {
    fn default() -> Self {
        Self::new_unchecked(DEFAULT_PAGINATION_LIMIT, 0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, ToSchema, JsonSchema)]
pub struct PaginationStartsWithZero(PaginationBase);
#[derive(Debug, Serialize, Deserialize, Error, Location)]
pub enum PaginationStartsWithZeroTryNewEr {
    LimitIsLessThanOrEqualToZero {
        #[eo_to_err_string_serde]
        limit: i64,
        loc: Loc,
    },
    OffsetIsLessThanZero {
        #[eo_to_err_string_serde]
        offset: i64,
        loc: Loc,
    },
    OffsetPlusLimitIsIntOverflow {
        #[eo_to_err_string_serde]
        limit: i64,
        #[eo_to_err_string_serde]
        offset: i64,
        loc: Loc,
    },
}
impl PaginationStartsWithZero {
    #[must_use]
    pub const fn end(&self) -> i64 {
        self.0.end()
    }
    #[must_use]
    pub const fn start(&self) -> i64 {
        self.0.start()
    }
    pub fn try_new(limit: i64, offset: i64) -> Result<Self, PaginationStartsWithZeroTryNewEr> {
        if limit <= 0 || offset < 0 {
            if limit <= 0 {
                Err(
                    PaginationStartsWithZeroTryNewEr::LimitIsLessThanOrEqualToZero {
                        limit,
                        loc: loc!(),
                    },
                )
            } else {
                Err(PaginationStartsWithZeroTryNewEr::OffsetIsLessThanZero {
                    offset,
                    loc: loc!(),
                })
            }
        } else if offset.checked_add(limit).is_some() {
            Ok(Self(PaginationBase::new_unchecked(limit, offset)))
        } else {
            Err(
                PaginationStartsWithZeroTryNewEr::OffsetPlusLimitIsIntOverflow {
                    limit,
                    offset,
                    loc: loc!(),
                },
            )
        }
    }
}
#[allow(unused_qualifications)]
#[allow(clippy::absolute_paths)]
#[allow(clippy::arbitrary_source_item_ordering)]
impl<'de> Deserialize<'de> for PaginationStartsWithZero {
    fn deserialize<__D>(__deserializer: __D) -> Result<Self, __D::Error>
    where
        __D: Deserializer<'de>,
    {
        #[expect(non_camel_case_types)]
        #[doc(hidden)]
        enum __Field {
            f0,
            f1,
            __ignore,
        }
        #[doc(hidden)]
        struct __FieldVisitor;
        impl serde::de::Visitor<'_> for __FieldVisitor {
            type Value = __Field;
            fn expecting(&self, __f: &mut Formatter<'_>) -> serde::__private228::fmt::Result {
                serde::__private228::Formatter::write_str(__f, "field identifier")
            }
            fn visit_u64<__E>(self, v: u64) -> Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match v {
                    0u64 => Ok(__Field::f0),
                    1u64 => Ok(__Field::f1),
                    _ => Ok(__Field::__ignore),
                }
            }
            fn visit_str<__E>(self, v: &str) -> Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match v {
                    "limit" => Ok(__Field::f0),
                    "offset" => Ok(__Field::f1),
                    _ => Ok(__Field::__ignore),
                }
            }
            fn visit_bytes<__E>(self, v: &[u8]) -> Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match v {
                    b"limit" => Ok(__Field::f0),
                    b"offset" => Ok(__Field::f1),
                    _ => Ok(__Field::__ignore),
                }
            }
        }
        impl<'de> Deserialize<'de> for __Field {
            #[inline]
            fn deserialize<__D>(__deserializer: __D) -> Result<Self, __D::Error>
            where
                __D: Deserializer<'de>,
            {
                Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
            }
        }
        #[doc(hidden)]
        struct __Visitor<'de> {
            marker: serde::__private228::PhantomData<PaginationStartsWithZero>,
            lifetime: serde::__private228::PhantomData<&'de ()>,
        }
        impl<'de> serde::de::Visitor<'de> for __Visitor<'de> {
            type Value = PaginationStartsWithZero;
            fn expecting(&self, __f: &mut Formatter<'_>) -> serde::__private228::fmt::Result {
                Formatter::write_str(__f, "struct PaginationStartsWithZero")
            }
            #[inline]
            fn visit_seq<__A>(self, mut __seq: __A) -> Result<Self::Value, __A::Error>
            where
                __A: serde::de::SeqAccess<'de>,
            {
                let Some(f0) = serde::de::SeqAccess::next_element::<i64>(&mut __seq)? else {
                    return Err(serde::de::Error::invalid_length(
                        0usize,
                        &"struct PaginationStartsWithZero with 2 els",
                    ));
                };
                let Some(f1) = serde::de::SeqAccess::next_element::<i64>(&mut __seq)? else {
                    return Err(serde::de::Error::invalid_length(
                        1usize,
                        &"struct PaginationStartsWithZero with 2 els",
                    ));
                };
                match PaginationStartsWithZero::try_new(f0, f1) {
                    Ok(v) => Ok(v),
                    Err(er) => Err(serde::de::Error::custom(format!("{er:?}"))), //todo use serde_json::to_string(&er).unwrap_or_else(|_|"failed to serialize er".into())
                }
            }
            #[inline]
            fn visit_map<__A>(self, mut __map: __A) -> Result<Self::Value, __A::Error>
            where
                __A: serde::de::MapAccess<'de>,
            {
                let mut f0: Option<i64> = None;
                let mut f1: Option<i64> = None;
                while let Some(__key) = serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                    match __key {
                        __Field::f0 => {
                            if Option::is_some(&f0) {
                                return Err(<__A::Error as serde::de::Error>::duplicate_field(
                                    "limit",
                                ));
                            }
                            f0 = Some(serde::de::MapAccess::next_value::<i64>(&mut __map)?);
                        }
                        __Field::f1 => {
                            if Option::is_some(&f1) {
                                return Err(<__A::Error as serde::de::Error>::duplicate_field(
                                    "offset",
                                ));
                            }
                            f1 = Some(serde::de::MapAccess::next_value::<i64>(&mut __map)?);
                        }
                        __Field::__ignore => {
                            let _: serde::de::IgnoredAny =
                                serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(
                                    &mut __map,
                                )?;
                        }
                    }
                }
                let f0_value = match f0 {
                    Some(v) => v,
                    None => serde::__private228::de::missing_field("limit")?,
                };
                let f1_value = match f1 {
                    Some(v) => v,
                    None => serde::__private228::de::missing_field("offset")?,
                };
                match PaginationStartsWithZero::try_new(f0_value, f1_value) {
                    Ok(v) => Ok(v),
                    Err(er) => Err(serde::de::Error::custom(format!("{er:?}"))),
                }
            }
        }
        #[doc(hidden)]
        const FIELDS: &[&str] = &["limit", "offset"];
        Deserializer::deserialize_struct(
            __deserializer,
            "PaginationStartsWithZero",
            FIELDS,
            __Visitor {
                marker: serde::__private228::PhantomData::<Self>,
                lifetime: serde::__private228::PhantomData,
            },
        )
    }
}
impl<'query_lifetime> PgTypeWhereFilter<'query_lifetime> for PaginationStartsWithZero {
    fn query_bind(
        self,
        query: Query<'query_lifetime, Postgres, PgArguments>,
    ) -> Result<Query<'query_lifetime, Postgres, PgArguments>, String> {
        self.0.query_bind(query)
    }
    fn query_part(
        &self,
        incr: &mut u64,
        column: &dyn Display,
        is_need_to_add_logical_operator: bool,
    ) -> Result<String, QueryPartEr> {
        self.0
            .query_part(incr, column, is_need_to_add_logical_operator)
    }
}
impl DefaultOptSomeVecOneEl for PaginationStartsWithZero {
    #[inline]
    fn default_opt_some_vec_one_el() -> Self {
        Self(PaginationBase::new_unchecked(DEFAULT_PAGINATION_LIMIT, 0))
    }
}
impl DefaultOptSomeVecOneElMaxPageSize for PaginationStartsWithZero {
    #[inline]
    fn default_opt_some_vec_one_el_max_page_size() -> Self {
        Self(PaginationBase::new_unchecked(i32::MAX.into(), 0))
    }
}
//this needed coz serde Option<Opt<T>> #[serde(skip_serializing_if = "Option::is_none")] - if both opts: inner and parent is null then it skip - its not correct
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, ToSchema, JsonSchema)]
pub struct Value<T> {
    pub value: T,
}
//todo ExactSizeIterator now is not a solution. er[E0658]: use of unstable library feature `exact_size_is_empty`. maybe rewrite it later
pub trait IsStringEmpty {
    fn is_string_empty(&self) -> bool;
}
#[derive(Debug, Serialize, Deserialize, Error, Location)]
pub enum NotEmptyUniqueVecTryNewEr<T> {
    IsEmpty {
        loc: Loc,
    },
    NotUnique {
        #[eo_to_err_string_serde]
        value: T,
        loc: Loc,
    },
}
#[derive(Debug, Clone, PartialEq, Eq, Serialize, ToSchema, JsonSchema)]
pub struct NotEmptyUniqueVec<T>(Vec<T>);
impl<T: PartialEq + Clone> NotEmptyUniqueVec<T> {
    #[must_use]
    pub fn into_vec(self) -> Vec<T> {
        self.0
    }
    #[must_use]
    pub const fn to_vec(&self) -> &Vec<T> {
        &self.0
    }
    pub fn try_new(v: Vec<T>) -> Result<Self, NotEmptyUniqueVecTryNewEr<T>> {
        if v.is_empty() {
            return Err(NotEmptyUniqueVecTryNewEr::IsEmpty { loc: loc!() });
        }
        {
            let mut acc = Vec::new();
            for el in &v {
                if acc.contains(&el) {
                    return Err(NotEmptyUniqueVecTryNewEr::NotUnique {
                        value: el.clone(),
                        loc: loc!(),
                    });
                }
                acc.push(el);
            }
        }
        Ok(Self(v))
    }
}
#[allow(unused_qualifications)]
#[allow(clippy::absolute_paths)]
#[allow(clippy::arbitrary_source_item_ordering)]
const _: () = {
    #[expect(clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de, T: Debug + PartialEq + Clone + Deserialize<'de>> Deserialize<'de>
        for NotEmptyUniqueVec<T>
    {
        fn deserialize<__D>(__deserializer: __D) -> Result<Self, __D::Error>
        where
            __D: Deserializer<'de>,
        {
            #[doc(hidden)]
            struct __Visitor<'de, T>
            where
                T: Deserialize<'de>,
            {
                marker: _serde::__private228::PhantomData<NotEmptyUniqueVec<T>>,
                lifetime: _serde::__private228::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de, T: Debug + PartialEq + Clone + Deserialize<'de>> _serde::de::Visitor<'de>
                for __Visitor<'de, T>
            {
                type Value = NotEmptyUniqueVec<T>;
                fn expecting(&self, __f: &mut Formatter<'_>) -> _serde::__private228::fmt::Result {
                    Formatter::write_str(__f, "tuple struct NotEmptyUniqueVec")
                }
                #[inline]
                fn visit_newtype_struct<__E>(self, __e: __E) -> Result<Self::Value, __E::Error>
                where
                    __E: Deserializer<'de>,
                {
                    let f0: Vec<T> = <Vec<T> as Deserialize>::deserialize(__e)?;
                    Ok(NotEmptyUniqueVec(f0))
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let Some(f0) = _serde::de::SeqAccess::next_element::<Vec<T>>(&mut __seq)?
                    else {
                        return Err(_serde::de::Error::invalid_length(
                            0usize,
                            &"tuple struct NotEmptyUniqueVec with 1 el",
                        ));
                    };
                    match NotEmptyUniqueVec::try_new(f0) {
                        Ok(v) => Ok(v),
                        Err(er) => Err(_serde::de::Error::custom(format!("{er:?}"))),
                    }
                }
            }
            Deserializer::deserialize_newtype_struct(
                __deserializer,
                "NotEmptyUniqueVec",
                __Visitor {
                    marker: _serde::__private228::PhantomData::<Self>,
                    lifetime: _serde::__private228::PhantomData,
                },
            )
        }
    }
};
impl<T: AllEnumVrtsArrDefaultOptSomeVecOneEl> DefaultOptSomeVecOneEl for NotEmptyUniqueVec<T> {
    fn default_opt_some_vec_one_el() -> Self {
        Self(AllEnumVrtsArrDefaultOptSomeVecOneEl::all_vrts_default_opt_some_vec_one_el())
    }
}
impl<T: AllEnumVrtsArrDefaultOptSomeVecOneElMaxPageSize> DefaultOptSomeVecOneElMaxPageSize
    for NotEmptyUniqueVec<T>
{
    fn default_opt_some_vec_one_el_max_page_size() -> Self {
        Self(AllEnumVrtsArrDefaultOptSomeVecOneElMaxPageSize::all_vrts_default_opt_some_vec_one_el_max_page_size())
    }
}
impl<T> Default for NotEmptyUniqueVec<T> {
    fn default() -> Self {
        Self(Vec::default())
    }
}
impl<T> From<NotEmptyUniqueVec<T>> for Vec<T> {
    fn from(v: NotEmptyUniqueVec<T>) -> Self {
        v.0
    }
}
impl<T1> NotEmptyUniqueVec<T1> {
    pub fn from_t1_impl_from_t2<T2: From<T1>>(v: Self) -> NotEmptyUniqueVec<T2> {
        NotEmptyUniqueVec(v.0.into_iter().map(T2::from).collect::<Vec<T2>>())
    }
}
impl<'query_lifetime, T> PgTypeWhereFilter<'query_lifetime> for NotEmptyUniqueVec<T>
where
    T: Debug
        + PartialEq
        + Clone
        + for<'t_lifetime> PgTypeWhereFilter<'t_lifetime>
        + AllEnumVrtsArrDefaultOptSomeVecOneEl,
{
    fn query_bind(
        self,
        mut query: Query<'query_lifetime, Postgres, PgArguments>,
    ) -> Result<Query<'query_lifetime, Postgres, PgArguments>, String> {
        for el in self.0 {
            match el.query_bind(query) {
                Ok(v) => {
                    query = v;
                }
                Err(er) => {
                    return Err(er);
                }
            }
        }
        Ok(query)
    }
    fn query_part(
        &self,
        incr: &mut u64,
        column: &dyn Display,
        is_need_to_add_logical_operator: bool,
    ) -> Result<String, QueryPartEr> {
        let mut acc = String::default();
        for (index, v_953208ce) in self.0.iter().enumerate() {
            match v_953208ce.query_part(
                incr,
                column,
                if index == 0 {
                    is_need_to_add_logical_operator
                } else {
                    true
                },
            ) {
                Ok(v) => {
                    acc.push_str(&v);
                }
                Err(er) => {
                    return Err(er);
                }
            }
        }
        Ok(acc)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub struct JsonFieldRights {
    can_create: bool,
    can_read: bool,
    can_update: bool,
}
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct NonPrimaryKeyPgTypeReadOnlyIds(pub Value<Option<()>>);
impl Decode<'_, Postgres> for NonPrimaryKeyPgTypeReadOnlyIds {
    fn decode(value: PgValueRef<'_>) -> Result<Self, BoxDynError> {
        match <Json<Self> as Decode<Postgres>>::decode(value) {
            Ok(v0) => Ok(v0.0),
            Err(er) => Err(er),
        }
    }
}
impl Type<Postgres> for NonPrimaryKeyPgTypeReadOnlyIds {
    fn compatible(ty: &<Postgres as Database>::TypeInfo) -> bool {
        <Json<Self> as Type<Postgres>>::compatible(ty)
    }
    fn type_info() -> <Postgres as Database>::TypeInfo {
        <Json<Self> as Type<Postgres>>::type_info()
    }
}
impl Default for NonPrimaryKeyPgTypeReadOnlyIds {
    fn default() -> Self {
        Self(Value { value: None })
    }
}
#[derive(Debug, Clone, Copy)]
pub enum EqualOperator {
    Equal,
    IsNull,
}
impl EqualOperator {
    #[must_use]
    pub const fn to_query_str(&self) -> &'static str {
        match &self {
            Self::Equal => "=",
            Self::IsNull => "is null",
        }
    }
}
pub trait PgTypeEqualOperator {
    fn operator(&self) -> EqualOperator;
}
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Serialize, JsonSchema)]
pub struct UnsignedPartOfI32(i32); //todo why exactly i32? maybe different types for pg type and pg json type
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Error, Location, JsonSchema)]
pub enum UnsignedPartOfI32TryFromI32Er {
    LessThanZero {
        #[eo_to_err_string_serde]
        value: i32,
        loc: Loc,
    },
}
impl TryFrom<i32> for UnsignedPartOfI32 {
    type Error = UnsignedPartOfI32TryFromI32Er;
    fn try_from(v: i32) -> Result<Self, Self::Error> {
        if v >= 0 {
            Ok(Self(v))
        } else {
            Err(Self::Error::LessThanZero {
                value: v,
                loc: loc!(),
            })
        }
    }
}
#[allow(unused_qualifications)]
#[allow(clippy::absolute_paths)]
#[allow(clippy::arbitrary_source_item_ordering)]
const _: () = {
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> Deserialize<'de> for UnsignedPartOfI32 {
        fn deserialize<__D>(__deserializer: __D) -> Result<Self, __D::Error>
        where
            __D: Deserializer<'de>,
        {
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private228::PhantomData<UnsignedPartOfI32>,
                lifetime: _serde::__private228::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = UnsignedPartOfI32;
                fn expecting(
                    &self,
                    __formatter: &mut Formatter<'_>,
                ) -> _serde::__private228::fmt::Result {
                    Formatter::write_str(__formatter, "tuple struct UnsignedPartOfI32")
                }
                #[inline]
                fn visit_newtype_struct<__E>(self, __e: __E) -> Result<Self::Value, __E::Error>
                where
                    __E: Deserializer<'de>,
                {
                    let f0: i32 = <i32 as Deserialize>::deserialize(__e)?;
                    match UnsignedPartOfI32::try_from(f0) {
                        Ok(v) => Ok(v),
                        Err(er) => Err(serde::de::Error::custom(format!("{er:?}"))),
                    }
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let Some(f0) = _serde::de::SeqAccess::next_element::<i32>(&mut __seq)? else {
                        return Err(_serde::de::Error::invalid_length(
                            0usize,
                            &"tuple struct UnsignedPartOfI32 with 1 el",
                        ));
                    };
                    match UnsignedPartOfI32::try_from(f0) {
                        Ok(v) => Ok(v),
                        Err(er) => Err(serde::de::Error::custom(format!("{er:?}"))),
                    }
                }
            }
            Deserializer::deserialize_newtype_struct(
                __deserializer,
                "UnsignedPartOfI32",
                __Visitor {
                    marker: _serde::__private228::PhantomData::<Self>,
                    lifetime: _serde::__private228::PhantomData,
                },
            )
        }
    }
};
impl ToErrString for UnsignedPartOfI32 {
    fn to_err_string(&self) -> String {
        self.0.to_string()
    }
}
impl Type<Postgres> for UnsignedPartOfI32 {
    fn compatible(ty: &<Postgres as Database>::TypeInfo) -> bool {
        <i32 as Type<Postgres>>::compatible(ty)
    }
    fn type_info() -> <Postgres as Database>::TypeInfo {
        <i32 as Type<Postgres>>::type_info()
    }
}
impl Encode<'_, Postgres> for UnsignedPartOfI32 {
    fn encode_by_ref(
        &self,
        buf: &mut PgArgumentBuffer,
    ) -> Result<IsNull, Box<dyn StdErEr + Send + Sync>> {
        <i32 as Encode<Postgres>>::encode_by_ref(&self.0, buf)
    }
}
impl UnsignedPartOfI32 {
    #[must_use]
    pub const fn get(&self) -> i32 {
        self.0
    }
}
impl DefaultOptSomeVecOneEl for UnsignedPartOfI32 {
    fn default_opt_some_vec_one_el() -> Self {
        Self(0)
    }
}
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Serialize, JsonSchema)]
pub struct NotZeroUnsignedPartOfI32(UnsignedPartOfI32);
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Error, Location, JsonSchema)]
pub enum NotZeroUnsignedPartOfI32TryFromI32Er {
    IsZero {
        loc: Loc,
    },
    UnsignedPartOfI32TryFromI32Er {
        #[eo_location]
        value: UnsignedPartOfI32TryFromI32Er,
        loc: Loc,
    },
}
impl TryFrom<i32> for NotZeroUnsignedPartOfI32 {
    type Error = NotZeroUnsignedPartOfI32TryFromI32Er;
    fn try_from(v: i32) -> Result<Self, Self::Error> {
        match UnsignedPartOfI32::try_from(v) {
            Ok(v0) => {
                if v0.0 == 0 {
                    Err(Self::Error::IsZero { loc: loc!() })
                } else {
                    Ok(Self(v0))
                }
            }
            Err(er) => Err(Self::Error::UnsignedPartOfI32TryFromI32Er {
                value: er,
                loc: loc!(),
            }),
        }
    }
}
#[allow(unused_qualifications)]
#[allow(clippy::absolute_paths)]
#[allow(clippy::arbitrary_source_item_ordering)]
const _: () = {
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> Deserialize<'de> for NotZeroUnsignedPartOfI32 {
        fn deserialize<__D>(__deserializer: __D) -> Result<Self, __D::Error>
        where
            __D: Deserializer<'de>,
        {
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private228::PhantomData<NotZeroUnsignedPartOfI32>,
                lifetime: _serde::__private228::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = NotZeroUnsignedPartOfI32;
                fn expecting(
                    &self,
                    __formatter: &mut Formatter<'_>,
                ) -> _serde::__private228::fmt::Result {
                    Formatter::write_str(__formatter, "tuple struct NotZeroUnsignedPartOfI32")
                }
                #[inline]
                fn visit_newtype_struct<__E>(self, __e: __E) -> Result<Self::Value, __E::Error>
                where
                    __E: Deserializer<'de>,
                {
                    let f0: i32 = <i32 as Deserialize>::deserialize(__e)?;
                    match NotZeroUnsignedPartOfI32::try_from(f0) {
                        Ok(v) => Ok(v),
                        Err(er) => Err(serde::de::Error::custom(format!("{er:?}"))),
                    }
                }
                #[inline]
                fn visit_seq<__A>(self, mut __seq: __A) -> Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let Some(f0) = _serde::de::SeqAccess::next_element::<i32>(&mut __seq)? else {
                        return Err(_serde::de::Error::invalid_length(
                            0usize,
                            &"tuple struct NotZeroUnsignedPartOfI32 with 1 el",
                        ));
                    };
                    match NotZeroUnsignedPartOfI32::try_from(f0) {
                        Ok(v) => Ok(v),
                        Err(er) => Err(serde::de::Error::custom(format!("{er:?}"))),
                    }
                }
            }
            Deserializer::deserialize_newtype_struct(
                __deserializer,
                "NotZeroUnsignedPartOfI32",
                __Visitor {
                    marker: _serde::__private228::PhantomData::<Self>,
                    lifetime: _serde::__private228::PhantomData,
                },
            )
        }
    }
};
impl ToErrString for NotZeroUnsignedPartOfI32 {
    fn to_err_string(&self) -> String {
        self.0.to_err_string()
    }
}
impl Type<Postgres> for NotZeroUnsignedPartOfI32 {
    fn compatible(ty: &<Postgres as Database>::TypeInfo) -> bool {
        <UnsignedPartOfI32 as Type<Postgres>>::compatible(ty)
    }
    fn type_info() -> <Postgres as Database>::TypeInfo {
        <UnsignedPartOfI32 as Type<Postgres>>::type_info()
    }
}
impl Encode<'_, Postgres> for NotZeroUnsignedPartOfI32 {
    fn encode_by_ref(
        &self,
        buf: &mut PgArgumentBuffer,
    ) -> Result<IsNull, Box<dyn StdErEr + Send + Sync>> {
        <UnsignedPartOfI32 as Encode<Postgres>>::encode_by_ref(&self.0, buf)
    }
}
impl NotZeroUnsignedPartOfI32 {
    #[must_use]
    pub const fn get(&self) -> i32 {
        self.0.get()
    }
}
impl DefaultOptSomeVecOneEl for NotZeroUnsignedPartOfI32 {
    fn default_opt_some_vec_one_el() -> Self {
        Self(DefaultOptSomeVecOneEl::default_opt_some_vec_one_el())
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, ToSchema, JsonSchema)]
pub enum SingleOrMultiple<T: Debug + PartialEq + Clone> {
    Multiple(NotEmptyUniqueVec<T>),
    Single(T),
}
pub fn incr_checked_add_one_returning_incr(incr: &mut u64) -> Result<u64, QueryPartEr> {
    incr.checked_add(1).map_or_else(
        || Err(QueryPartEr::CheckedAdd { loc: loc!() }),
        |v| {
            *incr = v;
            Ok(v)
        },
    )
}
#[must_use]
pub const fn i8_test_cases_vec() -> [i8; 3] {
    [i8::MIN, 0, i8::MAX]
}
#[must_use]
pub const fn i16_test_cases_vec() -> [i16; 3] {
    [i16::MIN, 0, i16::MAX]
}
#[must_use]
pub const fn i32_test_cases_vec() -> [i32; 3] {
    [i32::MIN, 0, i32::MAX]
}
#[must_use]
pub const fn i64_test_cases_vec() -> [i64; 3] {
    [i64::MIN, 0, i64::MAX]
}
#[must_use]
pub const fn u8_test_cases_vec() -> [u8; 3] {
    [u8::MIN, 0, u8::MAX]
}
#[must_use]
pub const fn u16_test_cases_vec() -> [u16; 3] {
    [u16::MIN, 0, u16::MAX]
}
#[must_use]
pub const fn u32_test_cases_vec() -> [u32; 3] {
    [u32::MIN, 0, u32::MAX]
}
#[must_use]
pub const fn u64_test_cases_vec() -> [u64; 3] {
    [u64::MIN, 0, u64::MAX]
}
#[must_use]
pub const fn f32_test_cases_vec() -> [f32; 18] {
    [
        f32::EPSILON,
        f32::MAX,
        f32::MIN,
        f32::MIN_POSITIVE,
        -1e30,
        -1e-30,
        -16_777_214.0,
        -100.0,
        -10.0,
        -1.0,
        -0.0,
        0.0,
        1.0,
        10.0,
        100.0,
        16_777_214.0,
        1e-30,
        1e30,
    ]
}
#[must_use]
pub const fn f64_test_cases_vec() -> [f64; 18] {
    [
        f64::EPSILON,
        f64::MAX,
        f64::MIN,
        f64::MIN_POSITIVE,
        -1e300,
        -1e-300,
        -9_007_199_254_740_990.0,
        -100.0,
        -10.0,
        -1.0,
        -0.0,
        0.0,
        1.0,
        10.0,
        100.0,
        9_007_199_254_740_990.0,
        1e-300,
        1e300,
    ]
}
#[must_use]
pub const fn bool_test_cases_vec() -> [bool; 2] {
    [true, false]
}
#[must_use]
pub fn string_test_cases_vec() -> [String; 12] {
    #[allow(clippy::non_ascii_literal)]
    [
        String::new(),
        "a".to_owned(),
        "Hello, world!".to_owned(),
        "   ".to_owned(),
        "\n\r\t".to_owned(),
        "1234567890".to_owned(),
        "".to_owned(),
        "".to_owned(),
        " Rust ".to_owned(),
        "a".repeat(1024),
        "line1\nline2\nline3".to_owned(),
        String::from_utf8_lossy(&[0xF0, 0x9F, 0x92, 0x96]).to_string(),
    ]
}
#[must_use]
pub fn uuid_uuid_test_cases_vec() -> [Uuid; 1] {
    [Uuid::new_v4()]
}
#[must_use]
pub fn wrap_into_jsonb_build_object(field: &str, value: &str) -> String {
    format!("jsonb_build_object('{field}',{value})||")
}
